def arrayPlay()
    puts "Sketching mode!"
    numbers = (1..100).to_a

    numbers.each_with_index do |n,index|
        puts "Item #{index}: #{n}"
    end
    puts "Sum of all terms in that array: #{numbers.inject(:+)}"
    puts "Sum of all letters in that array: #{"a".upto("z").inject(:+)}"
end

def ArraySets()

    fruits = ["apple", "banana", "orange", "strawberry", "tomato"]
    veggies = ["kale", "cucumber", "beets", "broccoli", "cauliflower", "tomato"]
    
    puts "Fruits and vegetables:"
    (fruits + veggies).each do |item|
        puts item
    end
    
    uniques = (fruits | veggies) # The pipe represents unique items in the arrays, just like sets
    repeat = veggies & fruits # & is the AND logical operator
    puts "Did you notice that there was a duplicate item? It's #{repeat}"
    puts "All the unique items are:"

    uniques.each do |item|
        puts item
    end
end 

class PentagonalNumberIterator
    include Enumerable
    GEN = lambda{|n| (n*((3*n)-1))/2}
    attr_accessor :num, :index
    def initialize
       self.index = 10
    end

    def each
        index.times do |i|
            yield GEN.call(i)
        end
    end

    def each_with_index
        yield num
        yield index
    end

    def next
        self.index += 1
        GEN.call(self.index)
    end
end

def iteratorPattern
    p = PentagonalNumberIterator.new
    p.each do |n|
       puts n
    end 
end

iteratorPattern
