#+TITLE: Emacs configuration file
#+AUTHOR: Auralcat
#+DATE: 2017:05:17

* Personal info
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Load from external file.
(load "~/.emacs.secrets")
  #+END_SRC

* Command history
  It's a good idea to save the previous commands' history, for a couple reasons:
  - Check the complex commands you use most often and improve your workflow
    based on that
  - Store cumbersome commands for specific situations that don't
    appear too often, but where this command saves your back (example
    in Ruby: extracting a variable inside "it" clause to a "let" block)
    #+BEGIN_SRC emacs-lisp :tangle yes
(savehist-mode 1)
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(setq savehist-file "~/file-bouncer/emacs-savehist")
(setq history-length 1024)
    #+END_SRC
* Bookmarks
  It's a quicker way to navigate through files you visit often.
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq bookmark-default-file "~/file-bouncer/bookmarks")
;; Every time bookmarks are changed, save them
(setq bookmark-save-flag 1)
  #+END_SRC
* Midnight mode
  Think of this as a kind of cron for Emacs. It runs a list of
  specified commands every "midnight". What constitutes a "midnight"
  can be defined by the user.
  The default action for ~midnight-hook~ is ~clean-buffer-list~
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package midnight
  :defer t
  :init
  (midnight-delay-set 'midnight-delay "10:30am")
  )
  #+END_SRC
* Evil Mode
  Yes, I'm committing this heresy
** Evil-leader
     Add a prefix key to Evil mode, like the Leader key in Vim.
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-leader
  :defer t)
(load "~/my-dotfiles/.emacs.d/elisp-custom/evil-leader-custom-functions.el")
(global-evil-leader-mode)
;; Evil mode needs to be loaded after evil-leader
(use-package evil
:defer t)
(evil-mode 1)

;; Load configs
(load "~/my-dotfiles/.emacs.d/evilrc")
     #+END_SRC
** Evil Surround
     Easier manipulation of delimiters, emulation of vim.surround
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-surround
:defer t)
(global-evil-surround-mode)
     #+END_SRC
** Custom text objects
*** Ruby Block
      Defines a text object for Ruby blocks.
      Credits: [[https://github.com/env0der][@env0der's dotfiles]]
      My modification is just the ~ruby-block-beg-re~ variable.
      #+BEGIN_SRC emacs-lisp :tangle yes
(evil-define-text-object evil-textobj-outer-ruby-block
  (count &optional beg end type)
  (evil-ruby-block-range beg end type count t))

(evil-define-text-object evil-textobj-inner-ruby-block
  (count &optional beg end type)
  (evil-ruby-block-range beg end type count nil))

(defun evil-ruby-block-range (count beg end type &optional inclusive)
  (let ((current-point (point))
        (block-begin (progn (evil-end-of-line) (re-search-backward ruby-block-beg-re nil t)))
        (block-end (progn (evilmi-jump-items) (point))))
    (if inclusive
        (let ((begin (progn (goto-char block-begin) (evil-beginning-of-line) (point)))
              (end (progn (goto-char block-end) (evil-next-line) (evil-beginning-of-line) (if (looking-at "^$") (+ (point) 1) (point)))))
          (progn
            (goto-char current-point)
            (evil-range begin end)))
      (let ((begin (progn (goto-char block-begin) (evil-next-line) (evil-first-non-blank) (point)))
            (end (progn (goto-char block-end) (evil-previous-line) (evil-end-of-line) (+ (point) 1))))
        (progn
          (goto-char current-point)
          (evil-range begin end))))))

(define-key evil-inner-text-objects-map "r" 'evil-textobj-inner-ruby-block)
(define-key evil-outer-text-objects-map "r" 'evil-textobj-outer-ruby-block)
      #+END_SRC
* Xref
This is quite useful to navigate through code faster.
#+BEGIN_SRC emacs-lisp :tangle yes
(evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
#+END_SRC

* Dired
  A couple customizations.
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq dired-listing-switches "-alh")
;; (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
;; (define-key dired-mode-map (kbd "^") (lambda () (find-alternate-file "..")))
;; Use Emacs mode in Dired.
(add-hook 'dired-mode-hook 'evil-emacs-state)
  #+END_SRC

* Macros
  #+BEGIN_SRC emacs-lisp :tangle yes
;; To save a macro, record it with C-x ( (start) and C-x ) (stop),
;; give it a name with C-x C-k n (C-k is for maKro) and
;; insert it in this file with insert-kbd-macro.
;; Then you execute it mapping it to a key!

;; This package allows you to override a couple functions.
(use-package noflet
:defer t)
(lambda (&optional arg) "Extracts a variable from an it clause and puts in a let statement." (interactive "p") (kmacro-exec-ring-item (quote ([100 100 134217745 134217729 112 99 87 108 101 116 40 58 25 escape 102 61 50 120 67 123 25 escape 86 61 15 15 48 119] 0 "%d")) arg))

;; Adds a byebug line to Ruby code
(fset 'auralcat/ruby/add-byebug-line
      (kmacro-lambda-form [?O ?b ?y ?e ?b ?u ?g escape return] 0 "%d"))

(fset 'auralcat/ruby-clone-method
      (lambda (&optional arg) "Clones a def method in Ruby." (interactive "p") (kmacro-exec-ring-item (quote ([86 125 121 103 118 escape 112] 0 "%d")) arg)))

(fset 'auralcat/search-git-conflict-string
      (lambda (&optional arg) "Searches for a Git conflict string." (interactive "p") (kmacro-exec-ring-item (quote ([134217747 94 91 60 61 62 93 13] 0 "%d")) argumento)))

(fset (quote sample-macro)
      (lambda (&optional arg) "Sample description" (interactive "p")
        (undo-boundary)
        (noflet ((undo-boundary ()))
          (kmacro-exec-ring-item (quote ([100 87 65 32 35 32 65 110 111 116 104 101 114 32 109 97 99 114 111 32 99 97 108 108 46 escape 134217730 return 112 45] 0 "%d")) arg)
          )
        (undo-boundary)
        ))

;; Some macros to adjust Ruby blocks
(fset 'auralcat/ruby-move-defun-backward
      (lambda (&optional arg) "Moves a DEF block backwards in the class definition." (interactive "p")
        (undo-boundary)
        (noflet ((undo-boundary ()))
          (kmacro-exec-ring-item (quote ([26 167772166 23 134217820 16 4 134217820 4 2 134217730 16 return 25 return 134217730 26] 0 "%d")) arg)
          )
        (undo-boundary)
        ))

(fset 'auralcat/ruby-move-block-forward
      (lambda (&optional arg) "Moves a Ruby block forward in the current nesting level." (interactive "p")
        (undo-boundary)
        (noflet ((undo-boundary ()))
          (kmacro-lambda-form [?\C-z ?\C-  ?\C-\M-n ?\C-e ?\C-w ?\C-\M-n ?\C-m ?\C-/ ?\C-e ?\C-m ?\C-m ?\C-y ?\C-u ?\C-  ?\C-  ?\C-k ?\C-k ?\C-i ?\C-z] 0 "%d")
          )
        (undo-boundary)
        )
      )

;; Removes a Ruby block wrapping another block.
(fset 'auralcat/ruby-block-vanish
      (kmacro-lambda-form [?m ?m ?% ?d ?d ?\' ?m ?d ?d ?\C-x ?\C-x ?=] 0 "%d"))

;; Sends a region to the *shell* buffer
(fset 'auralcat/sh-send-region
      (kmacro-lambda-form [?\M-w ?  ?$ ?\C-y return ?\M-o] 0 "%d"))

;; Sends a line to the *shell* buffer
(fset 'auralcat/sh-send-line
      (kmacro-lambda-form [?\C-z ?\C-a ?\S-\C-e ?\M-w ?\C-z ?  ?$ ?\C-y return ?\M-o] 0 "%d"))

;; Filter news with deceased or age headlines in Gnus feed.
;; It inserts the "[Aa]os [[:digit:]]+ anos" regexp in the filter minibuffer.
(fset 'auralcat/gnus-limit-to-age-headlines
      (kmacro-lambda-form [?/ ?/ ?\[ ?A ?a ?\C-e ?o ?s ?  ?\[ ?\[ ?: ?d ?i ?g ?i ?t ?: ?\C-e ?+ ?  ?a ?n ?o ?s return] 0 "%d"))

;; Remove links in an Org entry
(fset 'auralcat/org-remove-link
      (kmacro-lambda-form [?d ?s ?\] ?d ?f ?\] ?d ?s ?\]] 0 "%d"))
  #+END_SRC

** Elixir
#+BEGIN_SRC emacs-lisp :tangle yes
;; Changes a one-line function like:
;; def something(foo), do: "yay!"
;;
;; to:
;;
;; def something(foo) do
;;   "yay!"
;; end
(fset 'auralcat/elixir-change-one-line-function-to-multiline
      (kmacro-lambda-form [?f ?: ?F ?, ?x ?E ?x ?i return escape ?o ?e ?n ?d return escape ?\M-a return] 0 "%d"))

;; Calls IEx.pry in the line above the cursor.
(fset 'auralcat/elixir-iex-pry
      (kmacro-lambda-form [?O ?r ?e ?q ?u ?i ?r ?e ?  ?I ?E ?x ?\; ?  ?I ?E ?x ?. ?p ?r ?y escape] 0 "%d"))
#+END_SRC

* Mac OS
  #+BEGIN_SRC emacs-lisp :tangle yes
(when (eq system-type 'darwin) ;; mac specific settings
  ;; Use bigger fonts because of that Retina display
  (if (member "Fantasque Sans Mono" (font-family-list))
      (set-face-attribute (quote default) nil :font "Fantasque Sans Mono" :height 140)
    (set-face-attribute (quote default) nil :font "Monaco" :height 120))
  ;; Map Command to Meta
  (setq mac-command-modifier 'meta)
  ;; Map Option to Control (I know, smaller key, that's what we have for now. :/)
  (setq mac-option-modifier 'control)
  ;; Map Control key in OS X to Super
  (setq mac-control-modifier 'super)
  ;; Map Fn key in OS X to Hyper
  (setq ns-function-modifier 'hyper)
  ;; Point the executables in Mac OS to Emacs.
  (add-to-list 'exec-path "/usr/local/bin/")
  ;; Enable EPA
  (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))

  ;; Use Emacsclient in OS X
  (setq server-socket-dir (format "/tmp/emacs%d" (user-uid))))
  #+END_SRC
* Environment Customizations
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Make startup faster by reducing the frequency of garbage
;; collection.  The default is 0.8MB.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))
;; Portion of heap used for allocation.  Defaults to 0.1.
(setq gc-cons-percentage 0.6)

;; Sentences end with single spaces for me.
(setq sentence-end-double-space nil)

;; Set locale to Brazilian Portuguese
(set-locale-environment "pt_BR.UTF-8")

;; Change window title
(setq frame-title-format '("Emacs 26"))

;; A small performance improvement
(setq redisplay-dont-pause t)

;; Since I work only with left-to-right languages, we can set it like this.
(setq bidi-paragraph-direction 'left-to-right)
(if (version<= "27.1" emacs-version)
    (setq bidi-inhibit-bpa t))

;; I don't like lockfiles
(setq create-lockfiles nil)

;; Store all backups in a specific folder:
(setq backup-directory-alist `(("." . "~/file-bouncer/emacs-backups")))

;; Manual packages load path
(add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-themes/")
(add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-packages/")

;; Manual Elisp scripts load path
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/elisp-custom")

;; Backup files by copying them
(setq backup-by-copying t)

;; I'm too lazy to type "yes" or "no"
(fset 'yes-or-no-p 'y-or-n-p)

;; Clean whitespace before saving a file
(add-hook 'before-save-hook 'whitespace-cleanup)

;; While you're at it, save automatically when visiting files.
;; It's surprisingly useful. The only caveat is when you got an
;; open comment like this. It will remove all the whitespace.
;; It saves the file after 5 seconds of inactivity.
(auto-save-visited-mode t)

;; Allow only one theme at a time
(setq custom-theme-allow-multiple-selections nil)

;; Enable ido-mode (fewer keystrokes to switch buffers!)
(ido-mode 1)

;; Easier mark cycling, both local and global
(setq set-mark-command-repeat-pop t)

;; ido-mode in the minibuffer
(icomplete-mode 1)

;; Replace the built-in buffer menu with ibuffer
(global-set-key [24 2] (quote ibuffer))

;; Prevent the scratch buffer from being killed
(with-current-buffer "*scratch*"
  (emacs-lock-mode 'kill))

;; Enable auto-revert-mode
(global-auto-revert-mode t)

;; Remove the menu bar in terminal mode
(when (not (display-graphic-p))
  (menu-bar-mode -1))

;; Use Bash as default shell interpreter
(setq org-babel-sh-command "/bin/bash")
;; Get Emacs to understand your aliases
;; (setq shell-file-name "bash")
;; For reference, this is the default value:
;; (setq shell-command-switch "-c")
;; (setq shell-command-switch "-ic")

;; Activate Company mode
(add-hook 'after-init-hook 'global-company-mode)

;; Enable global Abbrev mode
(setq-default abbrev-mode t)

;; Save last edited place in files
(require 'saveplace)
(setq-default save-place t)

;; I need a bigger kill ring.
(setq kill-ring-max 180)

;; Use recentf-mode
(recentf-mode)
  #+END_SRC
* REPL
We need to do some customizations to comint-related buffers to improve performance.
#+BEGIN_SRC emacs-lisp :tangle yes
;; I prefer Emacs state in comint-related buffers.
(evil-set-initial-state 'comint-mode 'emacs)

(defun comint-mode-tweaks ()
  ;; Font-lock is the one that takes the biggest toll on performance.
  (font-lock-mode -1)
  (auto-composition-mode -1)
  (auto-compression-mode -1)
  (column-number-mode -1)
  (auto-save-visited-mode -1)
  )

(add-hook 'comint-mode-hook 'comint-mode-tweaks)
#+END_SRC

* Abbreviations
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq abbrev-file-name "~/.abbrev_defs")
  #+END_SRC
* Hooks
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Prog-mode is from where all the programming modes are derived from.
;; This means that if you call prog-mode-hook, the settings will be
;; applied to ALL programming modes in Emacs.

(defun prog-mode-tweaks ()
  ;; Set line number mode and column number mode for code files
  (if (< (string-to-number emacs-version) 24)
      (line-number-mode 1)
    (display-line-numbers-mode))
  (setq fill-column 80)
  )
(add-hook 'prog-mode-hook 'prog-mode-tweaks)
(add-hook 'text-mode-hook 'column-number-mode)

;; Create filling for org-mode
(add-hook 'org-mode-hook 'auto-fill-mode)
  #+END_SRC
* Packages
** Major Modes
*** Compilation mode tweaks
This is a built-in mode, but I want to change some stuff there.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun compilation-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1))

(add-hook 'compilation-mode-hook 'compilation-mode-tweaks)
#+END_SRC
*** Elixir-mode
    Elixir support for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package elixir-mode
:defer t)
    #+END_SRC
*** Sass-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package sass-mode
  :defer t
  ;; Set Sass mode for SASS files and Css mode for SCSS files.
  :init
  (add-to-list 'auto-mode-alist
               '("\\.sass\\'" . sass-mode)))

    #+END_SRC
*** SCSS-mode
    Major mode for SCSS files, together with Sass.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package scss-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist
               '("\\.scss\\'" . scss-mode)))
    #+END_SRC
*** Nov-mode
This is a mode for reading .epub files.
It's quite comfortable when you want to read longform books in the computer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  ;; Set the width to 80 chars, this is better to read.
  (setq nov-text-width 80)
  ;; Remove the mode line in the book's buffer.
  (add-hook 'nov-mode-hook #'(lambda () (setq-local mode-line-format nil))))
#+END_SRC
*** Makefile-mode
I'm working with Makefiles now, so this is useful.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'makefile-mode-hook #'(lambda () (setq-local indent-tabs-mode t)))
#+END_SRC
*** Js2-mode
    A better default Javascript mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package js2-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.js?\\'" . js2-mode))
  (setq js-indent-level 2))

;; TODO: Look for a better completion for JS modes in Company.
(defun js2-mode-tweaks ()
  ;; Use company-yas as main backend
  (set (make-local-variable 'company-backends) '(company-etags company-yasnippet))
  (company-mode t))

(add-hook 'js2-mode-hook 'js2-mode-tweaks)

;; Set syntax highlight level
(setq js2-highlight-level 3)
    #+END_SRC

*** PHP-mode
    PHP support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package php-mode
  :defer t
  :config
  (add-hook 'php-mode-hook (lambda() (add-to-list 'company-backends 'company-php))))
    #+END_SRC
*** Enhanced-ruby-mode
    A better ruby-mode.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package enh-ruby-mode
  :defer t)

;; No magic comments, please.
(setq enh-ruby-add-encoding-comment-on-save nil)
(setq ruby-insert-encoding-magic-comment nil)

;; ;; Set it as default mode for Ruby files
;; (add-to-list 'auto-mode-alist
;; '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
;; . enh-ruby-mode))

;; Fallback to vanilla Ruby mode when things go bad
(add-to-list 'auto-mode-alist
             '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
               . ruby-mode))

;; (define-key enh-ruby-mode-map (kbd "M-<down>") 'auralcat/ruby-move-defun-forward)
;; (define-key enh-ruby-mode-map (kbd "M-<up>") 'auralcat/ruby-move-defun-backward)

;; (define-key ruby-mode-map (kbd "M-<down>") 'auralcat/ruby-move-defun-forward)
;; (define-key ruby-mode-map (kbd "M-<up>") 'auralcat/ruby-move-defun-backward)
    #+END_SRC
*** Web Mode
    I use this for HTML files mostly, works good for PHP too.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode
  :ensure t
  :defer t
  :bind (:map web-mode-map
              ("C-<up>"    . web-mode-element-previous)
              ("C-<down>"  . web-mode-element-next)
              ("C-<left>"  . web-mode-element-beginning)
              ("C-<right>" . web-mode-tag-match)
              ("C-S-<up>"  . web-mode-element-parent)
              ("M-<up>"    . web-mode-element-content-select)
              ("C-k"       . web-mode-element-kill)
              ("M-RET"     . complete))

  :init
  ;; File associations
  (add-to-list 'auto-mode-alist '("\\.phtml\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html.erb\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html.eex\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.vue?\\'"   . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx?\\'"  . web-mode))

  ;; Engine associations
  (setq web-mode-engines-alist
        '(("php"    . "\\.phtml\\'")
          ("blade"  . "\\.blade\\.")))

  ;; Highlight tag when editing
  (setq web-mode-enable-current-element-highlight t))

    #+END_SRC
*** YAML-mode
    YAML support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t
  :defer t)
    #+END_SRC
*** CSV-mode
    CSV support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package csv-mode
  :defer t)
    #+END_SRC
*** APIB-mode
Necessary for parsing apib files (API Blueprint)
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package apib-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.apib?\\'"   . apib-mode)))
#+END_SRC
*** Typescript mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package typescript-mode
  :defer t)
#+END_SRC

** Minor Modes
*** JS-comint
    Open a REPL using Node.js in another buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package js-comint
:defer t)

;; Call the REPL with C-c C-s in js2-mode
;; (define-key js2-mode-map (kbd "C-c C-s") 'run-js)

;; Send last JS expression to REPL
;; (define-key js2-mode-map (kbd "C-x C-e") 'js-send-last-sexp)
    #+END_SRC
*** Flycheck Inline
    Shows the error when leaving the point over the place where it occurs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-inline
  :defer t
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
    #+END_SRC
*** Ruby-electric
    Auto-close do-end blocks, as well as braces and parens.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ruby-electric
  :defer t
  :diminish ruby-electric-mode
  :config
  (add-hook 'enh-ruby-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )
  (add-hook 'ruby-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )
  (add-hook 'enh-ruby-mode-hook 'ruby-electric-mode)
  (add-hook 'ruby-mode-hook 'ruby-electric-mode))
    #+END_SRC
*** Inf-elixir
Utility around Elixir's REPL in Emacs.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package inf-elixir
  :after (elixir-mode)
  :ensure t
  :defer t
  :init
  ;; Bindings for inf-elixir-mode
  (define-key elixir-mode-map (kbd "C-c C-l") 'inf-elixir-send-line)
  (define-key elixir-mode-map (kbd "C-c C-r") 'inf-elixir-send-region))
#+END_SRC
*** Mix
A wrapper around Elixir's ~mix~ for Emacs
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mix
  ;; I prefer creating a prefix for these commands because it's 2 key presses
  ;; instead of 3 with evil-leader.
  :config
  (define-prefix-command 'elixir-mix-map)
            (define-key 'elixir-mix-map "t" 'mix-test)
            (define-key 'elixir-mix-map (kbd "SPC") 'mix-test-current-buffer)
            (define-key 'elixir-mix-map "." 'mix-test-current-test)
            (define-key 'elixir-mix-map "c" 'mix-compile)
            (define-key 'elixir-mix-map "x" 'mix-execute-task)
            (define-key 'elixir-mix-map (kbd "C-,") 'mix-last-command))

  (add-hook 'elixir-mode-hook '(lambda ()
                                 (local-set-key (kbd "C-,") 'elixir-mix-map)))
#+END_SRC

*** Projectile
    Manage projects in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :defer t
  :init
  (setq projectile-keymap-prefix (kbd "C-c p"))
  ;; I use Universal ctags, so this needs some adjustment.
  (setq projectile-tags-command "ctags -eR ."))

;; Enable it
(add-hook 'after-init-hook #'projectile-global-mode)
    #+END_SRC
*** Autopair
    Automatically pair braces and quotes like in TextMate
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package autopair
  :after (prog-mode)
  :defer t
  :init (autopair-global-mode))
    #+END_SRC
*** Emmet-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package emmet-mode
  :after (:any web-mode sass-mode scss-mode)
  :defer t)
    #+END_SRC
*** Highlight-numbers mode
    Sets font lock faces to numbers in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-numbers
  :after (prog-mode)
  :defer t
  :config
  (add-hook 'prog-mode-hook 'highlight-numbers-mode))
    #+END_SRC
*** Flyspell
    Used to check prose.
    I use Markdown to write stuff in English.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flyspell
  :defer t
  :config
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)

  (add-hook 'git-commit-mode-hook 'flyspell-mode))
    #+END_SRC

*** Flycheck
    Syntax checker, replaces flymake
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :defer t
  :config
  ;; turn on flychecking globally
  (add-hook 'after-init-hook #'global-flycheck-mode))
;; Disable rubylint on default for Ruby modes.
;; If you need it, you can enable it locally using C-u C-c ! v.
(defun custom-disabled-ruby-checkers ()
  (add-to-list 'flycheck-disabled-checkers 'ruby-rubylint))
(add-hook 'enh-ruby-mode-hook 'custom-disabled-ruby-checkers)
(add-hook 'ruby-mode-hook 'custom-disabled-ruby-checkers)
    #+END_SRC

*** Helm
    Incremental completion and selection narrowing framework
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm
:defer t
:config
(require 'helm-config)
(helm-mode 1)

;; Bind the keys I want:
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "Â»") 'helm-M-x)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-x b") 'helm-mini)

;; Enable fuzzy matching
(setq helm-M-x-fuzzy-match t)

;; Use Helm for Projectile completion
(setq projectile-completion-system 'helm))
    #+END_SRC

*** Ace Window
    Switch between more than 3 windows (and act on them!) with ease.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-window
  :defer t
  :init
  ;; All you need to do is just give a keybinding to the main command.
  (global-set-key (kbd "M-o") 'ace-window))
    #+END_SRC

*** Company
**** Main Config
     *COMPlete ANYthing* inside Emacs.
     I switched to it because it works in GUI Emacs and ~auto-complete~ didn't at the time.
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :defer t
  :config
  ;; My standard Company configuration
  (setq company-tooltip-limit 20)
  (setq company-show-numbers t)
  (setq company-idle-delay 0)
  (setq company-echo-delay 0))

;; Web-mode needs HTML and CSS completions.
;; JS is not satisfactory at this point IMO
(defun web-mode-tweaks ()
  (require 'company-web-html)
  (set (make-local-variable 'company-backends) '(company-web-html company-css))
  (emmet-mode 1)
  (company-mode t))

;; Completion for Ruby mode
(defun ruby-mode-tweaks ()
  ;; Increase the min prefix length so it doesn't clash with most used keywords, like def.
  (set (make-local-variable 'company-minimum-prefix-length) 4)
  (set (make-local-variable 'company-backends) '(company-etags company-capf company-dabbrev company-yasnippet))
  (subword-mode 1))

;; Completion for REPL Ruby mode
(defun inf-ruby-mode-tweaks ()
  (set (make-local-variable 'company-minimum-prefix-length) 2)
  (set (make-local-variable 'company-backends) '(company-capf company-etags company-dabbrev company-yasnippet))
  (subword-mode 1))

;; General text writing completion (uses dabbrev and filename completion)
(defun human-language-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-dabbrev company-capf company-files))
  ;; If you write a word with 3 letters, it's better to use 'complete, I think.
  ;; Company-mode is meant for longer words and those with hard spelling IMO.
  (set (make-local-variable 'company-minimum-prefix-length) 4)
  (setq fill-column 80))

;; Shell completion
(defun shell-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-capf company-files)))

;; Elisp completion
(defun elisp-tweaks ()
  (set (make-local-variable 'company-minimum-prefix-length) 5)
  (set (make-local-variable 'company-backends) '(company-elisp company-etags company-yasnippet)))

;; Add tweaks
(add-hook 'enh-ruby-mode-hook 'ruby-mode-tweaks)
(add-hook 'inf-ruby-mode-hook 'inf-ruby-mode-tweaks)
(add-hook 'ruby-mode-hook 'ruby-mode-tweaks)
(add-hook 'elixir-mode-hook 'ruby-mode-tweaks)
(add-hook 'shell-mode-hook 'shell-mode-tweaks)
(add-hook 'emacs-lisp-mode-hook 'elisp-tweaks)
(add-hook 'ielm-mode-hook 'elisp-tweaks)

;; Human language writing hooks
(add-hook 'org-mode-hook 'human-language-mode-tweaks)
(add-hook 'markdown-mode-hook 'human-language-mode-tweaks)

(add-hook 'org-mode-hook 'variable-pitch-mode)
(add-hook 'markdown-mode-hook 'variable-pitch-mode)
(add-hook 'git-commit-setup-hook 'variable-pitch-mode)

;; Apib mode should come with its own customizations:
;; - Monospace fonts
;; - No auto-fill
;; - Line numbers on the side
(add-hook 'apib-mode-hook #'(lambda ()
                              (variable-pitch-mode 0)
                              (auto-fill-mode 0)
                              (display-line-numbers-mode 0)))

;; Web-mode completions
(use-package company-web
  :after (:all company-mode web-mode)
  :defer t)

;; Company statistics package
(use-package company-statistics
  :after (company-mode)
  :defer t
  :config
(company-statistics-mode))

;; Company with prescient.el offers better sorting of completion candidates.
;; I don't know if it clashes with company-statistics.
(use-package company-prescient
  :after (company-mode)
  :defer t
  :config
  (company-prescient-mode))
     #+END_SRC
*** Keyfreq
    Shows most used commands in editing session.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package keyfreq
  :config
  ;; Ignore arrow commands and self-insert-commands
  (setq keyfreq-excluded-commands
        '(self-insert-command
          org-self-insert-command
          weechat-self-insert-command
          vterm--self-insert
          abort-recursive-edit
          company-ignore
          ))

  ;; Activate it
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
    #+END_SRC
*** Diminish
    Free some space in the mode line removing superfluous mode indications.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  :ensure t
  :defer t
  ;; These are loaded at startup, I prefer declaring everything here.
  :diminish flycheck-mode
  :diminish projectile-mode
  :diminish helm-mode
  :diminish company-mode
  :diminish auto-revert-mode
  :diminish auto-fill-mode
  :diminish abbrev-mode
  :diminish autopair-mode)
;; These are loaded in other moments
(eval-after-load "editorconfig" '(diminish 'editorconfig-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
    #+END_SRC
*** Ace Jump
    Allows you to move anywhere in the visible portion of the buffer
    using 2 keystrokes.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-jump-mode
  :after (evil)
  :bind ("C-x j" . ace-jump-mode)
  :config
;; Save the position of the previous mark as a jump position for Evil.
;; With that, we can cycle through where ace-jump was called from using C-i and C-o.
(defadvice ace-jump-mode (before ace-jump-mode-advice)
  (evil--jumps-push))
(ad-activate 'ace-jump-mode))

    #+END_SRC

*** Editorconfig
    Helps developers define and maintain consistent coding styles
    between different editors and IDEs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :after (prog-mode)
  :ensure t
  :defer t
  :config
  (editorconfig-mode 1))
    #+END_SRC
*** Nyan-mode
    Put a Nyan Cat in your mode line! :3
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package nyan-mode
  :defer t
  :config
  (nyan-mode 1))
    #+END_SRC
*** Mode Icons
    Indicate modes in the mode line using icons
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package mode-icons
  :defer t
  :init
  (mode-icons-mode))
    #+END_SRC
*** Emojify
    Add emoji support for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package emojify
  :hook ((org-mode org-agenda-mode) . 'emojify-mode))
    #+END_SRC
** Utilities
*** Zoom window
Zooms a window just like in Tmux.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package zoom-window)
#+END_SRC
*** Notmuch
Read mail inside Emacs!
This is great for opensource projects and work.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package notmuch
  :defer t
  :config
  (defun my-notmuch-show-view-as-patch ()
    "View the the current message as a patch."
    (interactive)
    (let* ((id (notmuch-show-get-message-id))
           (msg (notmuch-show-get-message-properties))
           (part (notmuch-show-get-part-properties))
           (subject (concat "Subject: " (notmuch-show-get-subject) "\n"))
           (diff-default-read-only t)
           (buf (get-buffer-create (concat "*notmuch-patch-" id "*")))
           (map (make-sparse-keymap)))
      (define-key map "q" 'notmuch-bury-or-kill-this-buffer)
      (switch-to-buffer buf)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert subject)
        (insert (notmuch-get-bodypart-text msg part nil)))
      (set-buffer-modified-p nil)
      (diff-mode)
      (lexical-let ((new-ro-bind (cons 'buffer-read-only map)))
        (add-to-list 'minor-mode-overriding-map-alist new-ro-bind))
      (goto-char (point-min))))
  (define-key 'notmuch-show-part-map "d" 'my-notmuch-show-view-as-patch))
#+END_SRC
*** Vterm
It is a full-fledged terminal emulator inside Emacs. It uses ~libvterm~, which
is a C library, so it maintains compatibility between all CLI applications, and
you can use them without problems from inside Emacs.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun vterm-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-capf company-files))
  (evil-set-initial-state 'vterm-mode' emacs))

(use-package vterm
  :hook ((vterm-mode) . 'vterm-mode-tweaks)
  :config
  (setq vterm-use-vterm-prompt-detection-method t))
#+END_SRC
*** Exec path from shell
  Replicates terminal env vars in graphical Emacs.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :defer t
  :init
  (exec-path-from-shell-initialize))
  #+END_SRC
*** Git-Link
Create links to Github/GitLab files from the comfort of your Emacs buffer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-link
  :defer t)
#+END_SRC
*** IEdit
*I* nteractive *Edit*. This helps with interactive search and replace in a file.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package iedit
  :after (prog-mode)
  :ensure t
  :bind (:map prog-mode-map
              ("C-;". iedit-mode)))
#+END_SRC

*** Smartparens
This works better than Autopair for Elixir mode.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :after (elixir-mode)
  :init
  ;; Do not activate autopair for Elixir-related modes if we're using smartparens.
  (add-hook 'elixir-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )
  (add-hook 'inf-elixir-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )

  (add-hook 'elixir-mode-hook #'smartparens-mode)
  (add-hook 'inf-elixir-iex-mode-hook #'smartparens-mode)
  :config
  (require 'smartparens-config))
#+END_SRC

*** Prettier.js
    Prettier.js integration for Emacs.
    I want to run this thing when saving .js and web-related files.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package prettier-js
  :after (:any js2-mode sass-mode css-mode scss-mode)
  :hook ((js2-mode sass-mode scss-mode css-mode) . 'prettier-js-mode)
  :config
  (setq prettier-js-allowed-modes '(js2-mode sass-mode css-mode scss-mode))

  (defun toggle-prettier-js-save-hook ()
    "Toggles Prettier.js hook when you're working with a mode that supports it. Removes the hook otherwise."
    (if (member major-mode prettier-js-allowed-modes)
        (add-hook 'before-save-hook 'prettier-js)
      (remove-hook 'before-save-hook 'prettier-js)))
  (add-hook 'change-major-mode-hook 'toggle-prettier-js-save-hook))
    #+END_SRC
*** Origami-mode
    Code folding in Emacs. You can use this with Evil by pressing z a
    in normal-mode.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package origami
  :defer t
  :config
  ;; Activate it
  (global-origami-mode))
    #+END_SRC
*** Slack Client
    Run a Slack client inside Emacs. Surprisingly useful at work!
    Credits for the customizations below: [[http://endlessparentheses.com/mold-slack-entirely-to-your-liking-with-emacs.html][Endless Parentheses]]
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package slack
  :defer t
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
  (setq slack-prefer-current-team t)
  :config
  ;; Get my teams.
  (load "~/.slack-teams.el")

  ;; Set abbrevs from org-mode
  (abbrev-table-put slack-mode-abbrev-table
                    :parents (list org-mode-abbrev-table))

  (abbrev-table-put slack-thread-message-buffer-mode-abbrev-table
                    :parents (list slack-mode-abbrev-table))

  (abbrev-table-put slack-message-compose-buffer-mode-abbrev-table
                    :parents (list slack-mode-abbrev-table))

  ;; Expand abbrevs when pressing Enter in Slack modes (it's derived from lui-mode)
  (advice-add #'lui-send-input :before
              (lambda (&rest _)
                (ignore-errors (expand-abbrev))))

  ;; Define the keybindings for Slack-related modes.
  (evil-define-key 'normal slack-info-mode-map
    ",u" 'slack-room-update-messages)
  (evil-define-key 'normal slack-mode-map
    "Q" 'bury-buffer
    ",c" 'slack-buffer-kill
    ",ra" 'slack-message-add-reaction
    ",rr" 'slack-message-remove-reaction
    ",rs" 'slack-message-show-reaction-users
    ",pl" 'slack-room-pins-list
    ",pa" 'slack-message-pins-add
    ",pr" 'slack-message-pins-remove
    ",mm" 'slack-message-write-another-buffer
    ",me" 'slack-message-edit
    ",md" 'slack-message-delete
    ",u" 'slack-room-update-messages
    ",2" 'slack-message-embed-mention
    ",3" 'slack-message-embed-channel
    "\C-n" 'slack-buffer-goto-next-message
    "\C-p" 'slack-buffer-goto-prev-message)
  (evil-define-key 'normal slack-edit-message-mode-map
    ",k" 'slack-message-cancel-edit
    ",s" 'slack-message-send-from-buffer
    ",2" 'slack-message-embed-mention
    ",3" 'slack-message-embed-channel)
  (evil-define-key 'normal slack-thread-message-buffer-mode-map
    "Q" 'bury-buffer))

;; We need to define a hook for this thin

(defun auralcat/slack-shorten-room-names ()
  "Shortens the room name in Slack buffers."
  (cl-defmethod slack-buffer-name ((this slack-message-buffer))
    (slack-if-let* ((team (slack-buffer-team this))
                    (room (slack-buffer-room this))
                    (room-name (slack-room-name room team)))
                   room-name))
  )

(add-hook 'slack-mode-hook 'auralcat/slack-shorten-room-names)
    #+END_SRC

**** Notifications customization
     #+BEGIN_SRC emacs-lisp :tangle yes
;; Channels
(setq slack-message-notification-title-format-function
      (lambda (_team room threadp)
        (concat (if threadp "Thread in #%s") room)))

(defun endless/-cleanup-room-name (room-name)
  "Make group-chat names a bit more human-readable."
  (replace-regexp-in-string
   "--" " "
   (replace-regexp-in-string "#mpdm-" "" room-name)))

       ;;; Private messages and group chats
(setq slack-message-im-notification-title-format-function
      (lambda (_team room threadp)
        (concat (if threadp "Thread in %s")
                (endless/-cleanup-room-name room))))

;; Custom notifications
(load "~/.slack-custom-notifications.el")
     #+END_SRC
**** Autocompletion
     #+BEGIN_SRC emacs-lisp :tangle yes
;; Use company-slack to complete usernames in Slack modes
(defun slack-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-slack-backend company-dabbrev company-files))
  (set (make-local-variable 'company-minimum-prefix-length) 3)
  )

(add-hook 'slack-message-buffer-mode-hook 'slack-mode-tweaks)
(add-hook 'slack-message-compose-buffer-mode-hook 'slack-mode-tweaks)
(add-hook 'slack-message-edit-buffer-mode-hook 'slack-mode-tweaks)
(add-hook 'slack-thread-message-buffer-mode-hook 'slack-mode-tweaks)

;; Disable auto-fill-mode
(add-hook 'slack-mode-hook 'turn-off-auto-fill)
     #+END_SRC
*** Golden Ratio Mode
    Splits windows using the [[https://en.wikipedia.org/wiki/Golden_ratio][Golden Ratio]].
    This makes the focused window a bit larger than usual and the
    smaller ones are easier to read. It makes the multi-window
    experience more pleasing to the eye. Yeah, nature!
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package golden-ratio
  :diminish golden-ratio-mode
  :config
  ;; Get golden-ratio to work with ace-window
  (setq golden-ratio-extra-commands
        (append golden-ratio-extra-commands '(magit-status ace-window aw-flip-window)))
  (golden-ratio-mode 1))
    #+END_SRC

*** Docker
    A Docker command wrapper for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package docker
  :defer t
  :config
  ;; Extra stuff Docker needs on Mac OS X
  (when (eq system-type 'darwin)
    (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
    (setq exec-path (append exec-path '("/usr/local/bin"))))

  ;; Set the Docker command for me, please.
  (setq docker-command (string-trim (shell-command-to-string "command -v docker"))))
    #+END_SRC

*** Projectile Rails
    Rails utilities for Projectile-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile-rails
  :after (projectile)
  :defer t
  :init
  (add-hook 'ruby-mode-hook 'projectile-rails-mode)
  (add-hook 'enh-ruby-mode-hook 'projectile-rails-mode)

  (evil-leader/set-key-for-mode 'ruby-mode "r" 'projectile-rails-command-map))
    #+END_SRC
*** Projectile Phoenix
I made this package! <3
It helps in working with Phoenix projects.
Since it's not published in MELPA yet, we need to load it directly from the git
repository.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path "~/projectile-phoenix/")
(load "projectile-phoenix")

(projectile-phoenix-global-mode)

;; Configure the binding for Phoenix project buffers
(add-hook 'find-file-hook #'(lambda ()
                              (when (projectile-phoenix-project-p)
                                (evil-leader/set-key "r" 'projectile-phoenix-command-map))))
#+END_SRC
*** Bundler
    Interact with Bundler from Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package bundler
  :defer t)
    #+END_SRC
*** Evil-numbers
    Increment and decrement numbers like in Vim.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-numbers
  :after (evil)
  :defer t
  :config
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-e") 'evil-numbers/dec-at-pt))
    #+END_SRC

*** Diff-Highlight
    Highlights the changed content in buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :ensure
  :defer t
  :config
  ;; ((defun hl-diff-tweaks()
  ;;   (diff-hl-mode t)
  ;;   (diff-hl-flydiff-mode t))
  ;;   (add-hook 'prog-mode-hook 'hl-diff-tweaks))
  )
    #+END_SRC
*** Evil-Matchit
    Adds more matching objects for the % operator in evil, such as
    def-end in Ruby/Python and HTML tags.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-matchit
  :after (evil)
  :defer t
  :ensure t
  :init
  (global-evil-matchit-mode 1))
    #+END_SRC
*** Writeroom Mode
    Dims the modeline, perfect for focusing on writing text/code
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package writeroom-mode
  :ensure t
  :defer t)
;; Activate it manually, it doesn't play well with Moe modeline globally
    #+END_SRC
*** Restart Emacs
    Restart Emacs from within Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package restart-emacs
  :defer t)
    #+END_SRC
*** Helm-projectile
    Browse through Projectile commands using Helm.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm-projectile
  :after (:all helm projectile)
  :defer t
  :config
  ;; Activate it.
  (helm-projectile-on))
    #+END_SRC
*** Rainbow Delimiters
    Highlight parentheses, brackets and braces according to their
    depth.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :after (prog-mode)
  :defer t
  :init
  ;; Add this to prog-mode
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'slime-repl-mode-hook #'rainbow-delimiters-mode))
    #+END_SRC
*** Git Gutter
    Shows (and enables you to navigate between) parts of the code
    which where changed comparing to the current revision in a
    version-controlled project.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-gutter
  :when window-system
  :hook ((prog-mode text-mode) . 'git-gutter-mode)
  :diminish ""
  :config
  (use-package git-gutter-fringe
    :after (git-gutter)
    :defer t
    :ensure t
    :init
    (require 'git-gutter-fringe)
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:modified
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:deleted
        [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
        nil nil 'center)))
  ;; Adding evil-mode bindings
  (define-key evil-normal-state-map (kbd "g h") 'git-gutter:previous-hunk)
  (define-key evil-normal-state-map (kbd "g H") 'git-gutter:next-hunk)
  (define-key evil-normal-state-map (kbd "g @") 'git-gutter:popup-hunk))
    #+END_SRC

*** Magit
    How to win at Git from Emacs.
    The configuration for each part is below in separate headings.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :defer t
  :config
  ;; Highlight what changed in diffs.
  (setq magit-diff-refine-hunk t))
    #+END_SRC
**** Commit configuration
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-commit
  :after (magit)
  :hook (git-commit-mode . git-commit-tweaks)
  :custom (git-commit-summary-max-length 50)
  :preface
  (defun git-commit-tweaks ()
    "Ensures that the commit body does not exceed 72 characters."
    (setq fill-column 72)
    (set (make-local-variable 'company-backends) '(company-dabbrev company-capf company-files))
    (set (make-local-variable 'company-minimum-prefix-length) 2)
    (setq-local comment-auto-fill-only-comments nil)
    (evil-set-initial-state 'git-commit-mode 'emacs)
    ))
     #+END_SRC
**** Viewing diffs
#+BEGIN_SRC emacs-lisp :tangle yes
;; Wrap those long lines.
(add-hook 'magit-diff-mode-hook 'visual-line-mode)
#+END_SRC
*** Yasnippets
    It originally came with company-mode, it's handy to write faster
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet-snippets)
(use-package yasnippet-classic-snippets)

(defun do-not-add-newline-for-snippets ()
  "What is says on the tin."
  (setq-local require-final-newline nil)
  )

(add-hook 'snippet-mode-hook 'do-not-add-newline-for-snippets)
    #+END_SRC
*** Circadian
    Theme changer for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package circadian
  :ensure t
  :config
  (cond
   ((eq system-type 'darwin)
    (setq circadian-themes '((:sunrise . cosmos-light)
                             (:sunset  . cosmos-dark))))
   ;; Personal Linux machine
   ((and (string-equal system-name auralcat/personal-system-name) (eq system-type 'gnu/linux))
    (setq circadian-themes '((:sunrise . solarized-light)
                             (:sunset  . solarized-dark))))
   ;; Work Linux machine
   ((and (string-equal system-name auralcat/work-system-name) (eq system-type 'gnu/linux))
    (setq circadian-themes '((:sunrise . modus-operandi)
                             (:sunset  . modus-vivendi)))))

  ;; Hooks
  (add-hook 'circadian-before-load-theme-hook
            #'(lambda (theme)
                (if (eq theme 'solarized-dark)
                    (set-frame-font "Fantasque Sans Mono"))
                ))

  (circadian-setup))
    #+END_SRC
*** Anzu
    Show search result count in the mode line.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-anzu
  :after (evil)
  :config
  (global-anzu-mode))
    #+END_SRC
*** The S library
This is a string manipulation library that Emacs uses for stuff.
I have to call it here because I use it in my scripts.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package s)
    #+END_SRC
*** Org-mode GFM exporter
GFM stands for *Github Flavored Markdown*. It's a nice exporter not just for that
use case though, since it removes the line wraps on exporting.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-gfm
  :defer t)
#+END_SRC
*** sqlformat
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sqlformat
  :commands (sqlformat sqlformat-buffer sqlformat-region)
  :hook (sql-mode . sqlformat-on-save-mode)
  :init
  ;; This is for Postgres.
  (setq sqlformat-command 'pgformatter
        sqlformat-args '("-s2" "-g")))
#+END_SRC
* Function Aliases
  #+BEGIN_SRC emacs-lisp :tangle yes
;; This is how you define aliases for Elisp functions. These are useful for when
;; you don't need to bind a command to a specific key, but you call that
;; function through M-x often.
(defalias 'plp 'package-list-packages)
(defalias 'kfs 'keyfreq-show)
  #+END_SRC
* Themes
  Remember to _defer_ the loading of the theme packages, otherwise the
  faces might get mixed up and look ugly.

  This function makes it easier to change themes quickly. You can bind it to a
  keychord or whatnot and use it as you wish.
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/change-theme (new-theme)
  "Disables the current theme in the session, loads and enables the NEW-THEME."
  ;; This is the code Emacs uses to load themes in custom.el
  (interactive
   (list
    (intern (completing-read "Change to theme: "
                             (mapcar #'symbol-name
                                     (custom-available-themes))))
    ))
  (let* (
         (current-theme (car custom-enabled-themes))
         (new-theme-loaded-p (memq new-theme custom-enabled-themes))
         )
    (disable-theme current-theme)
    (if new-theme-loaded-p
        (enable-theme new-theme)
      (load-theme new-theme)
      )
    ))

;; Bind it to a keychord.
(global-set-key (kbd "M-`") 'auralcat/change-theme)
  #+END_SRC
** Jazz
   A warm theme with dark colors.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package jazz-theme :ensure t
  :defer t)
   #+END_SRC
** Abyss
   Dark contrast theme
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package abyss-theme :ensure :defer t)
   #+END_SRC
** Twilight Bright
   A port of the theme from TextMate.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package twilight-bright-theme :defer t)
   #+END_SRC
** Organic Green
   A light theme with a light-green background, looks real nice!
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package organic-green-theme :defer t)
   #+END_SRC
** Flat UI
   Flat colors which blend nicely.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flatui-theme :defer t)
   #+END_SRC
** Hemisu
   I like the dark theme from here.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package hemisu-theme :defer t)
   #+END_SRC
** Gruvbox
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gruvbox-theme :defer t)
#+END_SRC
** Solarized themes
These are the official ones.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package solarized-theme :defer t)
#+END_SRC

* Fonts
It's better to set the fonts here instead of hard-coding them in init.el or in
the themes themselves.
** Default
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set fonts for each system if the extra ones are installed.
;; Otherwise use the system's default fonts.
(cond
 ((eq system-type 'darwin)
  (if (font-info "Fantasque Sans Mono")
      (set-face-attribute 'default nil :font "Fantasque Sans Mono" :height 140)
    (set-face-attribute 'default nil :font "Monaco" :height 120))
  )
 ((eq system-type 'gnu/linux)
  (if (font-info "Terminus")
      (set-face-attribute 'default nil :font "Terminus" :height 100)
    (set-face-attribute 'default nil :font "Ubuntu Mono" :height 120)
    ))
 )
  #+END_SRC
** Variable Pitch
  #+BEGIN_SRC emacs-lisp :tangle yes
(cond
 ((eq system-type 'darwin)
  (if (font-info "Avenir")
      (set-face-attribute 'variable-pitch nil :font "Avenir" :height 120)
    (set-face-attribute 'variable-pitch nil :font "Helvetica" :height 120))
  )
 ((eq system-type 'gnu/linux)
  (if (font-info "Liberation Sans")
      (set-face-attribute 'variable-pitch nil :font "Liberation Sans" :height 120)
    (set-face-attribute 'variable-pitch nil :font "Open Sans" :height 120)
    ))
 )
  #+END_SRC

* Graphical
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set font in graphical mode
(when (display-graphic-p)
  ;; Remove menu and scroll bars in graphical mode
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  ;; Global emoji in the mode line exclusively
  (global-emojify-mode-line-mode)
  ;; Maximize frame on startup
  (toggle-frame-maximized)
  ;; Space lines and bask in the gloriousness of graphical mode.
  ;; 0.4 feels better for prose, and 0.2 is fine for code.
  (add-hook 'prog-mode-hook (lambda () (setq line-spacing 0.2)))
  (add-hook 'comint-mode-hook (lambda () (setq line-spacing 0.2)))
  (add-hook 'text-mode-hook (lambda () (setq line-spacing 0.6))))
  #+END_SRC
* Keybindings
 #+BEGIN_SRC emacs-lisp :tangle yes
;; Indent whole buffer using C-c TAB
(define-key prog-mode-map (kbd "C-c TAB") 'auralcat/indent-whole-buffer)

;; Translate the compose keys
(define-key key-translation-map (kbd "Â¹") (kbd "M-1"))
(define-key key-translation-map (kbd "Â²") (kbd "M-2"))
(define-key key-translation-map (kbd "Â³") (kbd "M-3"))
(define-key key-translation-map (kbd "Â£") (kbd "M-4"))
(define-key key-translation-map (kbd "Ã°") (kbd "M-d"))
(define-key key-translation-map (kbd "Å") (kbd "M-g"))
(define-key key-translation-map (kbd "<M-S-dead-grave>") (kbd "M-`"))
(define-key key-translation-map (kbd "â") (kbd "M-v"))
(define-key key-translation-map (kbd "â") (kbd "M-S-v"))
(define-key key-translation-map (kbd "C-â") (kbd "C-M-v"))
(define-key key-translation-map (kbd "C-â") (kbd "C-S-M-v"))
(define-key key-translation-map (kbd "Ã¦") (kbd "M-a"))
(define-key key-translation-map (kbd "C-Ã¦") (kbd "C-M-a"))
(define-key key-translation-map (kbd "Ã") (kbd "M-S-a"))
(define-key key-translation-map (kbd "Â°") (kbd "M-e"))
(define-key key-translation-map (kbd "C-Â°") (kbd "C-M-e"))
(define-key key-translation-map (kbd "C-Ä") (kbd "C-M-f"))
(define-key key-translation-map (kbd "C-â") (kbd "C-M-b"))
(define-key key-translation-map (kbd "M-Â°") (kbd "M-S-e"))

;; Some speed commands
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'helm-mini)
(global-set-key (kbd "M-3") 'ace-jump-mode)
(global-set-key (kbd "M-4") 'switch-to-buffer-other-window)

(use-package org :ensure t
  :bind (:map org-mode-map
              ("M-1". delete-other-windows)
              ("M-2". helm-mini)
              ("M-3". ace-jump-mode)
              ("M-4". switch-to-buffer-other-window)
              ))

(define-key comint-mode-map (kbd "M-1") 'delete-other-windows)
(define-key comint-mode-map (kbd "M-2") 'helm-mini)
(define-key comint-mode-map (kbd "M-3") 'ace-jump-mode)
(define-key comint-mode-map (kbd "M-4") 'switch-to-buffer-other-window)

;; Resize the frame with ease
(global-set-key [M-f11] (quote toggle-frame-fullscreen))
(global-set-key [M-f10] (quote toggle-frame-maximized))

;; Jump to previous window using M-'
(global-set-key (kbd "M-'") (quote evil-switch-to-windows-last-buffer))
(global-set-key (kbd "M-\"") (quote abbrev-prefix-mark))

;; Use the menu key for helm-m-x
(global-set-key [menu] (quote helm-M-x))

;; Unfill region
(define-key global-map "\C-\M-q" 'unfill-region)

;; Mapping AltGr-d to delete-other-windows,
;; Another symbol I don't use often.
(global-set-key [240] (quote delete-other-windows))

;; Access buffers with Alt-Gr b
(global-set-key [8221] (quote helm-buffers-list))

;; Map the Home and End keys to go to the beginning and end of the buffer
(global-set-key [home] (quote beginning-of-buffer))
(global-set-key [end] (quote end-of-buffer))

;; Move to beginning of line or indentation
(defun back-to-indentation-or-beginning () (interactive)
       (if (= (point) (progn (back-to-indentation) (point)))
           (beginning-of-line)))

;; We need this to get back to the beginning of the indentation or first word of the line.
(global-set-key (kbd "C-a") (quote back-to-indentation-or-beginning))

;; Hippie-Expand: change key to M-SPC; Replace dabbrev-expand
(global-set-key "\M- " 'hippie-expand)
(global-set-key "\M-/" 'hippie-expand)

;; Eshell configuration
(defun eshell-tweaks ()
  "Tweaks for the Emacs shell"
  (evil-set-initial-state 'shell-mode 'emacs))
(add-hook 'shell-mode-hook 'eshell-tweaks)

;; Evaluate buffer using SPC SPC, depending on major mode.
(evil-leader/set-key-for-mode 'emacs-lisp-mode "SPC" 'eval-buffer)
(evil-leader/set-key-for-mode 'enh-ruby-mode "SPC" 'ruby-send-buffer-and-go)
(evil-leader/set-key-for-mode 'ruby-mode "!" 'auralcat/ruby/add-byebug-line)
(evil-leader/set-key-for-mode 'ruby-mode "SPC" 'ruby-send-buffer-and-go)
(evil-leader/set-key-for-mode 'python-mode "SPC" 'python-shell-send-buffer)
(evil-leader/set-key-for-mode 'js2-mode "SPC" 'js-comint-send-buffer)
(evil-leader/set-key-for-mode 'elixir-mode "!" 'auralcat/elixir-iex-pry)
(evil-leader/set-key-for-mode 'elixir-mode "SPC" 'inf-elixir-send-buffer)
  #+END_SRC
* Guess Language Mode
  This is a helper mode which changes the current ~flyspell~ dictionary depending on the language you're typing in the
  current line. Quite useful when you write text in more than one language often. That way you're not bound to a
  specific mode to work with.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package guess-language
  :config
  (setq guess-language-languages '(pt en))
  (setq guess-language-langcodes
        '((en . ("en_US" "English"))
          (pt . ("pt_BR" "Brasileiro"))))
  (setq guess-language-min-paragraph-length 35))
  #+END_SRC
* Web-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun web-mode-keybindings ()
  "Define mode-specific keybindings like this."
  (local-set-key (kbd "C-c C-v") 'browse-url-of-buffer)
  (local-set-key (kbd "C-c /") 'sgml-close-tag))

;; Add company backends when loading web-mode.
(defun web-mode-company-load-backends ()
  (company-web-bootstrap+)
  (company-web-fa+))

(add-hook 'web-mode-hook 'web-mode-keybindings)
(add-hook 'web-mode-hook 'web-mode-company-load-backends)

;; Use tidy to check HTML buffers with web-mode.
(eval-after-load 'flycheck
  '(flycheck-add-mode 'html-tidy 'web-mode))
  #+END_SRC
* Org-mode
** Main configuration
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Some bindings for Emacs mode.
;; I've noticed that Org seems easier to navigate with Emacs bindings instead of Evil.
(define-key global-map (kbd "C-c a") 'org-agenda)
(define-key global-map (kbd "C-c k") 'org-capture)

;; Start indented, with inline images, and don't show emphasis markers.
(setq org-startup-indented t
      org-startup-with-inline-images t
      org-hide-emphasis-markers t)

;; We don't need Flycheck in org-mode buffers. Usually.
(add-hook 'org-mode-hook '(lambda() (flycheck-mode 0)))

;; Change the end of collapsed headings to an arrow.
(setq org-ellipsis "â¤µ")

;; Use fixed-pitch fonts inside org-src blocks.
(set-face-attribute 'org-block nil :inherit 'fixed-pitch :height 120)

;; Keep agenda file list in a single file so I can publish my config.
;; DO NOT use C-c [ or C-c ] to add/remove files to the agenda otherwise
;; Emacs will write the var to init.el
(setq org-agenda-files "~/file-bouncer/org-agenda-file-list.org")

;; When TODOs are ordered, enforce task dependencies
(setq org-enforce-todo-dependencies t)

;; Don't split my lines, thx.
(setq org-M-RET-may-split-line nil)

;; Truncate long task names
(setq org-clock-heading-function
      (lambda ()
        (let ((str (nth 4 (org-heading-components))))
          (concat (truncate-string-to-width str 27) "...")
          )))

;; Organize the bindings
;; Use helm-org-in-buffer-headings instead of imenu; it has more actions and
;; shows the exact heading you want.
(evil-leader/set-key-for-mode 'org-mode "h i" 'helm-org-in-buffer-headings)

;; Open subheading with C-c RET and invert with M-RET
(define-key org-mode-map (kbd "C-c RET") 'org-ctrl-c-ret)
(define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)

;; Use C-RET to complete words in Org-mode
(define-key org-mode-map (kbd "C-RET") 'complete)

;; Always respect the content of a heading when creating todos!
(define-key org-mode-map (kbd "<M-S-return>") 'org-insert-todo-heading-respect-content)

;; Map C-S-enter to org-insert-todo-subheading
(define-key org-mode-map (kbd "<C-S-return>") 'org-insert-todo-subheading)

;; Use Emacs mode in Org-capture buffers and notes buffer
(add-hook 'org-capture-mode-hook 'evil-emacs-state)

;; Idiot-proofing my configs
(define-key org-mode-map (kbd "C-c ]") nil)
(define-key org-mode-map (kbd "C-c [") nil)

;; Simplify org-todo in org-mode buffers with <leader> t
(evil-leader/set-key-for-mode 'org-mode "t" 'org-todo)

;; Log when a task was done and when it was rescheduled.
(setq org-log-done 'time)
(setq org-log-reschedule 'time)

;; Don't write inside invisible area when collapsing headings!
(setq org-catch-invisible-edits 'error)

;; Define a standard format for Org's column view
(setq org-columns-default-format "%50ITEM(Item) %EFFORT(Effort) %CLOCK(Time Spent)")

;; Set agenda as sticky. This makes the buffers persistent, and load faster if
;; you open them all the time.
(setq org-agenda-sticky t)
   #+END_SRC
** Org-agenda configuration
Colorize the agenda: https://llazarek.com/2018/07/improving-the-agenda.html
#+BEGIN_SRC emacs-lisp :tangle yes
(defun ll/org/agenda/color-headers-with (tag fg-col bg-col)
  "Color agenda lines matching TAG with color FG-COL."
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward tag nil t)
    (unless (find-in-line "\\[#[A-Z]\\]")
      (let ((todo-end (or (ll/org/agenda/find-todo-word-end)
                          (point-at-bol)))
            (tags-beginning (or (find-in-line " :" t)
                                (point-at-eol))))
        (add-text-properties todo-end
                             tags-beginning
                             `(face (:foreground ,fg-col :background ,bg-col)))))))

;; Helper definitions
(setq ll/org/agenda-todo-words
      '("TODO" "GOAL" "NEXT" "STARTED" "WAITING" "REVIEW" "SUBMIT"
        "DONE" "DEFERRED" "CANCELLED"))
(defun find-in-line (needle &optional beginning count)
  "Find the position of the start of NEEDLE in the current line.
  If BEGINNING is non-nil, find the beginning of NEEDLE in the current
  line. If COUNT is non-nil, find the COUNT'th occurrence from the left."
  (save-excursion
    (beginning-of-line)
    (let ((found (re-search-forward needle (point-at-eol) t count)))
      (if beginning
          (match-beginning 0)
        found))))
(defun ll/org/agenda/find-todo-word-end ()
  (reduce (lambda (a b) (or a b))
          (mapcar #'find-in-line ll/org/agenda-todo-words)))

;; Load my tag colors
(load "~/.agenda-colors")
#+END_SRC

** Org-English mode
This is a derived mode to hold English abbrevs.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode org-english-mode org-mode "Org-EN"
  "Org-mode used to hold English abbrevs. Does everything that plain org-mode does.")

(add-to-list 'auto-mode-alist '("\\.org\\.en?\\'" . org-english-mode))
#+END_SRC
** Auto-mark TODO entries as DONE
   #+BEGIN_SRC emacs-lisp :tangle yes
;; see http://thread.gmane.org/gmane.emacs.orgmode/42715
(eval-after-load 'org-list
  '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

;; Mark a parent TODO entry as DONE when its checkboxes are all ticked
(defun ndk/checkbox-list-complete ()
  (save-excursion
    (org-back-to-heading t)
    (let ((beg (point)) end)
      (end-of-line)
      (setq end (point))
      (goto-char beg)
      (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
          (if (match-end 1)
              (if (equal (match-string 1) "100%")
                  ;; all done - do the state change
                  (org-todo 'done)
                (org-todo 'todo))
            (if (and (> (match-end 2) (match-beginning 2))
                     (equal (match-string 2) (match-string 3)))
                (org-todo 'done)
              (org-todo 'todo)))))))
   #+END_SRC
** Tables
Use the fixed-pitch font for tables.
#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+END_SRC
** Capture templates
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Load them from a separate file.
(load "~/.org-capture-templates.el")
   #+END_SRC
** Org-bullets
   Change org-mode's *s to UTF-8 chars
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-bullets
  :init
  (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1)))
  ;; Fallback bullets.
  (setq org-bullets-bullet-list (quote ("â¿" "â" "â" "â" "â¸")))
  )
   #+END_SRC
** Org-babel
*** General settings
- Do not ask me if I want to run the source block
- Output the results in _scripting_ mode, instead of eval mode.
- Wrap them in an example block (for exporting)

  Important: the default header args will be:
  =:noweb :results output verbatim replace :exports both=
#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-org-confirm-babel-evaluate (lang body)
  "Don't confirm squat."
  (not (member lang '("sh" "elisp" "ruby" "elixir" "shell"))))

;; A few more tweaks for org-babel.
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate
      org-src-preserve-indentation t
      org-babel-min-lines-for-block-output 1
      org-babel-default-header-args
      (cons '(:noweb . "yes")
            (assq-delete-all :noweb org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:exports . "both")
            (assq-delete-all :exports org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:results . "output verbatim replace")
            (assq-delete-all :results org-babel-default-header-args)))

#+END_SRC

*** Elixir
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-elixir)
    #+END_SRC
*** Emacs' restclient-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-restclient)
    #+END_SRC

*** Load languages
    #+BEGIN_SRC emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (shell . t)
   (python . t)
   (ruby . t)
   (elixir . t)
   (plantuml . t)
   (dot . t)
   ))
    #+END_SRC

** Org-pomodoro
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-pomodoro
  :bind ("C-x p" . org-pomodoro))

;; Display notification when a pomodoro is completed
(defun pomodoro-display-notification (title body)
  (if (eq system-type 'darwin)
      (ns-do-applescript (format "display notification \"%s\" with title \"%s\" sound name \"Glass\"" body title))
    (notifications-notify :title title
                          :body body
                          :app-icon "~/my-dotfiles/.emacs.d/org-pomodoro/tomato.png")))

;; Use mpv in OS X
(when (eq system-type 'darwin)
  (setq org-pomodoro-audio-player "/usr/local/bin/mpv"))

(add-hook 'org-pomodoro-started-hook (lambda() (pomodoro-display-notification "Pomodoro started!" "Concentrate on your task!")))
(add-hook 'org-pomodoro-finished-hook (lambda() (pomodoro-display-notification "Pomodoro finished" "Time to take a break!")))
   #+END_SRC
** Evil-org
   Evil-mode keybindings for org-mode.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org
  :diminish evil-org-mode
  :hook (org-mode . evil-org-mode)
  )

;; Use 'complete when pressing C-<return> in insert mode for org-mode buffers.
(add-hook 'org-mode-hook #'(lambda () (define-key evil-insert-state-map (kbd "C-<return>") 'complete)))
   #+END_SRC
* Markdown-mode
  A couple tweaks to make it more Org-like.
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun markdown-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1)
  )

(use-package markdown-mode
  :hook ((markdown-mode . markdown-mode-tweaks)
         (gfm-mode . markdown-mode-tweaks))
  :bind
  ("M-<right>" . 'markdown-demote)
  ("M-<left>" . 'markdown-promote)
  ("M-<up>" . 'markdown-move-up)
  ("M-<down>" . 'markdown-move-down)
  ("C-c 1" . 'markdown-insert-header-atx-1)
  ("C-c 2" . 'markdown-insert-header-atx-2)
  ("C-c 3" . 'markdown-insert-header-atx-3)
  :config
  (setq markdown-asymmetric-header t))
  #+END_SRC
* Variables
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set Fundamental mode as default mode for new buffers:
(setq-default major-mode 'fundamental-mode)
(setq initial-major-mode 'fundamental-mode)

;; Enable auto-fill mode by default
(auto-fill-mode 1)

;; Change tab width and change tabs to spaces
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)

;; Making Emacs auto-indent
(define-key global-map (kbd "RET") 'newline-and-indent)

;; Shows trailing whitespace, if any:
(setq-default show-trailing-whitespace t)
;; Don't do that for terminal mode!
(add-hook 'multi-term-mode-hook (setq-default show-trailing-whitespace nil))

(defun css-mode-tweaks()
  (set (make-local-variable 'company-backends) '(company-css company-yasnippet company-etags))
  (emmet-mode 1))

;; Emmet-mode: activate for html-mode, sgml-mode,
;; css-mode, web-mode and sass-mode
(add-hook 'sgml-mode-hook 'emmet-mode)
(add-hook 'sass-mode-hook 'css-mode-tweaks)
(add-hook 'web-mode-hook 'emmet-mode)
(add-hook 'css-mode-hook 'css-mode-tweaks)

;; Python: use python3 as default shell interpreter
(setq python-shell-interpreter "python3")

  #+END_SRC
** Project-local variables
Disable the ~risky-variable~ check. I know what I'm doing.
This can be reverted later with ~(advice-remove)~ though.
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add 'risky-local-variable-p :override #'ignore)
#+END_SRC
* Custom functions
** Rails Docker utils
   #+BEGIN_SRC emacs-lisp :tangle yes
(require 'rails-docker-utils)
   #+END_SRC
** Kill relative file name
   I use that to work with rspec. Projectile has the ~C-c C-k~
   keybinding to kill the file name in a Helm session, when I realize
   I need to get that, I'm in the buffer already.

   #+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat-kill-relative-file-name ()
  "Add the file name relative to the project's root to the kill ring."
  (interactive)
  (let ((relative-file-name (magit-file-relative-name buffer-file-name)))
    (kill-new relative-file-name)
    (message "Current buffer's relative file name copied to kill ring: %s" relative-file-name)))
   #+END_SRC
** Calculate leap year
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun is-leap-year (year)
  "Checks if the given YEAR is a leap year"
  (interactive "P")
  (or
   (and (not (eq (% year 100) 0))
        (eq (% year 4) 0))
   (eq (% year 400) 0))
  )

   #+END_SRC
** Quick org-todo without leaving current buffer
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun my-org-remote-todo ()
  "Changes the TODO state of the currently clocked heading remotely."
  (interactive)
  (org-clock-goto)
  (org-todo)
  (mode-line-other-buffer)
  )
   #+END_SRC
** Unfill region
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Unfill region, AKA leave single huge line
(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
       logical line.  This is useful, e.g., for use with
       `visual-line-mode'."
  (interactive "*r")
  (let ((fill-column (point-max)))
    (fill-region beg end)))

(load "~/my-dotfiles/.emacs.d/elisp-custom/docker-sync-utils.el")
   #+END_SRC
* Twittering mode
  Use Twitter from within Emacs!
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package twittering-mode
  :bind (:map twittering-mode-map
              ("C-c r" . my-twittering-mode-reply-to-user)
              ("C-c f" . twittering-favorite)
              ("C-c n" . twittering-native-retweet)))

;; WIP, needs A LOT of remapping
;; Use evil-mode to navigate twittering's frame
;; (evil-set-initial-state 'twittering-mode 'emacs)

;; Adjust update interval in seconds. It's timeR, not time!
(setq twittering-timer-interval 3600)

;; Display icons (if applicable)
(setq twittering-icon-mode t)

;; Use a master password so you don't have to ask for authentication every time
(setq twittering-use-master-password t)
  #+END_SRC

* Mode Line
** Custom code
[[https://github.com/rnkn/olivetti/issues/39#issuecomment-660606677][Source]]
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mode-line-align (left right)
  "Return a string with LEFT and RIGHT at the edges of the
current window."
  (format (format "%%s %%%ds" (- (window-total-width) (length left) 2))
          left right))

(setq default-frame-alist '((internal-border-width . 20)))

(setq auralcat/mode-line-left-side
      (list " " evil-mode-line-tag
            " " mode-line-buffer-identification
            " " mode-line-modified
            " " mode-name
            " " mode-line-position
            " " '(vc-mode vc-mode)))

(setq auralcat/mode-line-right-side
      (list minor-mode-alist
            " " mode-line-misc-info
            " " mode-line-end-spaces))

(setq-default mode-line-format
              '("%e" (:eval (mode-line-align
                             (format-mode-line
                              auralcat/mode-line-left-side)
                             (format-mode-line
                              auralcat/mode-line-right-side)))))

#+END_SRC
* Cursor
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/get-face-foreground-color (face)
  "Return the hex code from the specified FACE."
  (face-attribute face :foreground))

;; Use basic faces to customize Evil cursors based on theme.
(defun auralcat/set-evil-faces-based-on-current-theme ()
  "Changes the faces for Evil modes based on current theme."
  (let
      ((evil-normal-face-color    (auralcat/get-face-foreground-color  'font-lock-builtin-face))
       (evil-insert-face-color    (auralcat/get-face-foreground-color  'font-lock-string-face))
       (evil-motion-face-color    (auralcat/get-face-foreground-color  'font-lock-keyword-face))
       (evil-replace-face-color   (auralcat/get-face-foreground-color  'font-lock-keyword-face))
       (evil-operator-face-color  (auralcat/get-face-foreground-color  'font-lock-constant-face))
       (evil-visual-face-color    (auralcat/get-face-foreground-color  'font-lock-type-face))
       (zoom-window-color    (auralcat/get-face-foreground-color  'font-lock-string-face)))
    (setq  evil-normal-state-cursor    `(,evil-normal-face-color    box))
    (setq  evil-insert-state-cursor    `(,evil-insert-face-color    bar))
    (setq  evil-motion-state-cursor    `(,evil-motion-face-color    box))
    (setq  evil-replace-state-cursor   `(,evil-replace-face-color   hbar))
    (setq  evil-operator-state-cursor  `(,evil-operator-face-color  box))
    (setq  evil-visual-state-cursor    `(,evil-visual-face-color    box))
    (setq  zoom-window-mode-line-color zoom-window-color)
    ))

(add-hook 'circadian-after-load-theme-hook #'(lambda (theme) (auralcat/set-evil-faces-based-on-current-theme)))

;; This is to be able to tell when I'm in Emacs state.
(setq evil-emacs-state-cursor '("purple" box))

(setq-default blink-cursor-blinks 0)
(setq-default blink-cursor-interval 0.6)
(setq-default blink-cursor-delay 0.2)
#+END_SRC
* Diary
** Last day of month
   #+BEGIN_SRC emacs-lisp :tangle yes
;; ORG-MODE:
;; * My Task
;;   SCHEDULED: <%%(diary-last-day-of-month date)>
;;; DIARY:  %%(diary-last-day-of-month date) Last Day of the Month
;;; See also:  (setq org-agenda-include-diary t)
;;; (diary-last-day-of-month '(2 28 2017))
(defun diary-last-day-of-month (date)
  "Return `t` if DATE is the last day of the month."
  (let* ((day (calendar-extract-day date))
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (last-day-of-month
          (calendar-last-day-of-month month year)))
    (= day last-day-of-month)))

(defun diary-first-weekday-of-month (date)
  (let* ((day (calendar-extract-day date))
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (first-day-date (list month 1 year))
         (first-absolute-day-weekday (calendar-day-of-week first-day-date)))

    (or
     ;; When the first day is Sunday, it's day 2.
     (and (eq first-absolute-day-weekday 0)
          (eq day 2))

     ;; When the first day is Saturday, it's day 3.
     (and (eq first-absolute-day-weekday 6)
          (eq day 3))

     ;; Else, it's day 1 and a weekday.
     (and (memq (calendar-day-of-week date) '(1 2 3 4 5))
          (eq day 1))
     )
    ))

(defun diary-last-weekday-of-month (date)
  (let* ((day-of-week (calendar-day-of-week date))
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (last-month-day (calendar-last-day-of-month month year))
         (month-day (cadr date)))

    (or
     ;; it's the last day of the month & it is a weekday
     (and (eq month-day last-month-day)
          (memq day-of-week '(1 2 3 4 5)))

     ;; it's a friday, and it's the last-but-one or last-but-two day
     ;; of the month
     (and (eq day-of-week 5)
          (or (eq month-day (1- last-month-day))
              (eq month-day (1- (1- last-month-day))))))))

(defun diary-first-working-day-of-month (date)
  "Returns `t` if DATE is the first working day of the month.
  This is defined as the first weekday of the month which is not a holiday."
  (let* ((day (calendar-extract-day date))
         (month (calendar-extract-month date)))
    (if
        ;; If it's May or Jan, check if day 2 is a weekday.
        (and (or (= month 5) (= month 1)))
        (and (= day 2) (memq (calendar-day-of-week date) '(1 2 3 4 5)))
      ;; Else, check if it's the first weekday of the month.
      (diary-first-weekday-of-month date))))
   #+END_SRC
