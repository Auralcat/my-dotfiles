#+TITLE: Emacs configuration file
#+AUTHOR: Auralcat
#+DATE: 2017:05:17
#+STARTUP: overview

* Personal info
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Load from external file.
(load "~/.emacs.secrets")
  #+END_SRC

* Command history
  It's a good idea to save the previous commands' history, for a couple reasons:
  - Check the complex commands you use most often and improve your workflow
    based on that
  - Store cumbersome commands for specific situations that don't
    appear too often, but where this command saves your back (example
    in Ruby: extracting a variable inside "it" clause to a "let" block)
    #+BEGIN_SRC emacs-lisp :tangle yes
(setq savehist-file "~/file-bouncer/emacs-savehist")
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(setq history-length 10000)
(setq history-delete-duplicates t)
(setq history-length 1024)
(add-hook 'after-init-hook 'savehist-mode)
    #+END_SRC
* Bookmarks
  It's a quicker way to navigate through files you visit often.
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq bookmark-default-file "~/emacs-bookmarks")
;; Every time bookmarks are changed, save them
(setq bookmark-save-flag 1)
  #+END_SRC
* Evil Mode
  Yes, I'm committing this heresy.
** Evil-leader
     Add a prefix key to Evil mode, like the Leader key in Vim.
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-leader
  :defer t)
(load "~/my-dotfiles/.emacs.d/elisp-custom/evil-leader-custom-functions.el")
(global-evil-leader-mode)
;; Evil mode needs to be loaded after evil-leader
(use-package evil
:defer t)
(evil-mode 1)

;; Load configs
(load "~/my-dotfiles/.emacs.d/evilrc")
     #+END_SRC
** Evil Surround
     Easier manipulation of delimiters, emulation of vim.surround
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-surround
:defer t)
(global-evil-surround-mode)
     #+END_SRC
** Easy copy and paste inside quotes
These are wrapper functions and macros to copy and paste text from inside quotes. I'm doing this quite a lot lately.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/evil-yank-inside-quotes ()
     "Copies text from inside single or double quotes."
     (interactive)
     (cond
      ((looking-at "\"")
       (auralcat/evil-yank-inside-double-quotes 1))
      ((looking-at "'")
       (auralcat/evil-yank-inside-single-quotes 1))
      ))

(defun auralcat/evil-paste-inside-quotes ()
     "Copies text from inside single or double quotes."
     (interactive)
     (cond
      ((looking-at "\"")
       (auralcat/evil-paste-inside-double-quotes 1))
      ((looking-at "'")
       (auralcat/evil-paste-inside-single-quotes 1))
      ))

(define-key evil-normal-state-map (kbd "g y") 'auralcat/evil-yank-inside-quotes)
(define-key evil-normal-state-map (kbd "g p") 'auralcat/evil-paste-inside-quotes)

(fset 'auralcat/evil-yank-inside-double-quotes
   (kmacro-lambda-form [?y ?i ?\"] 0 "%d"))
(fset 'auralcat/evil-yank-inside-single-quotes
   (kmacro-lambda-form [?y ?i ?\'] 0 "%d"))
(fset 'auralcat/evil-paste-inside-double-quotes
   (kmacro-lambda-form [?m ?z ?v ?i ?\" ?P ?` ?z] 0 "%d"))
(fset 'auralcat/evil-paste-inside-single-quotes
   (kmacro-lambda-form [?m ?z ?v ?i ?\' ?P ?` ?z] 0 "%d"))
#+END_SRC
* Xref
This is quite useful to navigate through code faster.
#+BEGIN_SRC emacs-lisp :tangle yes
(evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
#+END_SRC
* Occur
Occur is useful for when you want to keep a list of code points of interest in a
given buffer or a set of buffers with ~multi-occur-in-matching-buffers~. I was
used to doing this multi search through ~ibuffer~, but you can call this function
from ~M-x~ and get the same result if you want.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'occur-hook 'occur-rename-buffer)
#+END_SRC
* Dired
  A couple customizations.
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Customize Dired list switches.
(setq dired-listing-switches "-alh")

;; Use Emacs mode in Dired.
(add-hook 'dired-mode-hook 'evil-emacs-state)

;; Kill selected subdir with C-M-k
(add-hook 'dired-mode-hook #'(lambda () (define-key dired-mode-map (kbd "C-M-k") 'dired-kill-subdir)))
  #+END_SRC

* Macros
  #+BEGIN_SRC emacs-lisp :tangle yes
;; To save a macro, record it with C-x ( (start) and C-x ) (stop),
;; give it a name with C-x C-k n (C-k is for maKro) and
;; insert it in this file with insert-kbd-macro.
;; Then you execute it mapping it to a key!

;; This package allows you to override a couple functions.
(use-package noflet)
(lambda (&optional arg) "Extracts a variable from an it clause and puts in a let statement." (interactive "p") (kmacro-exec-ring-item (quote ([100 100 134217745 134217729 112 99 87 108 101 116 40 58 25 escape 102 61 50 120 67 123 25 escape 86 61 15 15 48 119] 0 "%d")) arg))

;; Adds a byebug line to Ruby code
(fset 'auralcat/ruby/add-byebug-line
      (kmacro-lambda-form [?O ?b ?y ?e ?b ?u ?g escape return] 0 "%d"))

(fset 'auralcat/ruby-clone-method
      (lambda (&optional arg) "Clones a def method in Ruby." (interactive "p") (kmacro-exec-ring-item (quote ([86 125 121 103 118 escape 112] 0 "%d")) arg)))

(fset 'auralcat/search-git-conflict-string
      (lambda (&optional arg) "Searches for a Git conflict string." (interactive "p") (kmacro-exec-ring-item (quote ([134217747 94 91 60 61 62 93 13] 0 "%d")) argumento)))

(fset (quote sample-macro)
      (lambda (&optional arg) "Sample description" (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-exec-ring-item (quote ([100 87 65 32 35 32 65 110 111 116 104 101 114 32 109 97 99 114 111 32 99 97 108 108 46 escape 134217730 return 112 45] 0 "%d")) arg)
      )
    (undo-boundary)
    ))

;; Some macros to adjust Ruby blocks
(fset 'auralcat/ruby-move-defun-backward
      (lambda (&optional arg) "Moves a DEF block backwards in the class definition." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-exec-ring-item (quote ([26 167772166 23 134217820 16 4 134217820 4 2 134217730 16 return 25 return 134217730 26] 0 "%d")) arg)
      )
    (undo-boundary)
    ))

(fset 'auralcat/ruby-move-block-forward
      (lambda (&optional arg) "Moves a Ruby block forward in the current nesting level." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-lambda-form [?\C-z ?\C-  ?\C-\M-n ?\C-e ?\C-w ?\C-\M-n ?\C-m ?\C-/ ?\C-e ?\C-m ?\C-m ?\C-y ?\C-u ?\C-  ?\C-  ?\C-k ?\C-k ?\C-i ?\C-z] 0 "%d")
      )
    (undo-boundary)
    )
      )

;; Removes a Ruby block wrapping another block.
(fset 'auralcat/ruby-block-vanish
      (kmacro-lambda-form [?m ?m ?% ?d ?d ?\' ?m ?d ?d ?\C-x ?\C-x ?=] 0 "%d"))

;; Remove links in an Org entry
(fset 'auralcat/org-remove-link
      (kmacro-lambda-form [?d ?s ?\] ?d ?f ?\] ?d ?s ?\]] 0 "%d"))

;; Copy the link at point in Org mode buffers
(fset 'org-copy-link-at-point
   (kmacro-lambda-form [?\C-c ?\C-l ?\C-  ?\C-a ?\M-w return return] 0 "%d"))

;; Paste the content from the kill ring into the next and previous lines
(fset 'auralcat/yank-content-into-next-line
      (lambda (&optional arg) "Paste the content from the kill ring into the next line." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-lambda-form [?\C-z return ?\C-p ?\C-y ?\C-a ?\C-n ?\C-z] 0 "%d"))
    (undo-boundary)))

(fset 'auralcat/yank-content-into-previous-line
      (lambda (&optional arg) "Paste the content from the kill ring into the previous line." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-lambda-form [?\C-z ?\C-e return ?\C-y ?\C-a ?\C-p ?\C-z] 0 "%d"))
    (undo-boundary)))

  #+END_SRC

** Elixir
#+BEGIN_SRC emacs-lisp :tangle yes
;; Changes a one-line function like:
;; def something(foo), do: "yay!"
;;
;; to:
;;
;; def something(foo) do
;;   "yay!"
;; end
(fset 'auralcat/elixir-change-one-line-function-to-multiline
      (kmacro-lambda-form [?f ?: ?F ?, ?x ?E ?x ?i return escape ?o ?e ?n ?d return escape ?\M-a return] 0 "%d"))

;; Calls IEx.pry in the line above the cursor.
(fset 'auralcat/elixir-iex-pry
      (kmacro-lambda-form [?O ?r ?e ?q ?u ?i ?r ?e ?  ?I ?E ?x ?\; ?  ?I ?E ?x ?. ?p ?r ?y escape] 0 "%d"))
#+END_SRC

* Environment Customizations
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Make startup faster by reducing the frequency of garbage
;; collection.  The default is 0.8MB.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))
;; Portion of heap used for allocation.  Defaults to 0.1.
(setq gc-cons-percentage 0.6)

;; Sentences end with single spaces for me.
(setq sentence-end-double-space nil)

;; Set locale to Brazilian Portuguese
(set-locale-environment "pt_BR.UTF-8")

;; Change window title
(setq frame-title-format (format "%s %s - %s" (nth 1 (split-string (emacs-version)))
                   (nth 2 (split-string (emacs-version)))
                   (system-name)))

;; Add frame margins. This makes things more pleasant to read.
(setq default-frame-alist '((internal-border-width . 20)))

;; A small performance improvement
(setq redisplay-dont-pause t)

;; Since I work only with left-to-right languages, we can set it like this.
(setq bidi-paragraph-direction 'left-to-right)

;; I don't like lockfiles
(setq create-lockfiles nil)

;; Starts the Emacs server for emacsclient.
(server-start)

;; Store all backups in a specific folder:
(setq backup-directory-alist `(("." . "~/file-bouncer/emacs-backups")))

;; Manual packages load path
(add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-themes/")

;; Manual Elisp scripts load path
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/elisp-custom")
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/manual-packages/")

;; Backup files by copying them
(setq backup-by-copying t)

;; I'm too lazy to type "yes" or "no"
;; And I'm also too lazy to press y.
(defconst y-or-n-p-ret-yes-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map y-or-n-p-map)
    (define-key map [return] 'act)
    map)
  "A keymap for y-or-n-p with RET meaning \"yes\".")

(fset 'yes-or-no-p 'y-or-n-p)

;; Clean whitespace before saving a file
(add-hook 'before-save-hook 'whitespace-cleanup)

;; When making executable scripts, this function can make the new file
;; executable for you automatically.
;; You'll still need to include the shebang in the start of the file though.
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)

;; While you're at it, save automatically when visiting files.
;; This is best used in prog-mode derivatives.
(add-hook 'prog-mode-hook #'(lambda () (auto-save-visited-mode 1)))

;; Disable it for outline-mode derivatives like Markdown and Org.
(add-hook 'text-mode-hook #'(lambda () (auto-save-visited-mode 0)))

;; Allow only one theme at a time
(setq custom-theme-allow-multiple-selections nil)

;; Easier mark cycling, both local and global
(setq set-mark-command-repeat-pop t)

;; Replace the built-in buffer menu with ibuffer
(global-set-key [24 2] (quote ibuffer))

;; Prevent the scratch buffer from being killed
(with-current-buffer "*scratch*"
  (emacs-lock-mode 'kill))

;; Enable auto-revert-mode
(global-auto-revert-mode t)

;; Remove the menu bar in terminal mode
(when (not (display-graphic-p))
  (menu-bar-mode -1))

;; Use Bash as default shell interpreter
(setq org-babel-sh-command "/bin/bash")
;; Get Emacs to understand your aliases
;; (setq shell-file-name "bash")
;; For reference, this is the default value:
;; (setq shell-command-switch "-c")
;; (setq shell-command-switch "-ic")

;; Activate Company mode
(add-hook 'after-init-hook 'global-company-mode)

;; Enable global Abbrev mode
(setq-default abbrev-mode t)

;; Save last edited place in files
(require 'saveplace)
(setq-default save-place t)

;; I need a bigger kill ring.
(setq kill-ring-max 180)

;; Use recentf-mode
(recentf-mode)
(setq recentf-max-menu-items 100)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
  #+END_SRC
** Garbage collection tweaks
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar file-name-handler-alist-old file-name-handler-alist)

(setq-default gc-cons-threshold 402653184
          file-name-handler-alist nil
          gc-cons-percentage 0.6
          auto-window-vscroll nil
          message-log-max 16384)

(add-hook 'after-init-hook
      `(lambda ()
         (setq file-name-handler-alist file-name-handler-alist-old
           gc-cons-threshold 800000
           gc-cons-percentage 0.1)
         (garbage-collect)) t)

(setq inhibit-compacting-font-caches t)

;; Optimize garbage collection
(use-package gcmh
  :ensure t
  :disabled t
  :init
  (setq gcmh-verbose nil)
  :config
  (gcmh-mode 1))
#+END_SRC
* Minibuffer completion
Currently I'm using ~ido-mode~ and ~fido-mode~ to provide completion in the
minibuffer.
~ido-everywhere~ allows you to use ~ido~'s functionality in any function that uses
the minibuffer, not only the ones that are directly supported.
~icomplete-vertical-mode~ is just to show the candidates vertically. It's one of
the things that I missed when switching from ~helm~.
#+BEGIN_SRC emacs-lisp :tangle yes
(ido-mode 1)
(fido-mode 1)
(icomplete-vertical-mode 1)
(ido-everywhere 1)
#+END_SRC
* MermaidJS
[[http://mermaid-js.github.io/mermaid/][MermaidJS]] is a Markdown syntax to generate flowcharts and diagrams.
It's quite handy to use whenever you need to explain complex concepts to other people.

To install it, run the command below.
I'm not installing it automatically when Emacs starts because that takes up init time.
#+BEGIN_SRC shell
npm install -g @mermaid-js/mermaid-cli
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mermaid-mode
:mode "\\.mermaid\\'")

(use-package ob-mermaid
  :config
  ;; We need to install the mermaid CLI to be able to compile Mermaid files into diagrams.
  (setq ob-mermaid-cli-path (string-trim (shell-command-to-string "command -v mmdc"))))
#+END_SRC
* REPL
We need to do some customizations to comint-related buffers to improve performance.
#+BEGIN_SRC emacs-lisp :tangle yes
;; I prefer Emacs state in comint-related buffers.
(evil-set-initial-state 'comint-mode 'emacs)

(defun comint-mode-tweaks ()
  ;; Font-lock is the one that takes the biggest toll on performance.
  (font-lock-mode -1)
  (auto-composition-mode -1)
  (auto-compression-mode -1)
  (column-number-mode -1)
  (auto-save-visited-mode -1)
  )

(add-hook 'comint-mode-hook 'comint-mode-tweaks)
#+END_SRC

* Abbreviations
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq abbrev-file-name "~/.abbrev_defs")
  #+END_SRC
* Hooks
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Prog-mode is from where all the programming modes are derived from.
;; This means that if you call prog-mode-hook, the settings will be
;; applied to ALL programming modes in Emacs.

(defun prog-mode-tweaks ()
  ;; Set line number mode and column number mode for code files
  (display-line-numbers-mode)
  (setq fill-column 80))

(add-hook 'prog-mode-hook 'prog-mode-tweaks)
(add-hook 'text-mode-hook 'column-number-mode)
  #+END_SRC
* Packages
** Major Modes
*** Markdown-mode
  A couple tweaks to make it more Org-like.
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun markdown-mode-tweaks ()
  (visual-line-mode 1)
  (outline-minor-mode 1)
  (auto-fill-mode -1))

(use-package markdown-mode
  :hook ((markdown-mode . markdown-mode-tweaks)
     (gfm-mode . markdown-mode-tweaks))
  :bind
  ("M-<right>" . 'markdown-demote)
  ("M-<left>" . 'markdown-promote)
  ("M-<up>" . 'markdown-move-up)
  ("M-<down>" . 'markdown-move-down)
  ("C-c 1" . 'markdown-insert-header-atx-1)
  ("C-c 2" . 'markdown-insert-header-atx-2)
  ("C-c 3" . 'markdown-insert-header-atx-3)
  :bind (:map evil-normal-state-map
              ("TAB" . 'outline-toggle-children))
  :config
  (setq markdown-fontify-code-blocks-natively t
    markdown-asymmetric-header t
    markdown-header-scaling nil)

  ;; Use fixed-pitch fonts inside code blocks.
  (set-face-attribute 'markdown-code-face nil :inherit 'fixed-pitch))
  #+END_SRC
**** Faces
I couldn't customize this through the ~markdown-header-scaling~ var, so let's try another approach.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/markdown-remap-heading-faces ()
  (face-remap-add-relative 'markdown-header-face-1 :height 2.0)
  (face-remap-add-relative 'markdown-header-face-2 :height 1.7)
  (face-remap-add-relative 'markdown-header-face-3 :height 1.4)
  (face-remap-add-relative 'markdown-header-face-4 :height 1.1)
  (face-remap-add-relative 'markdown-header-face-5 :height 1.0)
  (face-remap-add-relative 'markdown-header-face-6 :height 1.0))

(add-hook 'markdown-mode-hook 'auralcat/markdown-remap-heading-faces)
  #+END_SRC
*** Web-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun web-mode-keybindings ()
  "Define mode-specific keybindings like this."
  (local-set-key (kbd "C-c C-v") 'browse-url-of-buffer)
  (local-set-key (kbd "C-c /") 'sgml-close-tag))

;; Add company backends when loading web-mode.
(defun web-mode-company-load-backends ()
  (company-web-bootstrap+)
  (company-web-fa+))

(add-hook 'web-mode-hook 'web-mode-keybindings)
(add-hook 'web-mode-hook 'web-mode-company-load-backends)

;; Use tidy to check HTML buffers with web-mode.
(eval-after-load 'flycheck
  '(flycheck-add-mode 'html-tidy 'web-mode))
  #+END_SRC
*** Compilation mode tweaks
This is a built-in mode, but I want to change some stuff there.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun compilation-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1))

(add-hook 'compilation-mode-hook 'compilation-mode-tweaks)
;; Use Emacs keys and bindings in compilation-mode and its derived modes.
(add-hook 'compilation-mode-hook 'evil-emacs-state)
(add-hook 'compilation-start-hook 'evil-emacs-state)

;; Make the compilation buffer scroll to the end on command finish
(setq compilation-scroll-output t)
#+END_SRC
*** Elixir-mode
    Elixir support for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package elixir-mode
  :defer t
  :config
  (define-key elixir-mode-map (kbd "C-c C-l") 'inf-elixir-send-line)
  (define-key elixir-mode-map (kbd "C-c C-r") 'inf-elixir-send-region))
    #+END_SRC
*** Nov-mode
This is a mode for reading .epub files.
It's quite comfortable when you want to read longform books in the computer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nov
  :defer t
  :mode "\\.epub\\'"
  :init
  ;; Set the width to 80 chars, this is better to read.
  (setq nov-text-width 80)
  ;; Remove the mode line in the book's buffer.
  (add-hook 'nov-mode-hook #'(lambda ()
                   (setq-local mode-line-format nil)
                   (setq-local show-trailing-whitespace nil)
                   )))
#+END_SRC
*** Makefile-mode
I'm working with Makefiles now, so this is useful.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'makefile-mode-hook #'(lambda () (setq-local indent-tabs-mode t)))
#+END_SRC
*** Js2-mode
    A better default Javascript mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package js2-mode
  :defer t
  :mode "\\.js?\\'"
  :init
  (setq js-indent-level 2))

;; TODO: Look for a better completion for JS modes in Company.
(defun js2-mode-tweaks ()
  ;; Use company-yas as main backend
  (set (make-local-variable 'company-backends) '(company-etags company-yasnippet))
  (company-mode t))

(add-hook 'js2-mode-hook 'js2-mode-tweaks)

;; Set syntax highlight level
(setq js2-highlight-level 3)
    #+END_SRC

*** Enhanced-ruby-mode
    A better ruby-mode.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package enh-ruby-mode
  :defer t)

;; No magic comments, please.
(setq enh-ruby-add-encoding-comment-on-save nil)
(setq ruby-insert-encoding-magic-comment nil)

;; ;; Set it as default mode for Ruby files
;; (add-to-list 'auto-mode-alist
;; '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
;; . enh-ruby-mode))

;; Fallback to vanilla Ruby mode when things go bad
(add-to-list 'auto-mode-alist
         '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
           . ruby-mode))

;; (define-key enh-ruby-mode-map (kbd "M-<down>") 'auralcat/ruby-move-defun-forward)
;; (define-key enh-ruby-mode-map (kbd "M-<up>") 'auralcat/ruby-move-defun-backward)

;; (define-key ruby-mode-map (kbd "M-<down>") 'auralcat/ruby-move-defun-forward)
;; (define-key ruby-mode-map (kbd "M-<up>") 'auralcat/ruby-move-defun-backward)
    #+END_SRC
*** Web Mode
    I use this for HTML files mostly, works good for PHP too.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode
  :ensure t
  :defer t
  :bind (:map web-mode-map
          ("C-<up>"    . web-mode-element-previous)
          ("C-<down>"  . web-mode-element-next)
          ("C-<left>"  . web-mode-element-beginning)
          ("C-<right>" . web-mode-tag-match)
          ("C-S-<up>"  . web-mode-element-parent)
          ("M-<up>"    . web-mode-element-content-select)
          ("C-k"       . web-mode-element-kill)
          ("M-RET"     . complete))

  :init
  ;; File associations
  (add-to-list 'auto-mode-alist '("\\.phtml\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html.erb\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html.eex\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.vue?\\'"   . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx?\\'"  . web-mode))

  ;; Engine associations
  (setq web-mode-engines-alist
    '(("php"    . "\\.phtml\\'")
      ("blade"  . "\\.blade\\.")))

  ;; Highlight tag when editing
  (setq web-mode-enable-current-element-highlight t))

    #+END_SRC
*** YAML-mode
    YAML support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t
  :defer t)
    #+END_SRC
*** CSV-mode
    CSV support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package csv-mode
  :defer t)
    #+END_SRC
** Minor Modes
*** Flycheck Inline
    Shows the error when leaving the point over the place where it occurs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-inline
  :defer t
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
    #+END_SRC
*** Ruby-electric
    Auto-close do-end blocks, as well as braces and parens.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ruby-electric
  :defer t
  :hook ((enh-ruby-mode ruby-mode) . 'ruby-electric-mode)
  :diminish ruby-electric-mode)
    #+END_SRC
*** Mix
A wrapper around Elixir's ~mix~ for Emacs
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mix
  ;; I prefer creating a prefix for these commands because it's 2 key presses
  ;; instead of 3 with evil-leader.
  :config
  (define-prefix-command 'elixir-mix-map)
        (define-key 'elixir-mix-map "t" 'auralcat/mix-test)
        (define-key 'elixir-mix-map (kbd "SPC") 'auralcat/mix-test-current-buffer)
        (define-key 'elixir-mix-map "." 'auralcat/mix-test-current-test)
        (define-key 'elixir-mix-map "f" 'auralcat/elixir-run-mix-format-in-project-root)
        (define-key 'elixir-mix-map "c" 'mix-compile)
        (define-key 'elixir-mix-map "x" 'mix-execute-task)
        (define-key 'elixir-mix-map "w" 'auralcat/mix-test-watch-current-buffer)
        (define-key 'elixir-mix-map (kbd "C-,") 'mix-last-command))

  (add-hook 'elixir-mode-hook #'(lambda ()
                 (local-set-key (kbd "C-,") 'elixir-mix-map)))

(defun auralcat/elixir-run-mix-format-in-project-root (arg)
  "Runs `mix format` ín the project's root directory."
  (interactive "P")
  (if arg
      (projectile-run-shell-command-in-root "mix format --check-formatted")
    (projectile-run-shell-command-in-root "mix format")))

(defun auralcat/elixir--run-mix-format-on-save ()
  "Intended to be used in before-save-hook.
   Runs `mix format` on the buffer if it is visiting an Elixir file."
  (let ((elixir-file-extension-regexp "exs?$")
    )
    (when (and (buffer-file-name) (string-match-p elixir-file-extension-regexp (buffer-file-name)))
      (auralcat/elixir--run-mix-format))))

(defun auralcat/elixir--run-mix-format ()
   "- If the file is in a project, run `mix format` from the project root when saving current Elixir buffer.
    - If the buffer is not visiting a file in a project, run standard `mix format`."
   (if (projectile-project-p)
   (let ((default-directory (projectile-project-root)))
     (message (format "Running mix format on %s" default-directory))
     (shell-command "mix format"))
   (shell-command (format "mix format %s" (buffer-file-name))))
   (message "Elixir files formatted successfully."))

;; Wrappers around mix-test functions to use the umbrella app flag when necessary.
(defun auralcat/mix-test (prefix)
  "A wrapper around mix-test to pick up umbrella apps automatically."
  (interactive "P")
  (if (mix--umbrella-apps)
      (mix-test prefix t)
      (mix-test prefix)))

(defun auralcat/mix-test-current-test (prefix)
  "A wrapper around mix-test-current-test to pick up umbrella apps automatically."
  (interactive "P")
  (if (mix--umbrella-apps)
      (mix-test-current-test prefix t)
      (mix-test-current-test prefix)))

(defun auralcat/mix-test-current-buffer (prefix)
  "A wrapper around mix-test-current-buffer to pick up umbrella apps automatically."
  (interactive "P")
  (if (mix--umbrella-apps)
      (mix-test-current-buffer prefix t)
      (mix-test-current-buffer prefix)))

(defun auralcat/mix-test-watch-current-buffer (prefix)
  "Runs mix test.watch for the current buffer and respects umbrella app strucuture."
  (interactive "P")
  (mix--start
   "test"
   (format "test.watch --seed 0 --max-failures 1 %s" (kill-new (expand-file-name (buffer-file-name))))
   (mix--find-closest-mix-file-dir (expand-file-name (buffer-file-name)))
   prefix))

(add-hook 'after-save-hook 'auralcat/elixir--run-mix-format-on-save)
#+END_SRC

*** Projectile
    Manage projects in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :defer t
  :init
  (setq projectile-keymap-prefix (kbd "C-c p")
    ;; I use Universal ctags, so this needs some adjustment.
    projectile-tags-command "ctags -eR ."
    projectile-switch-project-action 'projectile-vc
    ;; We don't need to be prompted if we want to re-read the tags.
    tags-revert-without-query t))

;; Enable it
(add-hook 'after-init-hook #'projectile-global-mode)
    #+END_SRC
*** Emmet-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package emmet-mode
  :after (:any web-mode)
  :defer t)
    #+END_SRC
*** Highlight-numbers mode
    Sets font lock faces to numbers in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-numbers
  :after (prog-mode)
  :defer t
  :config
  (add-hook 'prog-mode-hook 'highlight-numbers-mode))
    #+END_SRC
*** Flyspell
    Used to check prose.
    I use Markdown to write stuff in English.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flyspell
  :defer t
  :config
  (add-hook 'gfm-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)

  (add-hook 'git-commit-mode-hook 'flyspell-mode))
    #+END_SRC

*** Flycheck
    Syntax checker, replaces flymake
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :defer t
  :config
  ;; turn on flychecking globally
  (add-hook 'after-init-hook #'global-flycheck-mode))
;; Disable rubylint on default for Ruby modes.
;; If you need it, you can enable it locally using C-u C-c ! v.
(defun custom-disabled-ruby-checkers ()
  (add-to-list 'flycheck-disabled-checkers 'ruby-rubylint))
(add-hook 'enh-ruby-mode-hook 'custom-disabled-ruby-checkers)
(add-hook 'ruby-mode-hook 'custom-disabled-ruby-checkers)
    #+END_SRC

*** Company
**** Main Config
     *COMPlete ANYthing* inside Emacs.
     I switched to it because it works in GUI Emacs and ~auto-complete~ didn't at the time.
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :defer t
  :config
  ;; My standard Company configuration
  (setq company-tooltip-limit 20)
  (setq company-show-numbers t)
  (setq company-idle-delay 0)
  (setq company-echo-delay 0))

;; Web-mode needs HTML and CSS completions.
;; JS is not satisfactory at this point IMO
(defun web-mode-tweaks ()
  (require 'company-web-html)
  (set (make-local-variable 'company-backends) '(company-web-html company-css))
  (emmet-mode 1)
  (company-mode t))

;; Completion for Ruby mode
(defun ruby-mode-tweaks ()
  ;; Increase the min prefix length so it doesn't clash with most used keywords, like def.
  (set (make-local-variable 'company-minimum-prefix-length) 4)
  (set (make-local-variable 'company-backends) '(company-etags company-capf company-dabbrev company-yasnippet))
  (subword-mode 1))

;; Completion for REPL Ruby mode
(defun inf-ruby-mode-tweaks ()
  (set (make-local-variable 'company-minimum-prefix-length) 2)
  (set (make-local-variable 'company-backends) '(company-capf company-etags company-dabbrev company-yasnippet))
  (subword-mode 1))

;; General text writing completion (uses dabbrev and filename completion)
(defun human-language-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-dabbrev company-capf company-files))
  ;; If you write a word with 3 letters, it's better to use 'complete, I think.
  ;; Company-mode is meant for longer words and those with hard spelling IMO.
  (set (make-local-variable 'company-minimum-prefix-length) 4)
  (setq fill-column 80))

;; Shell completion
(defun shell-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-capf company-files)))

;; Elisp completion
(defun elisp-tweaks ()
  (set (make-local-variable 'company-minimum-prefix-length) 5)
  (set (make-local-variable 'company-backends) '(company-elisp company-etags company-yasnippet)))

;; Add tweaks
(add-hook 'enh-ruby-mode-hook 'ruby-mode-tweaks)
(add-hook 'inf-ruby-mode-hook 'inf-ruby-mode-tweaks)
(add-hook 'ruby-mode-hook 'ruby-mode-tweaks)
(add-hook 'elixir-mode-hook 'ruby-mode-tweaks)
(add-hook 'shell-mode-hook 'shell-mode-tweaks)
(add-hook 'emacs-lisp-mode-hook 'elisp-tweaks)
(add-hook 'ielm-mode-hook 'elisp-tweaks)

;; Human language writing hooks
(add-hook 'org-mode-hook 'human-language-mode-tweaks)
(add-hook 'markdown-mode-hook 'human-language-mode-tweaks)

(add-hook 'org-mode-hook 'variable-pitch-mode)
(add-hook 'org-english-mode-hook 'variable-pitch-mode)
(add-hook 'markdown-mode-hook 'variable-pitch-mode)
(add-hook 'git-commit-setup-hook 'variable-pitch-mode)

;; Apib mode should come with its own customizations:
;; - Monospace fonts
;; - No auto-fill
;; - Line numbers on the side
(add-hook 'apib-mode-hook #'(lambda ()
                  (variable-pitch-mode 0)
                  (auto-fill-mode 0)
                  (display-line-numbers-mode 0)))

;; Web-mode completions
(use-package company-web
  :after (:all company-mode web-mode)
  :defer t)

;; Company statistics package
(use-package company-statistics
  :after (company-mode)
  :defer t
  :config
(company-statistics-mode))

;; Company with prescient.el offers better sorting of completion candidates.
;; I don't know if it clashes with company-statistics.
(use-package company-prescient
  :after (company-mode)
  :defer t
  :config
  (company-prescient-mode))
     #+END_SRC
*** Keyfreq
    Shows most used commands in editing session.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package keyfreq
  :config
  ;; Ignore arrow commands and self-insert-commands
  (setq keyfreq-excluded-commands
    '(self-insert-command
      org-self-insert-command
      weechat-self-insert-command
      isearch-printing-char
      abort-recursive-edit
      company-ignore
      ))

  ;; Activate it
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
    #+END_SRC
*** Diminish
    Free some space in the mode line removing superfluous mode indications.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  :ensure t
  :defer t
  ;; These are loaded at startup, I prefer declaring everything here.
  :diminish flycheck-mode
  :diminish projectile-mode
  :diminish company-mode
  :diminish auto-revert-mode
  :diminish auto-fill-mode
  :diminish abbrev-mode)
;; These are loaded in other moments
(eval-after-load "editorconfig" '(diminish 'editorconfig-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
    #+END_SRC
*** Editorconfig
    Helps developers define and maintain consistent coding styles
    between different editors and IDEs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :after (prog-mode)
  :ensure t
  :defer t
  :config
  (editorconfig-mode 1))
    #+END_SRC
*** Nyan-mode
      Put a Nyan Cat in your mode line! :3
      #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nyan-mode
    :init
    ;; This is to avoid trouble with mode line displays.
    ;; Nyan-mode changes the mode-line-position variable, where the line
    ;; number and column numbers are displayed.
    (add-hook 'nyan-mode-hook 'line-number-mode)
    (add-hook 'nyan-mode-hook 'column-number-mode)
    :config
    (nyan-mode 1))
      #+END_SRC
*** Mode Icons
    Indicate modes in the mode line using icons
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package mode-icons
  :init
  (mode-icons-mode))
    #+END_SRC
** Utilities
*** Play nice with ASDF
I found this manual package called[[https://github.com/tabfugnic/asdf.el/][ asdf.el]] that makes Emacs identify binaries
installed through ASDF in the system.

You just need to make sure that the cloned repo is in your ~load-path~.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/my-dotfiles/.emacs.d/manual-packages/emacs-asdf")
  (require 'asdf)
  (asdf-enable)
#+END_SRC
*** Expand-region
This one is a classic in the Emacs community.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+END_SRC
*** Ace Jump
Allows you to move anywhere in the visible portion of the buffer (or any
frame you got in your screens) using at least 3 keystrokes.

This is pretty useful for when you want to jump to a different section in
another window or even a frame.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-jump-mode
  :after (evil)
  :bind
  ("C-c SPC" . ace-jump-mode)
  ("M-3" . ace-jump-mode)
  (:map org-mode-map
    ("C-c SPC" . ace-jump-mode))
  :config
  ;; Save the position of the previous mark as a jump position for Evil.
  ;; With that, we can cycle through where ace-jump was called from using C-i and C-o.
  (defadvice ace-jump-mode (before ace-jump-mode-advice)
    (evil--jumps-push))
  (ad-activate 'ace-jump-mode))
#+END_SRC
*** Ace Window
I'm using ~other-frame~ quite a lot recently, and this is an upgrade over the
standard function since it works the same way if you have 2 windows or frames,
but it lets you select which window you want to jump to if you have more than 2
windows or frames open.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-window
  :bind ("C-M-o" . ace-window))
#+END_SRC

*** Evil-inflection
This is a wrapper around the ~string-inflection~ package for ~evil-mode~.
You get both the ~string-inflection~ package and a keybinding to use it in ~evil-mode.~
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-string-inflection)
#+END_SRC
*** Notmuch
Read mail inside Emacs!
This is great for opensource projects and work.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package notmuch
  :defer t
  :config
  (defun my-notmuch-show-view-as-patch ()
    "View the the current message as a patch."
    (interactive)
    (let* ((id (notmuch-show-get-message-id))
       (msg (notmuch-show-get-message-properties))
       (part (notmuch-show-get-part-properties))
       (subject (concat "Subject: " (notmuch-show-get-subject) "\n"))
       (diff-default-read-only t)
       (buf (get-buffer-create (concat "*notmuch-patch-" id "*")))
       (map (make-sparse-keymap)))
      (define-key map "q" 'notmuch-bury-or-kill-this-buffer)
      (switch-to-buffer buf)
      (let ((inhibit-read-only t))
    (erase-buffer)
    (insert subject)
    (insert (notmuch-get-bodypart-text msg part nil)))
      (set-buffer-modified-p nil)
      (diff-mode)
      (lexical-let ((new-ro-bind (cons 'buffer-read-only map)))
    (add-to-list 'minor-mode-overriding-map-alist new-ro-bind))
      (goto-char (point-min))))
  (define-key 'notmuch-show-part-map "d" 'my-notmuch-show-view-as-patch))
#+END_SRC
*** Exec path from shell
  Replicates terminal env vars in graphical Emacs.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :defer t
  :init
  (exec-path-from-shell-initialize))
  #+END_SRC
*** Git-Link
Create links to Github/GitLab files from the comfort of your Emacs buffer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-link
  :defer t)
#+END_SRC
*** Magit delta
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-delta
  :ensure t
  :hook (magit-mode . magit-delta-mode))
#+END_SRC
*** Smartparens
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :hook ((prog-mode inf-elixir-mode outline-mode markdown-mode) . 'smartparens-mode)
  :config
  (require 'smartparens-config))
#+END_SRC

*** Yafolding
    Code folding in Emacs.
    Takes some configuration to use it with evil, but works fine for Elixir buffers.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yafolding
  :hook (prog-mode . yafolding-mode)
  :defer t
  :bind (:map evil-normal-state-map
          ("zo" . 'yafolding-show-element)
          ("zc" . 'yafolding-hide-element)
          ("za" . 'yafolding-toggle-element)
          ("zA" . 'yafolding-toggle-all)
          ("zr" . 'yafolding-show-all)
          ("zm" . 'yafolding-hide-all)
          ))
    #+END_SRC
*** Olivetti mode
This is great to concentrate on text when you want to write prose.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package olivetti
  :config
  (setq olivetti-style 'fancy))

(defun auralcat/set-up-olivetti-mode-init ()
  "Initialization steps for olivetti-mode."
  (setq olivetti-body-width 104)
  (olivetti-mode 'toggle))

(add-hook 'outline-mode-hook 'auralcat/set-up-olivetti-mode-init)
;; Setting this up for only the parent mode should do the trick.
(add-hook 'markdown-mode-hook 'auralcat/set-up-olivetti-mode-init)
#+END_SRC
*** Golden Ratio Mode
    Splits windows using the [[https://en.wikipedia.org/wiki/Golden_ratio][Golden Ratio]].
    This makes the focused window a bit larger than usual and the
    smaller ones are easier to read. It makes the multi-window
    experience more pleasing to the eye. Yeah, nature!
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package golden-ratio
  ;; Play nice with ace-jump.
  :hook ((ace-jump-mode-end) . 'golden-ratio)
  :diminish golden-ratio-mode
  :config
  (setq golden-ratio-extra-commands
    (append golden-ratio-extra-commands '(magit-status aw-flip-window)))
  (golden-ratio-mode 1))
    #+END_SRC

*** Projectile Rails
    Rails utilities for Projectile-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile-rails
  :after (projectile)
  :defer t
  :init
  (add-hook 'ruby-mode-hook 'projectile-rails-mode)
  (add-hook 'enh-ruby-mode-hook 'projectile-rails-mode)

  (evil-leader/set-key-for-mode 'ruby-mode "r" 'projectile-rails-command-map))
    #+END_SRC
*** Bundler
    Interact with Bundler from Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package bundler
  :defer t)
    #+END_SRC
*** Evil-numbers
    Increment and decrement numbers like in Vim.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-numbers
  :after (evil)
  :defer t
  :config
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-e") 'evil-numbers/dec-at-pt))
    #+END_SRC

*** Diff-Highlight
    Highlights the changed content in buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :ensure
  :defer t
  :config
  ;; ((defun hl-diff-tweaks()
  ;;   (diff-hl-mode t)
  ;;   (diff-hl-flydiff-mode t))
  ;;   (add-hook 'prog-mode-hook 'hl-diff-tweaks))
  )
    #+END_SRC
*** Evil-Matchit
    Adds more matching objects for the % operator in evil, such as
    def-end in Ruby/Python and HTML tags.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-matchit
  :after (evil)
  :defer t
  :ensure t
  :init
  (global-evil-matchit-mode 1))
    #+END_SRC
*** Restart Emacs
    Restart Emacs from within Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package restart-emacs
  :defer t)
    #+END_SRC
*** Rainbow Delimiters
    Highlight parentheses, brackets and braces according to their
    depth.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :after (prog-mode)
  :defer t
  :init
  ;; Add this to prog-mode
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'slime-repl-mode-hook #'rainbow-delimiters-mode))
    #+END_SRC
*** Git Gutter
    Shows (and enables you to navigate between) parts of the code
    which where changed comparing to the current revision in a
    version-controlled project.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-gutter
  :when window-system
  :hook ((prog-mode text-mode) . 'git-gutter-mode)
  :diminish ""
  :config
  (use-package git-gutter-fringe
    :after (git-gutter)
    :defer t
    :ensure t
    :init
    (require 'git-gutter-fringe)
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added
    [224 224 224 224 224 224 224 224 224 224 224 224 224
         224 224 224 224 224 224 224 224 224 224 224 224]
    nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:modified
    [224 224 224 224 224 224 224 224 224 224 224 224 224
         224 224 224 224 224 224 224 224 224 224 224 224]
    nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:deleted
    [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
    nil nil 'center)))
  ;; Adding evil-mode bindings
  (define-key evil-normal-state-map (kbd "g h") 'git-gutter:previous-hunk)
  (define-key evil-normal-state-map (kbd "g H") 'git-gutter:next-hunk)
  (define-key evil-normal-state-map (kbd "g @") 'git-gutter:popup-hunk))
    #+END_SRC

*** Magit
    How to win at Git from Emacs.
    The configuration for each part is below in separate headings.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :defer t
  :config
  ;; Highlight what changed in diffs.
  (setq magit-diff-refine-hunk t))
    #+END_SRC
**** Commit configuration
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-commit
  :after (magit)
  :hook (git-commit-mode . git-commit-tweaks)
  :custom (git-commit-summary-max-length 50)
  :preface
  (defun git-commit-tweaks ()
    "Ensures that the commit body does not exceed 72 characters."
    (setq fill-column 72)
    (set (make-local-variable 'company-backends) '(company-dabbrev company-capf company-files))
    (set (make-local-variable 'company-minimum-prefix-length) 2)
    (setq-local comment-auto-fill-only-comments nil)
    (evil-set-initial-state 'git-commit-mode 'emacs)
    ))
     #+END_SRC
**** Viewing diffs
#+BEGIN_SRC emacs-lisp :tangle yes
;; Wrap those long lines.
(add-hook 'magit-diff-mode-hook 'visual-line-mode)
#+END_SRC
**** Open files for code review
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/magit-open-changed-files-from-main (args)
  "Opens the buffers visiting files that were changed compared to the main branch in the current branch.
   Requires M-x server-start first.

   It's highly recommended to update and pull changes from the remote repository into the master/main branch before running this command."
  (interactive "P")
  (let* ((default-directory (projectile-project-root))
     (git-changed-files-command "git --no-pager diff --name-only main $(git branch --show-current)"))
    (message "Opening changed files in the current branch compared to the master/main branch...")
    (projectile-run-async-shell-command-in-root (format "find $(%s) -exec emacsclient -n {} \\;" git-changed-files-command))))
#+END_SRC
*** Yasnippets
    It originally came with company-mode, it's handy to write faster
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet-snippets)
(use-package yasnippet-classic-snippets)

(defun do-not-add-newline-for-snippets ()
  "What is says on the tin."
  (setq-local require-final-newline nil)
  )

(add-hook 'snippet-mode-hook 'do-not-add-newline-for-snippets)
    #+END_SRC
*** Circadian
    Theme changer for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package circadian
  :ensure t
  :config
  (cond
   ;; Personal Linux machine
   ((and (string-equal system-name auralcat/personal-system-name) (eq system-type 'gnu/linux))
    (setq circadian-themes '((:sunrise . solarized-light)
                 (:sunset  . solarized-dark))))
   ;; Work Linux machine
   ((and (string-equal system-name auralcat/work-system-name) (eq system-type 'gnu/linux))
    (setq circadian-themes '((:sunrise . modus-operandi)
                 (:sunset  . modus-vivendi)))))
  (circadian-setup))
    #+END_SRC
*** Anzu
    Show search result count in the mode line.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-anzu
  :after (evil)
  :config
  (global-anzu-mode))
    #+END_SRC
*** Org-mode GFM exporter
GFM stands for *Github Flavored Markdown*. It's a nice exporter not just for that
use case though, since it removes the line wraps on exporting.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-gfm
  :defer t)
#+END_SRC
*** sqlformat
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sqlformat
  :commands (sqlformat sqlformat-buffer sqlformat-region)
  :hook (sql-mode . sqlformat-on-save-mode)
  :init
  ;; This is for Postgres.
  (setq sqlformat-command 'pgformatter
    sqlformat-args '("-s2" "-g")))
#+END_SRC
*** Auto package update
I honestly don't know why Emacs doesn't support this out of the box yet, but oh well.
You can put ~auto-package-update-async~ in the ~midnight-hook~.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-package-update
  :config
  (auto-package-update-at-time "11:30am")
  (setq auto-package-update-delete-old-versions t))
#+END_SRC
* Function Aliases
  #+BEGIN_SRC emacs-lisp :tangle yes
;; This is how you define aliases for Elisp functions. These are useful for when
;; you don't need to bind a command to a specific key, but you call that
;; function through M-x often.
(defalias 'plp 'package-list-packages)
(defalias 'kfs 'keyfreq-show)
  #+END_SRC
* Themes
  Remember to _defer_ the loading of the theme packages, otherwise the
  faces might get mixed up and look ugly.

  This function makes it easier to change themes quickly. You can bind it to a
  keychord or whatnot and use it as you wish.

  NOTE: If you want to run extra functions when changing themes,
  *you should add the function calls to the change theme function below*,
  otherwise the changes you want to happen won't take effect!
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/set-fringe-face-to-default-bg ()
  "Sets the fringe's background to the current theme's background color for the 'default face."
  (set-face-attribute 'fringe nil :background (face-attribute 'default :background)))

;; Set the fringe face function Circadian's change hook.
;; That way whenever the theme changes automatically, the fringe gets updated as
;; well.
(add-hook 'circadian-after-load-theme-hook 'auralcat/set-fringe-face-to-default-bg)

(defun auralcat/change-theme (new-theme)
  "Disables the current theme in the session, loads and enables the NEW-THEME."
  ;; This is the code Emacs uses to load themes in custom.el
  (interactive
   (list
    (intern (completing-read "Change to theme: "
                 (mapcar #'symbol-name
                     (custom-available-themes))))))
  (let* (
     (current-theme (car custom-enabled-themes))
     (new-theme-loaded-p (memq new-theme custom-enabled-themes)))
    (disable-theme current-theme)
    (if new-theme-loaded-p
    (enable-theme new-theme)
      (load-theme new-theme))
    ;; We should do this here because not every theme defines a fringe face and
    ;; I customized the fringe on my end.
    (auralcat/set-fringe-face-to-default-bg))
  ;; We should also set the preferred fonts here because this function does not
  ;; run any hooks.
  (auralcat--set-preferred-fonts-for-current-theme))

;; Add the hook on circadian
;; Bind it to a keychord.
(global-set-key (kbd "M-`") 'auralcat/change-theme)
  #+END_SRC
** Abyss
   Dark contrast theme
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package abyss-theme :ensure :defer t)
   #+END_SRC
** Twilight Bright
   A port of the theme from TextMate.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package twilight-bright-theme :defer t)
   #+END_SRC
** Gruvbox
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gruvbox-theme :defer t)
#+END_SRC
** Solarized themes
These are the official ones.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package solarized-theme :defer t)
#+END_SRC
** Modus themes
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package modus-themes
  :init
  (setq modus-themes-success-deuteranopia t))
#+END_SRC
* Fonts
It's better to set the fonts here instead of hard-coding them in init.el or in
the themes themselves.
** Default
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set fonts for each system if the extra ones are installed.
;; Otherwise use the system's default fonts.
(defun auralcat--set-fixed-pitch-fonts (font-name height)
  "Sets the fixed pitch fonts with the FONT-NAME family and the height as HEIGHT for both the 'default and 'fixed-pitch faces."
  (set-face-attribute 'default nil :family font-name :height height)
  (set-face-attribute 'fixed-pitch nil :family font-name :height height)
  (set-face-attribute 'org-block nil :family font-name :height height)
  (set-face-attribute 'org-table nil :family font-name :height height))

(defun auralcat--set-preferred-fonts-for-current-theme ()
  "Sets the preferred fonts for the current theme depending on the system Emacs is used in."
  (cond
   ((eq system-type 'gnu/linux)
    ;; This is because pure GTK Emacs does not play well with multiple frames.
    ;; This is not a problem for the personal setup, but I use 2 displays at work.
    (if (functionp 'pgtk-next-frame)
    (auralcat--set-fonts-for-gnu-linux 100)
      (auralcat--set-fonts-for-gnu-linux 120)))))

(defun auralcat--set-fonts-for-gnu-linux (height)
  "Sets fonts for GNU/Linux machines with HEIGHT."
  (if (font-info "Fantasque Sans Mono")
      (auralcat--set-fixed-pitch-fonts "Fantasque Sans Mono" height)
    (auralcat--set-fixed-pitch-fonts "Ubuntu Mono" height)))

;; Use Helvetica as the sans-serif font when available.
(when (font-info "Helvetica")
    (set-face-attribute 'variable-pitch nil :family "Helvetica" :height 100)
    ;; Use the Helvetica font as well for Emacs 29 mode line.
    (set-face-attribute 'mode-line nil :family "Helvetica"))

  #+END_SRC
* Graphical
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set font in graphical mode
(when (display-graphic-p)
  ;; Remove menu and scroll bars in graphical mode
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  ;; Maximize frame on startup
  (toggle-frame-maximized)
  ;; Space lines and bask in the gloriousness of graphical mode.
  ;; 0.4 feels better for prose, and 0.2 is fine for code.
  (add-hook 'prog-mode-hook #'(lambda () (setq line-spacing 0.2)))
  (add-hook 'comint-mode-hook #'(lambda () (setq line-spacing 0.2)))
  (add-hook 'text-mode-hook #'(lambda () (setq line-spacing 0.6))))
  #+END_SRC
* Multiplexing
This involves window and tab management.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Set rules for displaying buffers in windows.
(setq display-buffer-alist
      ;; Press q in the Magit buffer and the window vanishes!
      `(("^magit: .*$"
     (display-buffer-reuse-mode-window display-buffer-reuse-window display-buffer-at-bottom)
     (window-height . 0.5)
     (window-parameters . ((delete-window . t)))
     )
    ("^magit-diff: .*$"
     (display-buffer-use-some-frame display-buffer-reuse-mode-window display-buffer-reuse-window)
     (reusable-frames . t)
     (window-parameters . ((delete-window . t)))
     )
    ("^magit-revision: .*$"
     (display-buffer-reuse-mode-window display-buffer-reuse-window display-buffer-use-some-frame)
     (reusable-frames . t)
     (window-parameters . ((delete-window . t)))
     )
    ;; A buffer with unit test results: they're easier to read in another frame.
    ("^\\*mix .*\\*$"
     (display-buffer-use-some-frame display-buffer-in-tab display-buffer-reuse-mode-window display-buffer-reuse-window)
     (reusable-frames . t)
     (tab-name . "*Test results*")
     (inhibit-same-window . t)
     )
    ;; Search buffers tend to be more useful when they're in the same frame as the code.
    ("\\(^\\*ag search text:.*\\*$\\|\\^*Occur.*\\*$\\)"
     (display-buffer-reuse-mode-window display-buffer-reuse-window)
     )
    ("^\\*Org .*Export\\*$"
     (display-buffer-reuse-window display-buffer-in-side-window)
     (window-height . 0.5)
     (window-parameters . ((delete-window . t)))
     )))
#+END_SRC

* Keybindings
 #+BEGIN_SRC emacs-lisp :tangle yes
;; Translate the compose keys
(define-key key-translation-map (kbd "¹") (kbd "M-1"))
(define-key key-translation-map (kbd "²") (kbd "M-2"))
(define-key key-translation-map (kbd "³") (kbd "M-3"))
(define-key key-translation-map (kbd "£") (kbd "M-4"))
(define-key key-translation-map (kbd "¢") (kbd "M-5"))
(define-key key-translation-map (kbd "ð") (kbd "M-d"))
(define-key key-translation-map (kbd "ß") (kbd "M-s"))
(define-key key-translation-map (kbd "»") (kbd "M-x"))
(define-key key-translation-map (kbd "ŋ") (kbd "M-g"))
(define-key key-translation-map (kbd "<M-S-dead-grave>") (kbd "M-`"))
(define-key key-translation-map (kbd "“") (kbd "M-v"))
(define-key key-translation-map (kbd "‘") (kbd "M-S-v"))
(define-key key-translation-map (kbd "C-“") (kbd "C-M-v"))
(define-key key-translation-map (kbd "C-‘") (kbd "C-S-M-v"))
(define-key key-translation-map (kbd "æ") (kbd "M-a"))
(define-key key-translation-map (kbd "ŧ") (kbd "M-t"))
(define-key key-translation-map (kbd "C-æ") (kbd "C-M-a"))
(define-key key-translation-map (kbd "Æ") (kbd "M-S-a"))
(define-key key-translation-map (kbd "°") (kbd "M-e"))
(define-key key-translation-map (kbd "C-°") (kbd "C-M-e"))
(define-key key-translation-map (kbd "đ") (kbd "M-f"))
(define-key key-translation-map (kbd "ª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "C-đ") (kbd "C-M-f"))
(define-key key-translation-map (kbd "C-ª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "”") (kbd "M-b"))
(define-key key-translation-map (kbd "’") (kbd "M-S-b"))
(define-key key-translation-map (kbd "C-”") (kbd "C-M-b"))
(define-key key-translation-map (kbd "C-’") (kbd "C-M-S-b"))
(define-key key-translation-map (kbd "©") (kbd "M-c"))
(define-key key-translation-map (kbd "C-©") (kbd "C-M-c"))
(define-key key-translation-map (kbd "C-ß") (kbd "C-M-s"))
(define-key key-translation-map (kbd "C-®") (kbd "C-M-r"))
(define-key key-translation-map (kbd "®") (kbd "M-r"))
(define-key key-translation-map (kbd "M-°") (kbd "M-S-e"))
;; C-M-number translations.
(define-key key-translation-map (kbd "⅜") (kbd "M-%"))
(define-key key-translation-map (kbd "C-⅜") (kbd "C-M-%"))
(define-key key-translation-map (kbd "¼") (kbd "M-$"))
(define-key key-translation-map (kbd "C-¼") (kbd "C-M-$"))
(define-key key-translation-map (kbd "¾") (kbd "M-#"))
(define-key key-translation-map (kbd "C-¾") (kbd "C-M-#"))
(define-key key-translation-map (kbd "½") (kbd "M-@"))
(define-key key-translation-map (kbd "C-½") (kbd "C-M-@"))
(define-key key-translation-map (kbd "¡") (kbd "M-!"))
(define-key key-translation-map (kbd "C-¡") (kbd "C-M-!"))

;; Some speed commands
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'ido-switch-buffer)
(global-set-key (kbd "M-4") 'switch-to-buffer-other-window)
(global-set-key (kbd "M-5") 'tab-bar-switch-to-tab)

(define-key comint-mode-map (kbd "M-1") 'delete-other-windows)
(define-key comint-mode-map (kbd "M-4") 'switch-to-buffer-other-window)

;; Improve the case change commands with built-in DWIM
(global-set-key (kbd "M-u") 'upcase-dwim)
(global-set-key (kbd "M-l") 'downcase-dwim)
(global-set-key (kbd "M-c") 'capitalize-dwim)

;; Resize the frame with ease
(global-set-key [M-f11] (quote toggle-frame-fullscreen))
(global-set-key [M-f10] (quote toggle-frame-maximized))

(global-set-key (kbd "M-\"") (quote abbrev-prefix-mark))

;; Switch windows and frames
(define-key global-map (kbd "M-o") 'other-window)

;; Scroll other windows' pages easier
(define-key global-map (kbd "M-]") 'scroll-other-window)
(define-key global-map (kbd "M-[") 'scroll-other-window-down)

;; Unfill region
(define-key global-map "\C-\M-q" 'unfill-region)

;; Mapping AltGr-d to delete-other-windows,
;; Another symbol I don't use often.
(global-set-key [240] (quote delete-other-windows))

;; Map the Home and End keys to go to the beginning and end of the buffer
(global-set-key [home] (quote beginning-of-buffer))
(global-set-key [end] (quote end-of-buffer))

;; Move to beginning of line or indentation
(defun back-to-indentation-or-beginning () (interactive)
       (if (= (point) (progn (back-to-indentation) (point)))
       (beginning-of-line)))

;; We need this to get back to the beginning of the indentation or first word of the line.
(global-set-key (kbd "C-a") (quote back-to-indentation-or-beginning))

;; Hippie-Expand: change key to M-SPC; Replace dabbrev-expand
(global-set-key "\M- " 'hippie-expand)
(global-set-key "\M-/" 'hippie-expand)

;; Eshell configuration
(defun eshell-tweaks ()
  "Tweaks for the Emacs shell"
  (evil-set-initial-state 'shell-mode 'emacs))
(add-hook 'shell-mode-hook 'eshell-tweaks)

;; Evaluate buffer using SPC SPC, depending on major mode.
(evil-leader/set-key-for-mode 'emacs-lisp-mode "SPC" 'eval-buffer)
(evil-leader/set-key-for-mode 'enh-ruby-mode "SPC" 'ruby-send-buffer-and-go)
(evil-leader/set-key-for-mode 'ruby-mode "!" 'auralcat/ruby/add-byebug-line)
(evil-leader/set-key-for-mode 'ruby-mode "SPC" 'ruby-send-buffer-and-go)
(evil-leader/set-key-for-mode 'python-mode "SPC" 'python-shell-send-buffer)
(evil-leader/set-key-for-mode 'js2-mode "SPC" 'js-comint-send-buffer)
(evil-leader/set-key-for-mode 'elixir-mode "!" 'auralcat/elixir-iex-pry)
(evil-leader/set-key-for-mode 'elixir-mode "SPC" 'inf-elixir-send-buffer)
  #+END_SRC
* Org-mode
** Main configuration
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Some bindings for Emacs mode.
;; I've noticed that Org seems easier to navigate with Emacs bindings instead of Evil.
(define-key global-map (kbd "C-c a") 'org-agenda)
(define-key global-map (kbd "C-c k") 'org-capture)

;; More customizations for evil-mode.
(define-key evil-normal-state-map (kbd "TAB") 'org-cycle)

;; Start indented, with inline images, and don't show emphasis markers.
(setq org-startup-indented t
      org-startup-with-inline-images t
      org-hide-emphasis-markers t)

;; We don't need Flycheck in org-mode buffers. Usually.
(add-hook 'org-mode-hook #'(lambda () (flycheck-mode 0)))

;; Change the end of collapsed headings to an arrow.
(setq org-ellipsis "⤵")

;; Keep agenda file list in a single file so I can publish my config.
;; DO NOT use C-c [ or C-c ] to add/remove files to the agenda otherwise
;; Emacs will write the var to init.el
(setq org-agenda-files "~/file-bouncer/org-agenda-file-list.org")

;; Don't split my lines, thx.
(setq org-M-RET-may-split-line nil)

;; Truncate long task names
(setq org-clock-heading-function
      #'(lambda ()
    (let ((str (nth 4 (org-heading-components))))
      (concat (truncate-string-to-width str 27) "...")
      )))

;; Organize the bindings
;; Open subheading with C-c RET and invert with M-RET
(define-key org-mode-map (kbd "C-c RET") 'org-ctrl-c-ret)
(define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)

;; Use C-RET to complete words in Org-mode
(define-key org-mode-map (kbd "C-RET") 'complete)

;; Map C-S-enter to org-insert-todo-subheading
(define-key org-mode-map (kbd "<C-S-return>") 'org-insert-todo-subheading)

;; Use Emacs mode in Org-capture buffers and notes buffer
(add-hook 'org-capture-mode-hook 'evil-emacs-state)

;; Idiot-proofing my configs
(define-key org-mode-map (kbd "C-c ]") nil)
(define-key org-mode-map (kbd "C-c [") nil)

;; Simplify org-todo in org-mode buffers with <leader> t
(evil-leader/set-key-for-mode 'org-mode "t" 'org-todo)

;; Log when a task was done and when it was rescheduled.
(setq org-log-done 'time)
(setq org-log-reschedule 'time)

;; Don't write inside invisible area when collapsing headings!
(setq org-catch-invisible-edits 'error)

;; Define a standard format for Org's column view
(setq org-columns-default-format "%50ITEM(Item) %EFFORT(Effort) %CLOCK(Time Spent)")

;; Set agenda as sticky. This makes the buffers persistent, and load faster if
;; you open them all the time.
(setq org-agenda-sticky t)
   #+END_SRC
** Org-agenda configuration
Colorize the agenda: https://llazarek.com/2018/07/improving-the-agenda.html
#+BEGIN_SRC emacs-lisp :tangle yes
(defun ll/org/agenda/color-headers-with (tag fg-col bg-col)
  "Color agenda lines matching TAG with color FG-COL."
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward tag nil t)
    (unless (find-in-line "\\[#[A-Z]\\]")
      (let ((todo-end (or (ll/org/agenda/find-todo-word-end)
              (point-at-bol)))
        (tags-beginning (or (find-in-line " :" t)
                (point-at-eol))))
    (add-text-properties todo-end
                 tags-beginning
                 `(face (:foreground ,fg-col :background ,bg-col)))))))

;; Helper definitions
(setq ll/org/agenda-todo-words
      '("TODO" "GOAL" "NEXT" "STARTED" "WAITING" "REVIEW" "SUBMIT"
    "DONE" "DEFERRED" "CANCELLED"))
(defun find-in-line (needle &optional beginning count)
  "Find the position of the start of NEEDLE in the current line.
  If BEGINNING is non-nil, find the beginning of NEEDLE in the current
  line. If COUNT is non-nil, find the COUNT'th occurrence from the left."
  (save-excursion
    (beginning-of-line)
    (let ((found (re-search-forward needle (point-at-eol) t count)))
      (if beginning
      (match-beginning 0)
    found))))
(defun ll/org/agenda/find-todo-word-end ()
  (reduce (lambda (a b) (or a b))
      (mapcar #'find-in-line ll/org/agenda-todo-words)))

;; Load my tag colors
(load "~/.agenda-colors")
#+END_SRC

** Tables
Use the fixed-pitch font for tables.
#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+END_SRC
** Capture templates
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Load them from a separate file.
(load "~/.org-capture-templates.el")
   #+END_SRC
** Org-bullets
   Change org-mode's *s to UTF-8 chars
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-bullets
  :init
  (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1)))
  ;; Fallback bullets.
  (setq org-bullets-bullet-list (quote ("✿" "❀" "◉" "○" "✸")))
  )
   #+END_SRC
** Org-babel
*** General settings
- Do not ask me if I want to run the source block
- Output the results in _scripting_ mode, instead of eval mode.
- Wrap them in an example block (for exporting)
  Important: the default header args will be:
  =:noweb :results output verbatim replace :exports both=
- Also display the contents of the source code block in a monospace font when possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-org-confirm-babel-evaluate (lang body)
  "Don't confirm squat."
  (not (member lang '("sh" "elisp" "ruby" "elixir" "shell"))))

;; A few more tweaks for org-babel.
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate
      org-src-preserve-indentation t
      org-babel-min-lines-for-block-output 1
      org-babel-default-header-args
      (cons '(:noweb . "yes")
        (assq-delete-all :noweb org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:exports . "both")
        (assq-delete-all :exports org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:results . "output verbatim replace")
        (assq-delete-all :results org-babel-default-header-args)))
#+END_SRC
*** Elixir
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-elixir)
    #+END_SRC
*** Load languages
    #+BEGIN_SRC emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (shell . t)
   (python . t)
   (sql . t)
   (ruby . t)
   (elixir . t)
   (plantuml . t)
   (dot . t)
   ))
    #+END_SRC
** Faces
*** Fontify DONE items
This removes the focus on done items (either checklist items or headings). I
think this is a nice quality-of-life improvement for using ~org-mode~ as a TODO
tracker.

The only adjustment I did for my specific case is adding an iteration over the
list of org-modes I use, since I created ~org-english-mode~ for my own use.

#+BEGIN_SRC emacs-lisp :tangle yes
;; We are using an _anonymous face_ to have this customization work on startup.
(dolist (major-mode '(org-english-mode org-mode))
  (font-lock-add-keywords
 major-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 '(:strike-through t :inherit 'font-lock-comment-face) prepend))
 'append))
#+END_SRC
#+END_SRC
* HOWM
Quote from https://leahneukirchen.org/blog/archive/2022/03/note-taking-in-emacs-with-howm.html:
#+begin_quote
~howm~ is short for =Hitori Otegaru Wiki Modoki=, which roughly translates to
=Single-user Easy Wiki Mode=.
#+end_quote

It's a note-taking mode from the Japan Emacs community. The mode has been around
for the last 20 years, and it does not force any standards on you to write
notes, except for the note file structure.
You can customize it however you want, and even use ~org-mode~ to write the notes
if you wish (!)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package howm
  :ensure t
  :hook ((howm-menu-mode . evil-emacs-state)
         (howm-view-summary-mode . evil-emacs-state))
  :demand t
  :init
  ;; Use this to set which major mode name you would like to write your notes in through the pattern in file-name-alist.
  ;; In this case I'm using .org.en to open these files in org-english-mode.
  (setq howm-file-name-format "%Y/%m/%Y-%m-%d-%H%M%S.org.en")
  ;; Rename buffers with the base filename as the buffer title
(add-hook 'howm-mode-hook 'howm-mode-set-buffer-name)
(add-hook 'after-save-hook 'howm-mode-set-buffer-name))
#+END_SRC

* Custom derived modes
I use those for creating new namespaces for abbrevs or special functions in them
without affecting the respective parent mode.
** Org-English mode
This is a derived mode to hold English abbrevs.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode org-english-mode org-mode "Org-EN"
  "Org-mode used to hold English abbrevs. Does everything that plain org-mode does.")

(add-to-list 'auto-mode-alist '("\\.org\\.en?\\'" . org-english-mode))

;; Disable it for outline-mode derivatives like Markdown and Org.
(add-hook 'org-english-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC
** Livemd mode
This mode was created to offer support for =.livemd= files. These are generated by Livebook.

Livebook uses a special kind of Markdown, but for us there is no change
whatsoever from the usual ~gfm-mode~. It also has special keybindings in the
original implementation to add Elixir, Markdown or Mermaid blocks to the file.
In our case when implementing this in Emacs, we just need a keybinding to add
the Mermaid and Elixir code blocks.

Livebook supports Elixir code as a first class citizen as well as Mermaid diagrams.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode livemd-mode gfm-mode "Livebook"
  "A Markdown-flavored mode for editing Livebook notebook files."
(define-key livemd-mode-map (kbd "C-c e") 'livemd/insert-elixir-block)
(define-key livemd-mode-map (kbd "C-c m") 'livemd/insert-mermaid-block)
(define-key livemd-mode-map (kbd "C-c n") 'markdown-insert-header-atx-2)
(add-to-list 'auto-mode-alist '("\\.livemd?\\'" . livemd-mode))
(add-hook 'livemd-mode-hook #'(lambda () (auto-revert-mode 1)))
(add-hook 'livemd-mode-hook #'(lambda () (auto-save-visited-mode 0))))

(defun livemd/insert-elixir-block (args)
  "Inserts an Elixir code block."
  (interactive "P")
  (markdown-insert-gfm-code-block "elixir" nil))

(defun livemd/insert-mermaid-block (args)
  "Inserts a Mermaid diagram block."
  (interactive "P")
  (markdown-insert-gfm-code-block "mermaid" nil))
#+END_SRC
** Markdown-portuguese mode
An extra namespace for ~markdown-mode~ so I can store abbrevs and ~yasnippet~ snippets in Portuguese for ~markdown-mode~.

I'm leaving this mode to be toggled manually for now.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode markdown-portuguese-mode markdown-mode "Markdown-PT"
  "Markdown-mode used to hold Portuguese abbrevs. Does everything that plain markdown-mode does."
  (setq-local ispell-local-dictionary "pt_BR"))

(add-hook 'markdown-portuguese-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC

** Gfm-portuguese mode
An extra namespace for ~gfm-mode~ so I can store abbrevs and ~yasnippet~ snippets in Portuguese for ~gfm-mode~.

I'm leaving this mode to be toggled manually for now.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode gfm-portuguese-mode gfm-mode "Gfm-PT"
  "Gfm-mode used to hold Portuguese abbrevs. Does everything that plain gfm-mode does."
  (setq-local ispell-local-dictionary "pt_BR"))

(add-hook 'gfm-portuguese-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC

* Variables
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set Fundamental mode as default mode for new buffers:
(setq-default major-mode 'fundamental-mode)
(setq initial-major-mode 'fundamental-mode)

;; When toggling a buffer into read-only mode, activate view-mode immediately.
(setq view-read-only t)

;; Change tab width and change tabs to spaces
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)

;; Making Emacs auto-indent
(define-key global-map (kbd "RET") 'newline-and-indent)

;; Shows trailing whitespace, if any:
(setq-default show-trailing-whitespace t)

(defun css-mode-tweaks()
  (set (make-local-variable 'company-backends) '(company-css company-yasnippet company-etags))
  (emmet-mode 1))

;; Emmet-mode: activate for html-mode, sgml-mode,
;; css-mode, web-mode and sass-mode
(add-hook 'sgml-mode-hook 'emmet-mode)
(add-hook 'sass-mode-hook 'css-mode-tweaks)
(add-hook 'web-mode-hook 'emmet-mode)
(add-hook 'css-mode-hook 'css-mode-tweaks)

;; Python: use python3 as default shell interpreter
(setq python-shell-interpreter "python3")

  #+END_SRC
** Project-local variables
Disable the ~risky-variable~ check. I know what I'm doing.
This can be reverted later with ~(advice-remove)~ though.
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add 'risky-local-variable-p :override #'ignore)
#+END_SRC
* Custom functions
** Calculate leap year
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun is-leap-year (year)
  "Checks if the given YEAR is a leap year"
  (interactive "P")
  (or
   (and (not (eq (% year 100) 0))
    (eq (% year 4) 0))
   (eq (% year 400) 0))
  )

   #+END_SRC
** Unfill region
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Unfill region, AKA leave single huge line
(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
       logical line.  This is useful, e.g., for use with
       `visual-line-mode'."
  (interactive "*r")
  (let ((fill-column (point-max)))
    (fill-region beg end)))
   #+END_SRC
** COMMENT Read value from environment variables
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/get-env-var (env-var-name)
  "This is a way to work around how the system interprets environment variables
to read them in real time. It returns the value under ENV-VAR-NAME in your shell init files.

You just need to change the env var value (or add the key) in .bash_profile and
this function will pick it up."
 (shell-command-to-string (format "$SHELL --login -c 'echo -n $%s'" env-var-name)))
#+END_SRC
** Copy text from prog-modes into Markdown code block
This is useful when you want to copy some lines of code from Emacs to paste on Github comments or in a chat tool. That way you don't have to type `s and paste the text in there. Makes the process much smoother and faster.

#+NAME: auralcat/prog-copy-region-in-named-gfm-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-named-gfm-code-block (beg end)
  "Copy the selected region inside a named GFM code block with the major mode name to the clipboard."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list nil nil)))
  (let ((major-mode-basename (string-replace "-mode" "" (prin1-to-string major-mode)))
        (region-raw-string (buffer-substring-no-properties beg end)))
      (kill-new (format "```%s
%s
```" major-mode-basename region-raw-string))
  (message (format "Region copied to clipboard inside GFM %s code block!" major-mode-basename))))
#+END_SRC

The ~diff~ block is handy when you want to highlight a single line of code when explaining things in GitHub.

#+NAME: auralcat/prog-copy-region-in-diff-md-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-diff-gfm-code-block (beg end)
  "Copy the selected region inside a GFM `diff` code block to the clipboard.

   This is useful to highlight a single line in your message or comment."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list nil nil)))
  (kill-new (format "```%s
%s
```" "diff" (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside GFM `diff` code block!"))
#+END_SRC

We can also create the special ~suggestion~ GFM code block here. This is interpreted by GitHub as a code suggestion that the author of the pull request can incorporate into the branch with a single click. This makes the process of applying suggestions much faster and painless.

#+NAME: auralcat/prog-copy-region-in-suggestion-gfm-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-suggestion-gfm-code-block (beg end)
  "Copy the selected region inside a `suggestion` GFM code block with the major mode name to the clipboard.

  This block is interpreted by GitHub as a suggestion to the pull request, so the author or maintainers can apply the suggestions to the branch with a single click."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list nil nil)))
  (kill-new (format "```%s
%s
```" "suggestion" (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside a `suggestion` GFM code block!"))
#+END_SRC

For other cases where GFM code blocks don't get interpreted correctly, we can use the plain fenced Markdown code block:

#+NAME: auralcat/prog-copy-region-in-plain-md-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-plain-md-code-block (beg end)
  "Copy the selected region inside a plain Markdown code block."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list nil nil)))
  (kill-new (format "```
%s
```"  (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside plain Markdown code block!"))
#+END_SRC

* Work configurations
I prefer to leave the work Elisp configuration files somewhere else because they
contain private/confidential information.

These are usually aliases to commonly-accessed tools and workflows.
#+BEGIN_SRC emacs-lisp :tangle yes
(let ((work-config-file "~/elisp-work/work-config.el")
      (work-config-entrypoint-dir "~/elisp-work"))
  (when (file-exists-p work-config-entrypoint-dir)
    (add-to-list 'load-path work-config-entrypoint-dir)
    ;; Main entrypoint.
    (load work-config-file)))

#+END_SRC
* Mode Line
** VC mode customizations
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add #'vc-git-mode-line-string :filter-return #'my-replace-git-status)
(defun my-replace-git-status (tstr)
  (let* ((tstr (replace-regexp-in-string "Git" "" tstr))
     (first-char (substring tstr 0 1))
     (rest-chars (substring tstr 1)))
    (cond
     ((string= ":" first-char) ;;; Modified
      (replace-regexp-in-string "^:" "⚡️" tstr))
     ((string= "-" first-char) ;; No change
      (replace-regexp-in-string "^-" "✔️" tstr))
     (t tstr))))
#+END_SRC
** Custom code
[[https://github.com/rnkn/olivetti/issues/39#issuecomment-660606677][Source]]
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mode-line-align (left right)
  "Return a string with LEFT and RIGHT at the edges of the
  current window."
  (format (format "%%s %%%ds" (- (window-total-width) (length left) 2))
      left right))

(setq auralcat/mode-line-left-side
      ;; This should be a quoted list if you want values to be updated
      ;; when things change in the buffer.
      '(
    " " evil-mode-line-tag
    " " mode-line-buffer-identification
    " " mode-line-modified
    " " mode-name
    " " mode-line-position
    " " (vc-mode vc-mode)
    ))

(setq auralcat/mode-line-right-side
      (list minor-mode-alist
        " " mode-line-misc-info
        " " mode-line-end-spaces))

;; This needs to be setq-default to make every buffer use this mode line format.
(setq-default mode-line-format
      '("%e" (:eval (mode-line-align
             (format-mode-line
              auralcat/mode-line-left-side)
             (format-mode-line
              auralcat/mode-line-right-side)))))
#+END_SRC
* Cursor
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/get-face-foreground-color (face)
  "Return the hex code from the specified FACE."
  (face-attribute face :foreground))

;; Use basic faces to customize Evil cursors based on theme.
(defun auralcat/set-evil-faces-based-on-current-theme ()
  "Changes the faces for Evil modes based on current theme."
  (let
      ((evil-normal-face-color    (auralcat/get-face-foreground-color  'font-lock-builtin-face))
       (evil-insert-face-color    (auralcat/get-face-foreground-color  'font-lock-string-face))
       (evil-motion-face-color    (auralcat/get-face-foreground-color  'font-lock-keyword-face))
       (evil-replace-face-color   (auralcat/get-face-foreground-color  'font-lock-keyword-face))
       (evil-operator-face-color  (auralcat/get-face-foreground-color  'font-lock-constant-face))
       (evil-visual-face-color    (auralcat/get-face-foreground-color  'font-lock-type-face))
       (zoom-window-color    (auralcat/get-face-foreground-color  'font-lock-string-face)))
    (setq  evil-normal-state-cursor    `(,evil-normal-face-color    box))
    (setq  evil-insert-state-cursor    `(,evil-insert-face-color    bar))
    (setq  evil-motion-state-cursor    `(,evil-motion-face-color    box))
    (setq  evil-replace-state-cursor   `(,evil-replace-face-color   hbar))
    (setq  evil-operator-state-cursor  `(,evil-operator-face-color  box))
    (setq  evil-visual-state-cursor    `(,evil-visual-face-color    box))
    (setq  zoom-window-mode-line-color zoom-window-color)))

(add-hook 'circadian-after-load-theme-hook #'(lambda (theme) (auralcat--set-preferred-fonts-for-current-theme)))
(add-hook 'circadian-after-load-theme-hook #'(lambda (theme) (auralcat/set-evil-faces-based-on-current-theme)))
(add-hook 'after-init-hook #'(lambda () (auralcat--set-preferred-fonts-for-current-theme)))
(add-hook 'after-init-hook #'(lambda () (auralcat/set-evil-faces-based-on-current-theme)))

;; This is to be able to tell when I'm in Emacs state.
(setq evil-emacs-state-cursor '("purple" box))

(setq-default blink-cursor-blinks 0)
(setq-default blink-cursor-interval 0.6)
(setq-default blink-cursor-delay 0.2)
#+END_SRC
** Cursor position
Saves where you were in the last time you edited a given file.
This could be a subtle hint about what you were doing.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq save-place-file "~/.places")
(setq save-place-forget-unreadable-files t)
(save-place-mode 1)
#+END_SRC
* Diary
** Last day of month
   #+BEGIN_SRC emacs-lisp :tangle yes
;; ORG-MODE:
;; * My Task
;;   SCHEDULED: <%%(diary-last-day-of-month date)>
;;; DIARY:  %%(diary-last-day-of-month date) Last Day of the Month
;;; See also:  (setq org-agenda-include-diary t)
;;; (diary-last-day-of-month '(2 28 2017))
(defun diary-last-day-of-month (date)
  "Return `t` if DATE is the last day of the month."
  (let* ((day (calendar-extract-day date))
     (month (calendar-extract-month date))
     (year (calendar-extract-year date))
     (last-day-of-month
      (calendar-last-day-of-month month year)))
    (= day last-day-of-month)))

(defun diary-first-weekday-of-month (date)
  (let* ((day (calendar-extract-day date))
     (month (calendar-extract-month date))
     (year (calendar-extract-year date))
     (first-day-date (list month 1 year))
     (first-absolute-day-weekday (calendar-day-of-week first-day-date)))

    (or
     ;; When the first day is Sunday, it's day 2.
     (and (eq first-absolute-day-weekday 0)
      (eq day 2))

     ;; When the first day is Saturday, it's day 3.
     (and (eq first-absolute-day-weekday 6)
      (eq day 3))

     ;; Else, it's day 1 and a weekday.
     (and (memq (calendar-day-of-week date) '(1 2 3 4 5))
      (eq day 1))
     )
    ))

(defun diary-last-weekday-of-month (date)
  (let* ((day-of-week (calendar-day-of-week date))
     (month (calendar-extract-month date))
     (year (calendar-extract-year date))
     (last-month-day (calendar-last-day-of-month month year))
     (month-day (cadr date)))

    (or
     ;; it's the last day of the month & it is a weekday
     (and (eq month-day last-month-day)
      (memq day-of-week '(1 2 3 4 5)))

     ;; it's a friday, and it's the last-but-one or last-but-two day
     ;; of the month
     (and (eq day-of-week 5)
      (or (eq month-day (1- last-month-day))
          (eq month-day (1- (1- last-month-day))))))))

(defun diary-first-working-day-of-month (date)
  "Returns `t` if DATE is the first working day of the month.
  This is defined as the first weekday of the month which is not a holiday."
  (let* ((day (calendar-extract-day date))
     (month (calendar-extract-month date)))
    (if
    ;; If it's May or Jan, check if day 2 is a weekday.
    (and (or (= month 5) (= month 1)))
    (and (= day 2) (memq (calendar-day-of-week date) '(1 2 3 4 5)))
      ;; Else, check if it's the first weekday of the month.
      (diary-first-weekday-of-month date))))
   #+END_SRC
