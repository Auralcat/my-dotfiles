#+TITLE: Emacs configuration file
#+AUTHOR: Auralcat
#+DATE: 2017:05:17
#+STARTUP: overview

* Personal info
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Load from external file.
(load "~/.emacs.secrets")
  #+END_SRC

* Command history
  It's a good idea to save the previous commands' history, for a couple reasons:
  - Check the complex commands you use most often and improve your workflow
    based on that
  - Store cumbersome commands for specific situations that don't
    appear too often, but where this command saves your back (example
    in Ruby: extracting a variable inside "it" clause to a "let" block)
    #+BEGIN_SRC emacs-lisp :tangle yes
(setq savehist-file "~/file-bouncer/emacs-savehist")
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(setq history-length 10000)
(setq history-delete-duplicates t)
(setq history-length 1024)
(add-hook 'after-init-hook 'savehist-mode)
    #+END_SRC
* Bookmarks
  It's a quicker way to navigate through files you visit often.
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq bookmark-default-file "~/file-bouncer/bookmarks")
;; Every time bookmarks are changed, save them
(setq bookmark-save-flag 1)
  #+END_SRC
* Midnight mode
  Think of this as a kind of cron for Emacs. It runs a list of
  specified commands every "midnight". What constitutes a "midnight"
  can be defined by the user.
  The default action for ~midnight-hook~ is ~clean-buffer-list~
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package midnight
  :defer t
  :init
  (midnight-delay-set 'midnight-delay "10:30am")
  )
  #+END_SRC
* Evil Mode
  Yes, I'm committing this heresy
** Evil-leader
     Add a prefix key to Evil mode, like the Leader key in Vim.
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-leader
  :defer t)
(load "~/my-dotfiles/.emacs.d/elisp-custom/evil-leader-custom-functions.el")
(global-evil-leader-mode)
;; Evil mode needs to be loaded after evil-leader
(use-package evil
:defer t)
(evil-mode 1)

;; Load configs
(load "~/my-dotfiles/.emacs.d/evilrc")
     #+END_SRC
** Evil Surround
     Easier manipulation of delimiters, emulation of vim.surround
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-surround
:defer t)
(global-evil-surround-mode)
     #+END_SRC
** Custom text objects
*** Ruby Block
      Defines a text object for Ruby blocks.
      Credits: [[https://github.com/env0der][@env0der's dotfiles]]
      My modification is just the ~ruby-block-beg-re~ variable.
      #+BEGIN_SRC emacs-lisp :tangle yes
(evil-define-text-object evil-textobj-outer-ruby-block
  (count &optional beg end type)
  (evil-ruby-block-range beg end type count t))

(evil-define-text-object evil-textobj-inner-ruby-block
  (count &optional beg end type)
  (evil-ruby-block-range beg end type count nil))

(defun evil-ruby-block-range (count beg end type &optional inclusive)
  (let ((current-point (point))
        (block-begin (progn (evil-end-of-line) (re-search-backward ruby-block-beg-re nil t)))
        (block-end (progn (evilmi-jump-items) (point))))
    (if inclusive
        (let ((begin (progn (goto-char block-begin) (evil-beginning-of-line) (point)))
              (end (progn (goto-char block-end) (evil-next-line) (evil-beginning-of-line) (if (looking-at "^$") (+ (point) 1) (point)))))
          (progn
            (goto-char current-point)
            (evil-range begin end)))
      (let ((begin (progn (goto-char block-begin) (evil-next-line) (evil-first-non-blank) (point)))
            (end (progn (goto-char block-end) (evil-previous-line) (evil-end-of-line) (+ (point) 1))))
        (progn
          (goto-char current-point)
          (evil-range begin end))))))

(define-key evil-inner-text-objects-map "r" 'evil-textobj-inner-ruby-block)
(define-key evil-outer-text-objects-map "r" 'evil-textobj-outer-ruby-block)
      #+END_SRC
* Terminal configurations
I want my term to work like the shell-mode because I need to copy
stuff from there and see Docker output correctly.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package term
  :bind (:map term-raw-map
              ("M-x" . 'execute-extended-command)
              ("M-v" . 'scroll-down-command)
              ("C-v" . 'scroll-up-command)
              ("M-o" . 'other-window)
              ("C-M-o" . 'other-frame)
              ("M-2" . 'ido-switch-buffer)
              ("M-w" . 'auralcat/term-copy-last-command)
              ("M-4" . 'ido-switch-buffer-other-window))

  :config
  ;; Work PS1
  (cond
   ((and (string-equal system-name auralcat/work-system-name) (eq system-type 'gnu/linux))
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] \n*"))
   ;; Personal PS1
   ((and (string-equal system-name auralcat/personal-system-name) (eq system-type 'gnu/linux))
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")))

  (add-hook 'term-mode-hook #'(lambda ()
                                (set (make-local-variable 'company-backends) '(company-capf company-files))))

  (evil-set-initial-state 'term-mode 'emacs)
  (evil-set-initial-state 'ansi-term-mode 'emacs))

;; This is a macro to copy the last command's input to the kill-ring in term-mode.
;; Should also work in ansi-term.
(fset 'auralcat/term-copy-last-command
      (kmacro-lambda-form [?\C-c ?\C-j ?\C-2 ?\C-p ?\C-e ?\C-  ?\C-c ?\C-p ?\C-a ?\M-w ?\M-> ?\C-c ?\C-k] 0 "%d"))
#+END_SRC
* Xref
This is quite useful to navigate through code faster.
#+BEGIN_SRC emacs-lisp :tangle yes
(evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
#+END_SRC
* Occur
Occur is useful for when you want to keep a list of code points of interest in a
given buffer or a set of buffers with ~multi-occur-in-matching-buffers~. I was
used to doing this multi search through ~ibuffer~, but you can call this function
from ~M-x~ and get the same result if you want.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'occur-hook 'occur-rename-buffer)
#+END_SRC
* Dired
  A couple customizations.
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq dired-listing-switches "-alh")
;; Use Emacs mode in Dired.
(add-hook 'dired-mode-hook 'evil-emacs-state)
  #+END_SRC

* Macros
  #+BEGIN_SRC emacs-lisp :tangle yes
;; To save a macro, record it with C-x ( (start) and C-x ) (stop),
;; give it a name with C-x C-k n (C-k is for maKro) and
;; insert it in this file with insert-kbd-macro.
;; Then you execute it mapping it to a key!

;; This package allows you to override a couple functions.
(use-package noflet
:defer t)
(lambda (&optional arg) "Extracts a variable from an it clause and puts in a let statement." (interactive "p") (kmacro-exec-ring-item (quote ([100 100 134217745 134217729 112 99 87 108 101 116 40 58 25 escape 102 61 50 120 67 123 25 escape 86 61 15 15 48 119] 0 "%d")) arg))

;; Adds a byebug line to Ruby code
(fset 'auralcat/ruby/add-byebug-line
      (kmacro-lambda-form [?O ?b ?y ?e ?b ?u ?g escape return] 0 "%d"))

(fset 'auralcat/ruby-clone-method
      (lambda (&optional arg) "Clones a def method in Ruby." (interactive "p") (kmacro-exec-ring-item (quote ([86 125 121 103 118 escape 112] 0 "%d")) arg)))

(fset 'auralcat/search-git-conflict-string
      (lambda (&optional arg) "Searches for a Git conflict string." (interactive "p") (kmacro-exec-ring-item (quote ([134217747 94 91 60 61 62 93 13] 0 "%d")) argumento)))

(fset (quote sample-macro)
      (lambda (&optional arg) "Sample description" (interactive "p")
        (undo-boundary)
        (noflet ((undo-boundary ()))
          (kmacro-exec-ring-item (quote ([100 87 65 32 35 32 65 110 111 116 104 101 114 32 109 97 99 114 111 32 99 97 108 108 46 escape 134217730 return 112 45] 0 "%d")) arg)
          )
        (undo-boundary)
        ))

;; Some macros to adjust Ruby blocks
(fset 'auralcat/ruby-move-defun-backward
      (lambda (&optional arg) "Moves a DEF block backwards in the class definition." (interactive "p")
        (undo-boundary)
        (noflet ((undo-boundary ()))
          (kmacro-exec-ring-item (quote ([26 167772166 23 134217820 16 4 134217820 4 2 134217730 16 return 25 return 134217730 26] 0 "%d")) arg)
          )
        (undo-boundary)
        ))

(fset 'auralcat/ruby-move-block-forward
      (lambda (&optional arg) "Moves a Ruby block forward in the current nesting level." (interactive "p")
        (undo-boundary)
        (noflet ((undo-boundary ()))
          (kmacro-lambda-form [?\C-z ?\C-  ?\C-\M-n ?\C-e ?\C-w ?\C-\M-n ?\C-m ?\C-/ ?\C-e ?\C-m ?\C-m ?\C-y ?\C-u ?\C-  ?\C-  ?\C-k ?\C-k ?\C-i ?\C-z] 0 "%d")
          )
        (undo-boundary)
        )
      )

;; Removes a Ruby block wrapping another block.
(fset 'auralcat/ruby-block-vanish
      (kmacro-lambda-form [?m ?m ?% ?d ?d ?\' ?m ?d ?d ?\C-x ?\C-x ?=] 0 "%d"))

;; Remove links in an Org entry
(fset 'auralcat/org-remove-link
      (kmacro-lambda-form [?d ?s ?\] ?d ?f ?\] ?d ?s ?\]] 0 "%d"))

;; Copy the link at point in Org mode buffers
(fset 'org-copy-link-at-point
   (kmacro-lambda-form [?\C-c ?\C-l ?\C-  ?\C-a ?\M-w return return] 0 "%d"))
  #+END_SRC

** Elixir
#+BEGIN_SRC emacs-lisp :tangle yes
;; Changes a one-line function like:
;; def something(foo), do: "yay!"
;;
;; to:
;;
;; def something(foo) do
;;   "yay!"
;; end
(fset 'auralcat/elixir-change-one-line-function-to-multiline
      (kmacro-lambda-form [?f ?: ?F ?, ?x ?E ?x ?i return escape ?o ?e ?n ?d return escape ?\M-a return] 0 "%d"))

;; Calls IEx.pry in the line above the cursor.
(fset 'auralcat/elixir-iex-pry
      (kmacro-lambda-form [?O ?r ?e ?q ?u ?i ?r ?e ?  ?I ?E ?x ?\; ?  ?I ?E ?x ?. ?p ?r ?y escape] 0 "%d"))
#+END_SRC

* Mac OS
  #+BEGIN_SRC emacs-lisp :tangle yes
(when (eq system-type 'darwin) ;; mac specific settings
  ;; Use bigger fonts because of that Retina display
  (if (member "Fantasque Sans Mono" (font-family-list))
      (set-face-attribute (quote default) nil :font "Fantasque Sans Mono" :height 140)
    (set-face-attribute (quote default) nil :font "Monaco" :height 120))
  ;; Map Command to Meta
  (setq mac-command-modifier 'meta)
  ;; Map Option to Control (I know, smaller key, that's what we have for now. :/)
  (setq mac-option-modifier 'control)
  ;; Map Control key in OS X to Super
  (setq mac-control-modifier 'super)
  ;; Map Fn key in OS X to Hyper
  (setq ns-function-modifier 'hyper)
  ;; Point the executables in Mac OS to Emacs.
  (add-to-list 'exec-path "/usr/local/bin/")
  ;; Enable EPA
  (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))

  ;; Use Emacsclient in OS X
  (setq server-socket-dir (format "/tmp/emacs%d" (user-uid))))
  #+END_SRC
* Environment Customizations
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Make startup faster by reducing the frequency of garbage
;; collection.  The default is 0.8MB.  Measured in bytes.
(setq gc-cons-threshold (* 50 1000 1000))
;; Portion of heap used for allocation.  Defaults to 0.1.
(setq gc-cons-percentage 0.6)

;; Sentences end with single spaces for me.
(setq sentence-end-double-space nil)

;; Set locale to Brazilian Portuguese
(set-locale-environment "pt_BR.UTF-8")

;; Change window title
(setq frame-title-format (format "%s %s" (nth 1 (split-string (emacs-version)))
                                   (nth 2 (split-string (emacs-version)))))

;; Add frame margins. This makes things more pleasant to read.
(setq default-frame-alist '((internal-border-width . 20)))

;; A small performance improvement
(setq redisplay-dont-pause t)

;; Since I work only with left-to-right languages, we can set it like this.
(setq bidi-paragraph-direction 'left-to-right)
(if (version<= "27.1" emacs-version)
    (setq bidi-inhibit-bpa t))

;; I don't like lockfiles
(setq create-lockfiles nil)

;; Starts the Emacs server for emacsclient.
(server-start)

;; Store all backups in a specific folder:
(setq backup-directory-alist `(("." . "~/file-bouncer/emacs-backups")))

;; Manual packages load path
(add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-themes/")
(add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-packages/")

;; Manual Elisp scripts load path
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/elisp-custom")

;; Backup files by copying them
(setq backup-by-copying t)

;; I'm too lazy to type "yes" or "no"
(fset 'yes-or-no-p 'y-or-n-p)

;; Clean whitespace before saving a file
(add-hook 'before-save-hook 'whitespace-cleanup)

;; While you're at it, save automatically when visiting files.
;; It's surprisingly useful. The only caveat is when you got an
;; open comment like this. It will remove all the whitespace.
;; It saves the file after 5 seconds of inactivity.
(auto-save-visited-mode t)

;; Allow only one theme at a time
(setq custom-theme-allow-multiple-selections nil)

;; Enable ido-mode (fewer keystrokes to switch buffers!)
(ido-mode 1)
(ido-everywhere 1)
(icomplete-mode 1)
(icomplete-vertical-mode 1)

;; Easier mark cycling, both local and global
(setq set-mark-command-repeat-pop t)

;; Replace the built-in buffer menu with ibuffer
(global-set-key [24 2] (quote ibuffer))

;; Prevent the scratch buffer from being killed
(with-current-buffer "*scratch*"
  (emacs-lock-mode 'kill))

;; Enable auto-revert-mode
(global-auto-revert-mode t)

;; Remove the menu bar in terminal mode
(when (not (display-graphic-p))
  (menu-bar-mode -1))

;; Use Bash as default shell interpreter
(setq org-babel-sh-command "/bin/bash")
;; Get Emacs to understand your aliases
;; (setq shell-file-name "bash")
;; For reference, this is the default value:
;; (setq shell-command-switch "-c")
;; (setq shell-command-switch "-ic")

;; Activate Company mode
(add-hook 'after-init-hook 'global-company-mode)

;; Enable global Abbrev mode
(setq-default abbrev-mode t)

;; Save last edited place in files
(require 'saveplace)
(setq-default save-place t)

;; I need a bigger kill ring.
(setq kill-ring-max 180)

;; Use recentf-mode
(recentf-mode)
(setq recentf-max-menu-items 100)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
  #+END_SRC
* REPL
We need to do some customizations to comint-related buffers to improve performance.
#+BEGIN_SRC emacs-lisp :tangle yes
;; I prefer Emacs state in comint-related buffers.
(evil-set-initial-state 'comint-mode 'emacs)

(defun comint-mode-tweaks ()
  ;; Font-lock is the one that takes the biggest toll on performance.
  (font-lock-mode -1)
  (auto-composition-mode -1)
  (auto-compression-mode -1)
  (column-number-mode -1)
  (auto-save-visited-mode -1)
  )

(add-hook 'comint-mode-hook 'comint-mode-tweaks)
#+END_SRC

* Abbreviations
  #+BEGIN_SRC emacs-lisp :tangle yes
(setq abbrev-file-name "~/.abbrev_defs")
  #+END_SRC
* Hooks
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Prog-mode is from where all the programming modes are derived from.
;; This means that if you call prog-mode-hook, the settings will be
;; applied to ALL programming modes in Emacs.

(defun prog-mode-tweaks ()
  ;; Set line number mode and column number mode for code files
  (if (< (string-to-number emacs-version) 24)
      (line-number-mode 1)
    (display-line-numbers-mode))
  (setq fill-column 80)
  )
(add-hook 'prog-mode-hook 'prog-mode-tweaks)
(add-hook 'text-mode-hook 'column-number-mode)

;; Create filling for org-mode
(add-hook 'org-mode-hook 'auto-fill-mode)
  #+END_SRC
* Packages
** Major Modes
*** Markdown-mode
  A couple tweaks to make it more Org-like.
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun markdown-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1)
  )

(use-package markdown-mode
  :hook ((markdown-mode . markdown-mode-tweaks)
         (gfm-mode . markdown-mode-tweaks))
  :bind
  ("M-<right>" . 'markdown-demote)
  ("M-<left>" . 'markdown-promote)
  ("M-<up>" . 'markdown-move-up)
  ("M-<down>" . 'markdown-move-down)
  ("C-c 1" . 'markdown-insert-header-atx-1)
  ("C-c 2" . 'markdown-insert-header-atx-2)
  ("C-c 3" . 'markdown-insert-header-atx-3)
  :config
  (setq markdown-asymmetric-header t))
  #+END_SRC

*** Web-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun web-mode-keybindings ()
  "Define mode-specific keybindings like this."
  (local-set-key (kbd "C-c C-v") 'browse-url-of-buffer)
  (local-set-key (kbd "C-c /") 'sgml-close-tag))

;; Add company backends when loading web-mode.
(defun web-mode-company-load-backends ()
  (company-web-bootstrap+)
  (company-web-fa+))

(add-hook 'web-mode-hook 'web-mode-keybindings)
(add-hook 'web-mode-hook 'web-mode-company-load-backends)

;; Use tidy to check HTML buffers with web-mode.
(eval-after-load 'flycheck
  '(flycheck-add-mode 'html-tidy 'web-mode))
  #+END_SRC
*** Compilation mode tweaks
This is a built-in mode, but I want to change some stuff there.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun compilation-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1))

(add-hook 'compilation-mode-hook 'compilation-mode-tweaks)
;; Use Emacs keys and bindings in compilation-mode and its derived modes.
(add-hook 'compilation-mode-hook 'evil-emacs-state)
(add-hook 'compilation-start-hook 'evil-emacs-state)
#+END_SRC
*** Elixir-mode
    Elixir support for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package elixir-mode
  :defer t
  :config
  (define-key elixir-mode-map (kbd "C-c C-l") 'inf-elixir-send-line)
  (define-key elixir-mode-map (kbd "C-c C-r") 'inf-elixir-send-region))
    #+END_SRC
*** Sass-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package sass-mode
  :defer t
  ;; Set Sass mode for SASS files and Css mode for SCSS files.
  :init
  (add-to-list 'auto-mode-alist
               '("\\.sass\\'" . sass-mode)))

    #+END_SRC
*** SCSS-mode
    Major mode for SCSS files, together with Sass.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package scss-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist
               '("\\.scss\\'" . scss-mode)))
    #+END_SRC
*** Nov-mode
This is a mode for reading .epub files.
It's quite comfortable when you want to read longform books in the computer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  ;; Set the width to 80 chars, this is better to read.
  (setq nov-text-width 80)
  ;; Remove the mode line in the book's buffer.
  (add-hook 'nov-mode-hook #'(lambda () (setq-local mode-line-format nil))))
#+END_SRC
*** Makefile-mode
I'm working with Makefiles now, so this is useful.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'makefile-mode-hook #'(lambda () (setq-local indent-tabs-mode t)))
#+END_SRC
*** Js2-mode
    A better default Javascript mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package js2-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.js?\\'" . js2-mode))
  (setq js-indent-level 2))

;; TODO: Look for a better completion for JS modes in Company.
(defun js2-mode-tweaks ()
  ;; Use company-yas as main backend
  (set (make-local-variable 'company-backends) '(company-etags company-yasnippet))
  (company-mode t))

(add-hook 'js2-mode-hook 'js2-mode-tweaks)

;; Set syntax highlight level
(setq js2-highlight-level 3)
    #+END_SRC

*** PHP-mode
    PHP support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package php-mode
  :defer t
  :config
  (add-hook 'php-mode-hook (lambda() (add-to-list 'company-backends 'company-php))))
    #+END_SRC
*** Enhanced-ruby-mode
    A better ruby-mode.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package enh-ruby-mode
  :defer t)

;; No magic comments, please.
(setq enh-ruby-add-encoding-comment-on-save nil)
(setq ruby-insert-encoding-magic-comment nil)

;; ;; Set it as default mode for Ruby files
;; (add-to-list 'auto-mode-alist
;; '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
;; . enh-ruby-mode))

;; Fallback to vanilla Ruby mode when things go bad
(add-to-list 'auto-mode-alist
             '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
               . ruby-mode))

;; (define-key enh-ruby-mode-map (kbd "M-<down>") 'auralcat/ruby-move-defun-forward)
;; (define-key enh-ruby-mode-map (kbd "M-<up>") 'auralcat/ruby-move-defun-backward)

;; (define-key ruby-mode-map (kbd "M-<down>") 'auralcat/ruby-move-defun-forward)
;; (define-key ruby-mode-map (kbd "M-<up>") 'auralcat/ruby-move-defun-backward)
    #+END_SRC
*** Web Mode
    I use this for HTML files mostly, works good for PHP too.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode
  :ensure t
  :defer t
  :bind (:map web-mode-map
              ("C-<up>"    . web-mode-element-previous)
              ("C-<down>"  . web-mode-element-next)
              ("C-<left>"  . web-mode-element-beginning)
              ("C-<right>" . web-mode-tag-match)
              ("C-S-<up>"  . web-mode-element-parent)
              ("M-<up>"    . web-mode-element-content-select)
              ("C-k"       . web-mode-element-kill)
              ("M-RET"     . complete))

  :init
  ;; File associations
  (add-to-list 'auto-mode-alist '("\\.phtml\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html.erb\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html.eex\\'"    . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.vue?\\'"   . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx?\\'"  . web-mode))

  ;; Engine associations
  (setq web-mode-engines-alist
        '(("php"    . "\\.phtml\\'")
          ("blade"  . "\\.blade\\.")))

  ;; Highlight tag when editing
  (setq web-mode-enable-current-element-highlight t))

    #+END_SRC
*** YAML-mode
    YAML support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t
  :defer t)
    #+END_SRC
*** CSV-mode
    CSV support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package csv-mode
  :defer t)
    #+END_SRC
*** APIB-mode
Necessary for parsing apib files (API Blueprint)
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package apib-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.apib?\\'"   . apib-mode)))
#+END_SRC
*** Typescript mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package typescript-mode
  :defer t)
#+END_SRC

** Minor Modes
*** JS-comint
    Open a REPL using Node.js in another buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package js-comint
:defer t)

;; Call the REPL with C-c C-s in js2-mode
;; (define-key js2-mode-map (kbd "C-c C-s") 'run-js)

;; Send last JS expression to REPL
;; (define-key js2-mode-map (kbd "C-x C-e") 'js-send-last-sexp)
    #+END_SRC
*** Flycheck Inline
    Shows the error when leaving the point over the place where it occurs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-inline
  :defer t
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
    #+END_SRC
*** Ruby-electric
    Auto-close do-end blocks, as well as braces and parens.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ruby-electric
  :defer t
  :diminish ruby-electric-mode
  :config
  (add-hook 'enh-ruby-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )
  (add-hook 'ruby-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )
  (add-hook 'enh-ruby-mode-hook 'ruby-electric-mode)
  (add-hook 'ruby-mode-hook 'ruby-electric-mode))
    #+END_SRC
*** Inf-elixir
Utility around Elixir's REPL in Emacs.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package inf-elixir
  :after (elixir-mode)
  :ensure t
  :defer t
  :init
  ;; Bindings for inf-elixir-mode
  (define-key elixir-mode-map (kbd "C-c C-l") 'inf-elixir-send-line)
  (define-key elixir-mode-map (kbd "C-c C-r") 'inf-elixir-send-region))
#+END_SRC
*** Mix
A wrapper around Elixir's ~mix~ for Emacs
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mix
  ;; I prefer creating a prefix for these commands because it's 2 key presses
  ;; instead of 3 with evil-leader.
  :config
  (define-prefix-command 'elixir-mix-map)
            (define-key 'elixir-mix-map "t" 'mix-test)
            (define-key 'elixir-mix-map (kbd "SPC") 'mix-test-current-buffer)
            (define-key 'elixir-mix-map "." 'mix-test-current-test)
            (define-key 'elixir-mix-map "f" 'auralcat/elixir-run-mix-format-in-project-root)
            (define-key 'elixir-mix-map "c" 'mix-compile)
            (define-key 'elixir-mix-map "x" 'mix-execute-task)
            (define-key 'elixir-mix-map (kbd "C-,") 'mix-last-command))

  (add-hook 'elixir-mode-hook '(lambda ()
                                 (local-set-key (kbd "C-,") 'elixir-mix-map)))

(defun auralcat/elixir-run-mix-format-in-project-root (arg)
  "Runs `mix format` ín the project's root directory."
  (interactive "P")
  (if arg
      (projectile-run-shell-command-in-root "mix format --check-formatted")
    (projectile-run-shell-command-in-root "mix format")))
#+END_SRC

*** Projectile
    Manage projects in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :defer t
  :init
  (setq projectile-keymap-prefix (kbd "C-c p"))
  ;; I use Universal ctags, so this needs some adjustment.
  (setq projectile-tags-command "ctags -eR ."))

;; Enable it
(add-hook 'after-init-hook #'projectile-global-mode)
    #+END_SRC
*** Autopair
    Automatically pair braces and quotes like in TextMate
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package autopair
  :after (prog-mode)
  :defer t
  :init (autopair-global-mode))
    #+END_SRC
*** Emmet-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package emmet-mode
  :after (:any web-mode sass-mode scss-mode)
  :defer t)
    #+END_SRC
*** Highlight-numbers mode
    Sets font lock faces to numbers in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-numbers
  :after (prog-mode)
  :defer t
  :config
  (add-hook 'prog-mode-hook 'highlight-numbers-mode))
    #+END_SRC
*** Flyspell
    Used to check prose.
    I use Markdown to write stuff in English.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flyspell
  :defer t
  :config
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'flyspell-mode)

  (add-hook 'git-commit-mode-hook 'flyspell-mode))
    #+END_SRC

*** Flycheck
    Syntax checker, replaces flymake
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :defer t
  :config
  ;; turn on flychecking globally
  (add-hook 'after-init-hook #'global-flycheck-mode))
;; Disable rubylint on default for Ruby modes.
;; If you need it, you can enable it locally using C-u C-c ! v.
(defun custom-disabled-ruby-checkers ()
  (add-to-list 'flycheck-disabled-checkers 'ruby-rubylint))
(add-hook 'enh-ruby-mode-hook 'custom-disabled-ruby-checkers)
(add-hook 'ruby-mode-hook 'custom-disabled-ruby-checkers)
    #+END_SRC

*** Company
**** Main Config
     *COMPlete ANYthing* inside Emacs.
     I switched to it because it works in GUI Emacs and ~auto-complete~ didn't at the time.
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :defer t
  :config
  ;; My standard Company configuration
  (setq company-tooltip-limit 20)
  (setq company-show-numbers t)
  (setq company-idle-delay 0)
  (setq company-echo-delay 0))

;; Web-mode needs HTML and CSS completions.
;; JS is not satisfactory at this point IMO
(defun web-mode-tweaks ()
  (require 'company-web-html)
  (set (make-local-variable 'company-backends) '(company-web-html company-css))
  (emmet-mode 1)
  (company-mode t))

;; Completion for Ruby mode
(defun ruby-mode-tweaks ()
  ;; Increase the min prefix length so it doesn't clash with most used keywords, like def.
  (set (make-local-variable 'company-minimum-prefix-length) 4)
  (set (make-local-variable 'company-backends) '(company-etags company-capf company-dabbrev company-yasnippet))
  (subword-mode 1))

;; Completion for REPL Ruby mode
(defun inf-ruby-mode-tweaks ()
  (set (make-local-variable 'company-minimum-prefix-length) 2)
  (set (make-local-variable 'company-backends) '(company-capf company-etags company-dabbrev company-yasnippet))
  (subword-mode 1))

;; General text writing completion (uses dabbrev and filename completion)
(defun human-language-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-dabbrev company-capf company-files))
  ;; If you write a word with 3 letters, it's better to use 'complete, I think.
  ;; Company-mode is meant for longer words and those with hard spelling IMO.
  (set (make-local-variable 'company-minimum-prefix-length) 4)
  (setq fill-column 80))

;; Shell completion
(defun shell-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-capf company-files)))

;; Elisp completion
(defun elisp-tweaks ()
  (set (make-local-variable 'company-minimum-prefix-length) 5)
  (set (make-local-variable 'company-backends) '(company-elisp company-etags company-yasnippet)))

;; Add tweaks
(add-hook 'enh-ruby-mode-hook 'ruby-mode-tweaks)
(add-hook 'inf-ruby-mode-hook 'inf-ruby-mode-tweaks)
(add-hook 'ruby-mode-hook 'ruby-mode-tweaks)
(add-hook 'elixir-mode-hook 'ruby-mode-tweaks)
(add-hook 'shell-mode-hook 'shell-mode-tweaks)
(add-hook 'emacs-lisp-mode-hook 'elisp-tweaks)
(add-hook 'ielm-mode-hook 'elisp-tweaks)

;; Human language writing hooks
(add-hook 'org-mode-hook 'human-language-mode-tweaks)
(add-hook 'markdown-mode-hook 'human-language-mode-tweaks)

(add-hook 'org-mode-hook 'variable-pitch-mode)
(add-hook 'markdown-mode-hook 'variable-pitch-mode)
(add-hook 'git-commit-setup-hook 'variable-pitch-mode)

;; Apib mode should come with its own customizations:
;; - Monospace fonts
;; - No auto-fill
;; - Line numbers on the side
(add-hook 'apib-mode-hook #'(lambda ()
                              (variable-pitch-mode 0)
                              (auto-fill-mode 0)
                              (display-line-numbers-mode 0)))

;; Web-mode completions
(use-package company-web
  :after (:all company-mode web-mode)
  :defer t)

;; Company statistics package
(use-package company-statistics
  :after (company-mode)
  :defer t
  :config
(company-statistics-mode))

;; Company with prescient.el offers better sorting of completion candidates.
;; I don't know if it clashes with company-statistics.
(use-package company-prescient
  :after (company-mode)
  :defer t
  :config
  (company-prescient-mode))
     #+END_SRC
*** Keyfreq
    Shows most used commands in editing session.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package keyfreq
  :config
  ;; Ignore arrow commands and self-insert-commands
  (setq keyfreq-excluded-commands
        '(self-insert-command
          org-self-insert-command
          weechat-self-insert-command
          isearch-printing-char
          vterm--self-insert
          abort-recursive-edit
          company-ignore
          ))

  ;; Activate it
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
    #+END_SRC
*** Diminish
    Free some space in the mode line removing superfluous mode indications.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  :ensure t
  :defer t
  ;; These are loaded at startup, I prefer declaring everything here.
  :diminish flycheck-mode
  :diminish projectile-mode
  :diminish company-mode
  :diminish auto-revert-mode
  :diminish auto-fill-mode
  :diminish abbrev-mode
  :diminish autopair-mode)
;; These are loaded in other moments
(eval-after-load "editorconfig" '(diminish 'editorconfig-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
    #+END_SRC
*** Editorconfig
    Helps developers define and maintain consistent coding styles
    between different editors and IDEs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :after (prog-mode)
  :ensure t
  :defer t
  :config
  (editorconfig-mode 1))
    #+END_SRC
*** Nyan-mode
      Put a Nyan Cat in your mode line! :3
      #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nyan-mode
    :init
    ;; This is to avoid trouble with mode line displays.
    ;; Nyan-mode changes the mode-line-position variable, where the line
    ;; number and column numbers are displayed.
    (add-hook 'nyan-mode-hook 'line-number-mode)
    (add-hook 'nyan-mode-hook 'column-number-mode)
    :config
    (nyan-mode 1))
      #+END_SRC
*** Mode Icons
    Indicate modes in the mode line using icons
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package mode-icons
  :init
  (mode-icons-mode))
    #+END_SRC
*** Emojify
      Add emoji support for Emacs
      #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package emojify
    :hook (after-init . global-emojify-mode))
      #+END_SRC
** Utilities
*** Ace Jump
Allows you to move anywhere in the visible portion of the buffer (or any
frame you got in your screens) using at least 3 keystrokes.

This is pretty useful for when you want to jump to a different section in
another window or even a frame.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-jump-mode
  :after (evil)
  :bind
  ("C-c SPC" . ace-jump-mode)
  ("M-3" . ace-jump-mode)
  (:map org-mode-map
        ("C-c SPC" . ace-jump-mode))
  :config
  ;; Save the position of the previous mark as a jump position for Evil.
  ;; With that, we can cycle through where ace-jump was called from using C-i and C-o.
  (defadvice ace-jump-mode (before ace-jump-mode-advice)
    (evil--jumps-push))
  (ad-activate 'ace-jump-mode))
#+END_SRC
*** Zoom window
Zooms a window just like in Tmux.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package zoom-window)
#+END_SRC
*** Notmuch
Read mail inside Emacs!
This is great for opensource projects and work.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package notmuch
  :defer t
  :config
  (defun my-notmuch-show-view-as-patch ()
    "View the the current message as a patch."
    (interactive)
    (let* ((id (notmuch-show-get-message-id))
           (msg (notmuch-show-get-message-properties))
           (part (notmuch-show-get-part-properties))
           (subject (concat "Subject: " (notmuch-show-get-subject) "\n"))
           (diff-default-read-only t)
           (buf (get-buffer-create (concat "*notmuch-patch-" id "*")))
           (map (make-sparse-keymap)))
      (define-key map "q" 'notmuch-bury-or-kill-this-buffer)
      (switch-to-buffer buf)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert subject)
        (insert (notmuch-get-bodypart-text msg part nil)))
      (set-buffer-modified-p nil)
      (diff-mode)
      (lexical-let ((new-ro-bind (cons 'buffer-read-only map)))
        (add-to-list 'minor-mode-overriding-map-alist new-ro-bind))
      (goto-char (point-min))))
  (define-key 'notmuch-show-part-map "d" 'my-notmuch-show-view-as-patch))
#+END_SRC
*** Vterm
It is a full-fledged terminal emulator inside Emacs. It uses ~libvterm~, which
is a C library, so it maintains compatibility between all CLI applications, and
you can use them without problems from inside Emacs.

The advantage over using ~term-mode~ or ~shell-mode~ are:
- No need to put additional configuration in Emacs to get the terminal to show colors.
  It also respects the PS1 configuration in your ~.bashrc~.
- Easier to toggle a mode to copy information from the terminal to other buffers.
  Although ~vterm-copy-mode~ takes some time getting used to.

The drawbacks are:
- Currently the side of the terminal output gets cut if you switch to other
  windows with ~golden-ratio-mode~
- Needs to bind new keybindings to get commands that are by default in
  ~shell-mode~ or ~term-mode~ with ~line-mode~.
- To search the terminal buffer with =C-s=, you'll need to enter ~vterm-copy-mode~.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun vterm-mode-tweaks ()
  (set (make-local-variable 'company-backends) '(company-capf company-files))
  (setq-local show-trailing-whitespace nil)
  ;; I don't like having the mode line in the terminals.
  (setq-local show-trailing-whitespace nil)
  (setq-local mode-line-format nil)
  ;; Disable emojify mode for the terminal
  (emojify-mode -1)
  (evil-set-initial-state 'vterm-mode' emacs))

(use-package vterm
  :hook ((vterm-mode) . 'vterm-mode-tweaks)
  :bind (:map vterm-mode-map
              ("C-M-o" . 'other-frame)
              ("M-w" . 'auralcat/vterm-copy-last-command-output)
              ("M-p" . 'vterm-send-up)
              ("M-r" . 'vterm-send-C-r)
              ("M-n" . 'vterm-send-down))
  :config
  (setq vterm-use-vterm-prompt-detection-method t))

;; Macro to copy vterm's last command output.
(fset 'auralcat/vterm-copy-last-command-output
      (kmacro-lambda-form [?\C-c ?\C-t ?\C-c ?\C-p ?\C-a ?\C-  ?\C-c ?\C-n ?\C-p ?\M-b ?\C-e return] 0 "%d"))
#+END_SRC
*** Exec path from shell
  Replicates terminal env vars in graphical Emacs.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :defer t
  :init
  (exec-path-from-shell-initialize))
  #+END_SRC
*** Git-Link
Create links to Github/GitLab files from the comfort of your Emacs buffer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-link
  :defer t)
#+END_SRC
*** Magit delta
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-delta
  :ensure t
  :hook (magit-mode . magit-delta-mode))
#+END_SRC
*** Smartparens
This works better than Autopair for Elixir mode.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :after (elixir-mode)
  :init
  ;; Do not activate autopair for Elixir-related modes if we're using smartparens.
  (add-hook 'elixir-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )
  (add-hook 'inf-elixir-mode-hook
            #'(lambda ()
                (setq autopair-dont-activate t) ;; for emacsen < 24
                (autopair-mode -1))             ;; for emacsen >= 24
            )

  (add-hook 'elixir-mode-hook #'smartparens-mode)
  (add-hook 'inf-elixir-iex-mode-hook #'smartparens-mode)
  :config
  (require 'smartparens-config))
#+END_SRC

*** Prettier.js
    Prettier.js integration for Emacs.
    I want to run this thing when saving .js and web-related files.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package prettier-js
  :after (:any js2-mode sass-mode css-mode scss-mode)
  :hook ((js2-mode sass-mode scss-mode css-mode) . 'prettier-js-mode)
  :config
  (setq prettier-js-allowed-modes '(js2-mode sass-mode css-mode scss-mode))

  (defun toggle-prettier-js-save-hook ()
    "Toggles Prettier.js hook when you're working with a mode that supports it. Removes the hook otherwise."
    (if (member major-mode prettier-js-allowed-modes)
        (add-hook 'before-save-hook 'prettier-js)
      (remove-hook 'before-save-hook 'prettier-js)))
  (add-hook 'change-major-mode-hook 'toggle-prettier-js-save-hook))
    #+END_SRC
*** Yafolding
    Code folding in Emacs.
    Takes some configuration to use it with evil, but works fine for Elixir buffers.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yafolding
  :hook (prog-mode . yafolding-mode)
  :defer t
  :bind (:map evil-normal-state-map
              ("zo" . 'yafolding-show-element)
              ("zc" . 'yafolding-hide-element)
              ("za" . 'yafolding-toggle-element)
              ("zA" . 'yafolding-toggle-all)
              ("zr" . 'yafolding-show-all)
              ("zm" . 'yafolding-hide-all)
              ))
    #+END_SRC
*** Olivetti
This is great to concentrate on text when you want to write prose.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package olivetti
  :config
  (setq olivetti-style 'fancy
        olivetti-body-width 80))
#+END_SRC
*** Golden Ratio Mode
    Splits windows using the [[https://en.wikipedia.org/wiki/Golden_ratio][Golden Ratio]].
    This makes the focused window a bit larger than usual and the
    smaller ones are easier to read. It makes the multi-window
    experience more pleasing to the eye. Yeah, nature!
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package golden-ratio
  ;; Play nice with ace-jump.
  :hook ((ace-jump-mode-end) . 'golden-ratio)
  :diminish golden-ratio-mode
  :config
  (setq golden-ratio-extra-commands
        (append golden-ratio-extra-commands '(magit-status aw-flip-window)))
  (golden-ratio-mode 1))
    #+END_SRC

*** Docker
    A Docker command wrapper for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package docker
  :defer t
  :config
  ;; Extra stuff Docker needs on Mac OS X
  (when (eq system-type 'darwin)
    (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
    (setq exec-path (append exec-path '("/usr/local/bin"))))

  ;; Set the Docker command for me, please.
  (setq docker-command (string-trim (shell-command-to-string "command -v docker"))))
    #+END_SRC

*** Projectile Rails
    Rails utilities for Projectile-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile-rails
  :after (projectile)
  :defer t
  :init
  (add-hook 'ruby-mode-hook 'projectile-rails-mode)
  (add-hook 'enh-ruby-mode-hook 'projectile-rails-mode)

  (evil-leader/set-key-for-mode 'ruby-mode "r" 'projectile-rails-command-map))
    #+END_SRC
*** Projectile Phoenix
I made this package! <3
It helps in working with Phoenix projects.
Since it's not published in MELPA yet, we need to load it directly from the git
repository.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path "~/projectile-phoenix/")
(load "projectile-phoenix")

(projectile-phoenix-global-mode)

;; Configure the binding for Phoenix project buffers
(add-hook 'find-file-hook #'(lambda ()
                              (when (projectile-phoenix-project-p)
                                (evil-leader/set-key "r" 'projectile-phoenix-command-map))))
#+END_SRC
*** Bundler
    Interact with Bundler from Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package bundler
  :defer t)
    #+END_SRC
*** Evil-numbers
    Increment and decrement numbers like in Vim.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-numbers
  :after (evil)
  :defer t
  :config
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-e") 'evil-numbers/dec-at-pt))
    #+END_SRC

*** Diff-Highlight
    Highlights the changed content in buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :ensure
  :defer t
  :config
  ;; ((defun hl-diff-tweaks()
  ;;   (diff-hl-mode t)
  ;;   (diff-hl-flydiff-mode t))
  ;;   (add-hook 'prog-mode-hook 'hl-diff-tweaks))
  )
    #+END_SRC
*** Evil-Matchit
    Adds more matching objects for the % operator in evil, such as
    def-end in Ruby/Python and HTML tags.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-matchit
  :after (evil)
  :defer t
  :ensure t
  :init
  (global-evil-matchit-mode 1))
    #+END_SRC
*** Writeroom Mode
    Dims the modeline, perfect for focusing on writing text/code
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package writeroom-mode
  :ensure t
  :defer t)
;; Activate it manually, it doesn't play well with Moe modeline globally
    #+END_SRC
*** Restart Emacs
    Restart Emacs from within Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package restart-emacs
  :defer t)
    #+END_SRC
*** Rainbow Delimiters
    Highlight parentheses, brackets and braces according to their
    depth.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :after (prog-mode)
  :defer t
  :init
  ;; Add this to prog-mode
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'slime-repl-mode-hook #'rainbow-delimiters-mode))
    #+END_SRC
*** Git Gutter
    Shows (and enables you to navigate between) parts of the code
    which where changed comparing to the current revision in a
    version-controlled project.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-gutter
  :when window-system
  :hook ((prog-mode text-mode) . 'git-gutter-mode)
  :diminish ""
  :config
  (use-package git-gutter-fringe
    :after (git-gutter)
    :defer t
    :ensure t
    :init
    (require 'git-gutter-fringe)
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:modified
        [224 224 224 224 224 224 224 224 224 224 224 224 224
             224 224 224 224 224 224 224 224 224 224 224 224]
        nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:deleted
        [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
        nil nil 'center)))
  ;; Adding evil-mode bindings
  (define-key evil-normal-state-map (kbd "g h") 'git-gutter:previous-hunk)
  (define-key evil-normal-state-map (kbd "g H") 'git-gutter:next-hunk)
  (define-key evil-normal-state-map (kbd "g @") 'git-gutter:popup-hunk))
    #+END_SRC

*** Magit
    How to win at Git from Emacs.
    The configuration for each part is below in separate headings.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :defer t
  :config
  ;; Highlight what changed in diffs.
  (setq magit-diff-refine-hunk t))
    #+END_SRC
**** Commit configuration
     #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-commit
  :after (magit)
  :hook (git-commit-mode . git-commit-tweaks)
  :custom (git-commit-summary-max-length 50)
  :preface
  (defun git-commit-tweaks ()
    "Ensures that the commit body does not exceed 72 characters."
    (setq fill-column 72)
    (set (make-local-variable 'company-backends) '(company-dabbrev company-capf company-files))
    (set (make-local-variable 'company-minimum-prefix-length) 2)
    (setq-local comment-auto-fill-only-comments nil)
    (evil-set-initial-state 'git-commit-mode 'emacs)
    ))
     #+END_SRC
**** Viewing diffs
#+BEGIN_SRC emacs-lisp :tangle yes
;; Wrap those long lines.
(add-hook 'magit-diff-mode-hook 'visual-line-mode)
#+END_SRC
**** Open files for code review
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/magit-open-changed-files-from-main ()
  "Opens the buffers visiting files that were changed compared to the main branch in the current branch.
   Requires M-x server-start first."
  (interactive "P")
  (magit-git-command-topdir "git --no-pager diff --name-only FETCH_HEAD $(git merge-base FETCH_HEAD origin/master) | xargs emacsclient -n"))
#+END_SRC
*** Yasnippets
    It originally came with company-mode, it's handy to write faster
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet-snippets)
(use-package yasnippet-classic-snippets)

(defun do-not-add-newline-for-snippets ()
  "What is says on the tin."
  (setq-local require-final-newline nil)
  )

(add-hook 'snippet-mode-hook 'do-not-add-newline-for-snippets)
    #+END_SRC
*** Circadian
    Theme changer for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package circadian
  :ensure t
  :config
  (cond
   ((eq system-type 'darwin)
    (setq circadian-themes '((:sunrise . cosmos-light)
                             (:sunset  . cosmos-dark))))
   ;; Personal Linux machine
   ((and (string-equal system-name auralcat/personal-system-name) (eq system-type 'gnu/linux))
    (setq circadian-themes '((:sunrise . solarized-light)
                             (:sunset  . solarized-dark))))
   ;; Work Linux machine
   ((and (string-equal system-name auralcat/work-system-name) (eq system-type 'gnu/linux))
    (setq circadian-themes '((:sunrise . modus-operandi)
                             (:sunset  . modus-vivendi)))))

  ;; Hooks
  (add-hook 'circadian-before-load-theme-hook
            #'(lambda (theme)
                (if (eq theme 'solarized-dark)
                    (set-frame-font "Fantasque Sans Mono"))
                ))

  (circadian-setup))
    #+END_SRC
*** Anzu
    Show search result count in the mode line.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-anzu
  :after (evil)
  :config
  (global-anzu-mode))
    #+END_SRC
*** Org-mode GFM exporter
GFM stands for *Github Flavored Markdown*. It's a nice exporter not just for that
use case though, since it removes the line wraps on exporting.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-gfm
  :defer t)
#+END_SRC
*** sqlformat
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sqlformat
  :commands (sqlformat sqlformat-buffer sqlformat-region)
  :hook (sql-mode . sqlformat-on-save-mode)
  :init
  ;; This is for Postgres.
  (setq sqlformat-command 'pgformatter
        sqlformat-args '("-s2" "-g")))
#+END_SRC
* Function Aliases
  #+BEGIN_SRC emacs-lisp :tangle yes
;; This is how you define aliases for Elisp functions. These are useful for when
;; you don't need to bind a command to a specific key, but you call that
;; function through M-x often.
(defalias 'plp 'package-list-packages)
(defalias 'kfs 'keyfreq-show)
  #+END_SRC
* Themes
  Remember to _defer_ the loading of the theme packages, otherwise the
  faces might get mixed up and look ugly.

  This function makes it easier to change themes quickly. You can bind it to a
  keychord or whatnot and use it as you wish.

  NOTE: If you want to run extra functions when changing themes,
  *you should add the function calls to the change theme function below*,
  otherwise the changes you want to happen won't take effect!
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/set-fringe-face-to-default-bg ()
  "Sets the fringe's background to the current theme's background color for the 'default face."
  (set-face-attribute 'fringe nil :background (face-attribute 'default :background)))

;; Set the fringe face function Circadian's change hook.
;; That way whenever the theme changes automatically, the fringe gets updated as
;; well.
(add-hook 'circadian-after-load-theme-hook 'auralcat/set-fringe-face-to-default-bg)

(defun auralcat/change-theme (new-theme)
  "Disables the current theme in the session, loads and enables the NEW-THEME."
  ;; This is the code Emacs uses to load themes in custom.el
  (interactive
   (list
    (intern (completing-read "Change to theme: "
                             (mapcar #'symbol-name
                                     (custom-available-themes))))))
  (let* (
         (current-theme (car custom-enabled-themes))
         (new-theme-loaded-p (memq new-theme custom-enabled-themes)))
    (disable-theme current-theme)
    (if new-theme-loaded-p
        (enable-theme new-theme)
      (load-theme new-theme))
    ;; We should do this here because not every theme defines a fringe face and
    ;; I customized the fringe on my end.
    (auralcat/set-fringe-face-to-default-bg))
  ;; We should also set the preferred fonts here because this function does not
  ;; run any hooks.
  (auralcat--set-preferred-fonts-for-current-theme))

;; Add the hook on circadian
;; Bind it to a keychord.
(global-set-key (kbd "M-`") 'auralcat/change-theme)
  #+END_SRC
** Jazz
   A warm theme with dark colors.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package jazz-theme :ensure t
  :defer t)
   #+END_SRC
** Abyss
   Dark contrast theme
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package abyss-theme :ensure :defer t)
   #+END_SRC
** Twilight Bright
   A port of the theme from TextMate.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package twilight-bright-theme :defer t)
   #+END_SRC
** Organic Green
   A light theme with a light-green background, looks real nice!
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package organic-green-theme :defer t)
   #+END_SRC
** Flat UI
   Flat colors which blend nicely.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flatui-theme :defer t)
   #+END_SRC
** Hemisu
   I like the dark theme from here.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package hemisu-theme :defer t)
   #+END_SRC
** Gruvbox
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gruvbox-theme :defer t)
#+END_SRC
** Solarized themes
These are the official ones.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package solarized-theme :defer t)
#+END_SRC
** Modus themes
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package modus-themes
  :init
  (setq modus-themes-syntax 'green-strings
        modus-themes-success-deuteranopia t))
#+END_SRC
* Fonts
It's better to set the fonts here instead of hard-coding them in init.el or in
the themes themselves.
** Default
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set fonts for each system if the extra ones are installed.
;; Otherwise use the system's default fonts.
(defun auralcat--set-fixed-pitch-fonts (font-name height)
  "Sets the fixed pitch fonts with the FONT-NAME family and the height as HEIGHT for both the 'default and 'fixed-pitch faces."
  (set-face-attribute 'default nil :family font-name :height height)
  (set-face-attribute 'fixed-pitch nil :family font-name :height height)
  (set-face-attribute 'org-block nil :family font-name :height height)
  (set-face-attribute 'org-table nil :family font-name :height height))

(defun auralcat--set-preferred-fonts-for-current-theme ()
  "Sets the preferred fonts for the current theme depending on the system Emacs is used in."
  (cond
   ((eq system-type 'darwin)
    (if (font-info "Fantasque Sans Mono")
        (auralcat--set-fixed-pitch-fonts "Fantasque Sans Mono" 140)
      (auralcat--set-fixed-pitch-fonts "Monaco" 120)))
   ((eq system-type 'gnu/linux)
    (if (font-info "Fantasque Sans Mono")
        (auralcat--set-fixed-pitch-fonts "Fantasque Sans Mono" 120)
      (auralcat--set-fixed-pitch-fonts "Ubuntu Mono" 120)))))

;; Use Helvetica as the sans-serif font when available.
(when (font-info "Helvetica")
    (set-face-attribute 'variable-pitch nil :family "Helvetica" :height 120))
  #+END_SRC
* Graphical
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set font in graphical mode
(when (display-graphic-p)
  ;; Remove menu and scroll bars in graphical mode
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  ;; Maximize frame on startup
  (toggle-frame-maximized)
  ;; Space lines and bask in the gloriousness of graphical mode.
  ;; 0.4 feels better for prose, and 0.2 is fine for code.
  (add-hook 'prog-mode-hook (lambda () (setq line-spacing 0.2)))
  (add-hook 'comint-mode-hook (lambda () (setq line-spacing 0.2)))
  (add-hook 'text-mode-hook (lambda () (setq line-spacing 0.6))))
  #+END_SRC

** Adjust variable pitch fonts and monospace fonts
Explanation/Context: https://github.com/olivertaylor/olivertaylor.github.io/blob/master/notes/20210324_emacs-optical-font-adjustment.org
#+BEGIN_SRC emacs-lisp :tangle yes
(defun scale-up-variable-pitch-face ()
  "In the current buffer, scale variable-pitch up and fixed-pitch down."
  (interactive)
  (face-remap-add-relative 'variable-pitch :height 1.1)
  (face-remap-add-relative 'fixed-pitch :height 0.9))

(add-hook 'buffer-face-mode-hook 'scale-up-variable-pitch-face)
#+END_SRC

* Multiplexing
This involves window and tab management.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Set rules for displaying buffers in windows.
(setq display-buffer-alist
      ;; Press q in the Magit buffer and the window vanishes!
      `(("^magit: .*$"
         (display-buffer-reuse-mode-window display-buffer-reuse-window display-buffer-at-bottom)
         (window-height . 0.5)
         (window-parameters . ((delete-window . t)))
         )
        ;; A buffer with unit test results: they're easier to read in another frame.
        ("^\\*mix .*\\*$"
         (display-buffer-use-some-frame display-buffer-in-tab display-buffer-reuse-mode-window display-buffer-reuse-window)
         (reusable-frames . t)
         (tab-name . "*Test results*")
         (inhibit-same-window . t)
         )
        ;; Search buffers tend to be more useful when they're in the same frame as the code.
        ("\\(^\\*ag search text:.*\\*$\\|\\^*Occur.*\\*$\\)"
         (display-buffer-reuse-mode-window display-buffer-reuse-window)
         )
        ("^\\*Org .*Export\\*$"
         (display-buffer-reuse-window display-buffer-in-side-window)
         (window-height . 0.5)
         (window-parameters . ((delete-window . t)))
         )))
#+END_SRC

* Keybindings
 #+BEGIN_SRC emacs-lisp :tangle yes
;; Translate the compose keys
(define-key key-translation-map (kbd "¹") (kbd "M-1"))
(define-key key-translation-map (kbd "²") (kbd "M-2"))
(define-key key-translation-map (kbd "³") (kbd "M-3"))
(define-key key-translation-map (kbd "£") (kbd "M-4"))
(define-key key-translation-map (kbd "¢") (kbd "M-5"))
(define-key key-translation-map (kbd "ð") (kbd "M-d"))
(define-key key-translation-map (kbd "ß") (kbd "M-s"))
(define-key key-translation-map (kbd "»") (kbd "M-x"))
(define-key key-translation-map (kbd "ŋ") (kbd "M-g"))
(define-key key-translation-map (kbd "<M-S-dead-grave>") (kbd "M-`"))
(define-key key-translation-map (kbd "“") (kbd "M-v"))
(define-key key-translation-map (kbd "‘") (kbd "M-S-v"))
(define-key key-translation-map (kbd "C-“") (kbd "C-M-v"))
(define-key key-translation-map (kbd "C-‘") (kbd "C-S-M-v"))
(define-key key-translation-map (kbd "æ") (kbd "M-a"))
(define-key key-translation-map (kbd "C-æ") (kbd "C-M-a"))
(define-key key-translation-map (kbd "Æ") (kbd "M-S-a"))
(define-key key-translation-map (kbd "°") (kbd "M-e"))
(define-key key-translation-map (kbd "C-°") (kbd "C-M-e"))
(define-key key-translation-map (kbd "đ") (kbd "M-f"))
(define-key key-translation-map (kbd "ª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "C-đ") (kbd "C-M-f"))
(define-key key-translation-map (kbd "C-ª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "”") (kbd "M-b"))
(define-key key-translation-map (kbd "’") (kbd "M-S-b"))
(define-key key-translation-map (kbd "C-”") (kbd "C-M-b"))
(define-key key-translation-map (kbd "C-’") (kbd "C-M-S-b"))
(define-key key-translation-map (kbd "©") (kbd "M-c"))
(define-key key-translation-map (kbd "C-©") (kbd "C-M-c"))
(define-key key-translation-map (kbd "C-ß") (kbd "C-M-s"))
(define-key key-translation-map (kbd "C-®") (kbd "C-M-r"))
(define-key key-translation-map (kbd "®") (kbd "M-r"))
(define-key key-translation-map (kbd "M-°") (kbd "M-S-e"))
;; C-M-number translations.
(define-key key-translation-map (kbd "⅜") (kbd "M-%"))
(define-key key-translation-map (kbd "C-⅜") (kbd "C-M-%"))
(define-key key-translation-map (kbd "¼") (kbd "M-$"))
(define-key key-translation-map (kbd "C-¼") (kbd "C-M-$"))
(define-key key-translation-map (kbd "¾") (kbd "M-#"))
(define-key key-translation-map (kbd "C-¾") (kbd "C-M-#"))
(define-key key-translation-map (kbd "½") (kbd "M-@"))
(define-key key-translation-map (kbd "C-½") (kbd "C-M-@"))
(define-key key-translation-map (kbd "¡") (kbd "M-!"))
(define-key key-translation-map (kbd "C-¡") (kbd "C-M-!"))

;; Some speed commands
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'ido-switch-buffer)
(global-set-key (kbd "M-4") 'switch-to-buffer-other-window)
(global-set-key (kbd "M-5") 'tab-bar-switch-to-tab)

(define-key comint-mode-map (kbd "M-1") 'delete-other-windows)
(define-key comint-mode-map (kbd "M-4") 'switch-to-buffer-other-window)

;; Improve the case change commands with built-in DWIM
(global-set-key (kbd "M-u") 'upcase-dwim)
(global-set-key (kbd "M-l") 'downcase-dwim)
(global-set-key (kbd "M-c") 'capitalize-dwim)

;; Resize the frame with ease
(global-set-key [M-f11] (quote toggle-frame-fullscreen))
(global-set-key [M-f10] (quote toggle-frame-maximized))

(global-set-key (kbd "M-\"") (quote abbrev-prefix-mark))

;; Switch windows and frames
(define-key global-map (kbd "M-o") 'other-window)
(define-key global-map (kbd "C-M-o") 'other-frame)

;; Scroll other windows' pages easier
(define-key global-map (kbd "M-]") 'scroll-other-window)
(define-key global-map (kbd "M-[") 'scroll-other-window-down)

;; Unfill region
(define-key global-map "\C-\M-q" 'unfill-region)

;; Mapping AltGr-d to delete-other-windows,
;; Another symbol I don't use often.
(global-set-key [240] (quote delete-other-windows))

;; Map the Home and End keys to go to the beginning and end of the buffer
(global-set-key [home] (quote beginning-of-buffer))
(global-set-key [end] (quote end-of-buffer))

;; Move to beginning of line or indentation
(defun back-to-indentation-or-beginning () (interactive)
       (if (= (point) (progn (back-to-indentation) (point)))
           (beginning-of-line)))

;; We need this to get back to the beginning of the indentation or first word of the line.
(global-set-key (kbd "C-a") (quote back-to-indentation-or-beginning))

;; Hippie-Expand: change key to M-SPC; Replace dabbrev-expand
(global-set-key "\M- " 'hippie-expand)
(global-set-key "\M-/" 'hippie-expand)

;; Eshell configuration
(defun eshell-tweaks ()
  "Tweaks for the Emacs shell"
  (evil-set-initial-state 'shell-mode 'emacs))
(add-hook 'shell-mode-hook 'eshell-tweaks)

;; Evaluate buffer using SPC SPC, depending on major mode.
(evil-leader/set-key-for-mode 'emacs-lisp-mode "SPC" 'eval-buffer)
(evil-leader/set-key-for-mode 'enh-ruby-mode "SPC" 'ruby-send-buffer-and-go)
(evil-leader/set-key-for-mode 'ruby-mode "!" 'auralcat/ruby/add-byebug-line)
(evil-leader/set-key-for-mode 'ruby-mode "SPC" 'ruby-send-buffer-and-go)
(evil-leader/set-key-for-mode 'python-mode "SPC" 'python-shell-send-buffer)
(evil-leader/set-key-for-mode 'js2-mode "SPC" 'js-comint-send-buffer)
(evil-leader/set-key-for-mode 'elixir-mode "!" 'auralcat/elixir-iex-pry)
(evil-leader/set-key-for-mode 'elixir-mode "SPC" 'inf-elixir-send-buffer)
  #+END_SRC
* Org-mode
** Main configuration
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Some bindings for Emacs mode.
;; I've noticed that Org seems easier to navigate with Emacs bindings instead of Evil.
(define-key global-map (kbd "C-c a") 'org-agenda)
(define-key global-map (kbd "C-c k") 'org-capture)

;; Start indented, with inline images, and don't show emphasis markers.
(setq org-startup-indented t
      org-startup-with-inline-images t
      org-hide-emphasis-markers t)

;; We don't need Flycheck in org-mode buffers. Usually.
(add-hook 'org-mode-hook '(lambda() (flycheck-mode 0)))

;; Change the end of collapsed headings to an arrow.
(setq org-ellipsis "⤵")

;; Keep agenda file list in a single file so I can publish my config.
;; DO NOT use C-c [ or C-c ] to add/remove files to the agenda otherwise
;; Emacs will write the var to init.el
(setq org-agenda-files "~/file-bouncer/org-agenda-file-list.org")

;; When TODOs are ordered, enforce task dependencies
(setq org-enforce-todo-dependencies t)

;; Don't split my lines, thx.
(setq org-M-RET-may-split-line nil)

;; Truncate long task names
(setq org-clock-heading-function
      (lambda ()
        (let ((str (nth 4 (org-heading-components))))
          (concat (truncate-string-to-width str 27) "...")
          )))

;; Organize the bindings
;; Open subheading with C-c RET and invert with M-RET
(define-key org-mode-map (kbd "C-c RET") 'org-ctrl-c-ret)
(define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)

;; Use C-RET to complete words in Org-mode
(define-key org-mode-map (kbd "C-RET") 'complete)

;; Always respect the content of a heading when creating todos!
(define-key org-mode-map (kbd "<M-S-return>") 'org-insert-todo-heading-respect-content)

;; Map C-S-enter to org-insert-todo-subheading
(define-key org-mode-map (kbd "<C-S-return>") 'org-insert-todo-subheading)

;; Use Emacs mode in Org-capture buffers and notes buffer
(add-hook 'org-capture-mode-hook 'evil-emacs-state)

;; Idiot-proofing my configs
(define-key org-mode-map (kbd "C-c ]") nil)
(define-key org-mode-map (kbd "C-c [") nil)

;; Simplify org-todo in org-mode buffers with <leader> t
(evil-leader/set-key-for-mode 'org-mode "t" 'org-todo)

;; Log when a task was done and when it was rescheduled.
(setq org-log-done 'time)
(setq org-log-reschedule 'time)

;; Don't write inside invisible area when collapsing headings!
(setq org-catch-invisible-edits 'error)

;; Define a standard format for Org's column view
(setq org-columns-default-format "%50ITEM(Item) %EFFORT(Effort) %CLOCK(Time Spent)")

;; Set agenda as sticky. This makes the buffers persistent, and load faster if
;; you open them all the time.
(setq org-agenda-sticky t)
   #+END_SRC
** Org-agenda configuration
Colorize the agenda: https://llazarek.com/2018/07/improving-the-agenda.html
#+BEGIN_SRC emacs-lisp :tangle yes
(defun ll/org/agenda/color-headers-with (tag fg-col bg-col)
  "Color agenda lines matching TAG with color FG-COL."
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward tag nil t)
    (unless (find-in-line "\\[#[A-Z]\\]")
      (let ((todo-end (or (ll/org/agenda/find-todo-word-end)
                          (point-at-bol)))
            (tags-beginning (or (find-in-line " :" t)
                                (point-at-eol))))
        (add-text-properties todo-end
                             tags-beginning
                             `(face (:foreground ,fg-col :background ,bg-col)))))))

;; Helper definitions
(setq ll/org/agenda-todo-words
      '("TODO" "GOAL" "NEXT" "STARTED" "WAITING" "REVIEW" "SUBMIT"
        "DONE" "DEFERRED" "CANCELLED"))
(defun find-in-line (needle &optional beginning count)
  "Find the position of the start of NEEDLE in the current line.
  If BEGINNING is non-nil, find the beginning of NEEDLE in the current
  line. If COUNT is non-nil, find the COUNT'th occurrence from the left."
  (save-excursion
    (beginning-of-line)
    (let ((found (re-search-forward needle (point-at-eol) t count)))
      (if beginning
          (match-beginning 0)
        found))))
(defun ll/org/agenda/find-todo-word-end ()
  (reduce (lambda (a b) (or a b))
          (mapcar #'find-in-line ll/org/agenda-todo-words)))

;; Load my tag colors
(load "~/.agenda-colors")
#+END_SRC

** Org-English mode
This is a derived mode to hold English abbrevs.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode org-english-mode org-mode "Org-EN"
  "Org-mode used to hold English abbrevs. Does everything that plain org-mode does.")

(add-to-list 'auto-mode-alist '("\\.org\\.en?\\'" . org-english-mode))
#+END_SRC
** Auto-mark TODO entries as DONE
   #+BEGIN_SRC emacs-lisp :tangle yes
;; see http://thread.gmane.org/gmane.emacs.orgmode/42715
(eval-after-load 'org-list
  '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

;; Mark a parent TODO entry as DONE when its checkboxes are all ticked
(defun ndk/checkbox-list-complete ()
  (save-excursion
    (org-back-to-heading t)
    (let ((beg (point)) end)
      (end-of-line)
      (setq end (point))
      (goto-char beg)
      (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
          (if (match-end 1)
              (if (equal (match-string 1) "100%")
                  ;; all done - do the state change
                  (org-todo 'done)
                (org-todo 'todo))
            (if (and (> (match-end 2) (match-beginning 2))
                     (equal (match-string 2) (match-string 3)))
                (org-todo 'done)
              (org-todo 'todo)))))))
   #+END_SRC
** Tables
Use the fixed-pitch font for tables.
#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+END_SRC
** Capture templates
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Load them from a separate file.
(load "~/.org-capture-templates.el")
   #+END_SRC
** Org-bullets
   Change org-mode's *s to UTF-8 chars
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-bullets
  :init
  (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1)))
  ;; Fallback bullets.
  (setq org-bullets-bullet-list (quote ("✿" "❀" "◉" "○" "✸")))
  )
   #+END_SRC
** Org-babel
*** General settings
- Do not ask me if I want to run the source block
- Output the results in _scripting_ mode, instead of eval mode.
- Wrap them in an example block (for exporting)
  Important: the default header args will be:
  =:noweb :results output verbatim replace :exports both=
- Also display the contents of the source code block in a monospace font when possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-org-confirm-babel-evaluate (lang body)
  "Don't confirm squat."
  (not (member lang '("sh" "elisp" "ruby" "elixir" "shell"))))

;; A few more tweaks for org-babel.
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate
      org-src-preserve-indentation t
      org-babel-min-lines-for-block-output 1
      org-babel-default-header-args
      (cons '(:noweb . "yes")
            (assq-delete-all :noweb org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:exports . "both")
            (assq-delete-all :exports org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:results . "output verbatim replace")
            (assq-delete-all :results org-babel-default-header-args)))
#+END_SRC
*** Elixir
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-elixir)
    #+END_SRC
*** Load languages
    #+BEGIN_SRC emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (shell . t)
   (python . t)
   (sql . t)
   (ruby . t)
   (elixir . t)
   (plantuml . t)
   (dot . t)
   ))
    #+END_SRC

** Evil-org
   Evil-mode keybindings for org-mode.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil-org
  :diminish evil-org-mode
  :hook (org-mode . evil-org-mode)
  )

;; Use 'complete when pressing C-<return> in insert mode for org-mode buffers.
(add-hook 'org-mode-hook #'(lambda () (define-key evil-insert-state-map (kbd "C-<return>") 'complete)))
   #+END_SRC
* Variables
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set Fundamental mode as default mode for new buffers:
(setq-default major-mode 'fundamental-mode)
(setq initial-major-mode 'fundamental-mode)

;; Enable auto-fill mode by default
(auto-fill-mode 1)

;; When toggling a buffer into read-only mode, activate view-mode immediately.
(setq view-read-only t)

;; Change tab width and change tabs to spaces
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)

;; Making Emacs auto-indent
(define-key global-map (kbd "RET") 'newline-and-indent)

;; Shows trailing whitespace, if any:
(setq-default show-trailing-whitespace t)

(defun css-mode-tweaks()
  (set (make-local-variable 'company-backends) '(company-css company-yasnippet company-etags))
  (emmet-mode 1))

;; Emmet-mode: activate for html-mode, sgml-mode,
;; css-mode, web-mode and sass-mode
(add-hook 'sgml-mode-hook 'emmet-mode)
(add-hook 'sass-mode-hook 'css-mode-tweaks)
(add-hook 'web-mode-hook 'emmet-mode)
(add-hook 'css-mode-hook 'css-mode-tweaks)

;; Python: use python3 as default shell interpreter
(setq python-shell-interpreter "python3")

  #+END_SRC
** Project-local variables
Disable the ~risky-variable~ check. I know what I'm doing.
This can be reverted later with ~(advice-remove)~ though.
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add 'risky-local-variable-p :override #'ignore)
#+END_SRC
* Custom functions
** Calculate leap year
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun is-leap-year (year)
  "Checks if the given YEAR is a leap year"
  (interactive "P")
  (or
   (and (not (eq (% year 100) 0))
        (eq (% year 4) 0))
   (eq (% year 400) 0))
  )

   #+END_SRC
** Quick org-todo without leaving current buffer
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun my-org-remote-todo ()
  "Changes the TODO state of the currently clocked heading remotely."
  (interactive)
  (org-clock-goto)
  (org-todo)
  (mode-line-other-buffer)
  )
   #+END_SRC
** Unfill region
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Unfill region, AKA leave single huge line
(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
       logical line.  This is useful, e.g., for use with
       `visual-line-mode'."
  (interactive "*r")
  (let ((fill-column (point-max)))
    (fill-region beg end)))
   #+END_SRC
* Work configurations
I prefer to leave the work Elisp configuration files somewhere else because they
contain private/confidential information.

These are usually aliases to commonly-accessed tools and workflows.
#+BEGIN_SRC emacs-lisp :tangle yes
(let ((work-config-file "~/elisp-work/work-config.el")
      (work-config-entrypoint-dir "~/elisp-work"))
  (when (file-exists-p work-config-entrypoint-dir)
    (add-to-list 'load-path work-config-entrypoint-dir)
    ;; Main entrypoint.
    (load work-config-file)))

#+END_SRC
* Mode Line
** VC mode customizations
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add #'vc-git-mode-line-string :filter-return #'my-replace-git-status)
(defun my-replace-git-status (tstr)
  (let* ((tstr (replace-regexp-in-string "Git" "" tstr))
         (first-char (substring tstr 0 1))
         (rest-chars (substring tstr 1)))
    (cond
     ((string= ":" first-char) ;;; Modified
      (replace-regexp-in-string "^:" "⚡️" tstr))
     ((string= "-" first-char) ;; No change
      (replace-regexp-in-string "^-" "✔️" tstr))
     (t tstr))))
#+END_SRC
** Custom code
[[https://github.com/rnkn/olivetti/issues/39#issuecomment-660606677][Source]]
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mode-line-align (left right)
  "Return a string with LEFT and RIGHT at the edges of the
  current window."
  (format (format "%%s %%%ds" (- (window-total-width) (length left) 2))
          left right))

(setq auralcat/mode-line-left-side
      ;; This should be a quoted list if you want values to be updated
      ;; when things change in the buffer.
      '(
        " " evil-mode-line-tag
        " " mode-line-buffer-identification
        " " mode-line-modified
        " " mode-name
        " " mode-line-position
        " " (vc-mode vc-mode)
        ))

(setq auralcat/mode-line-right-side
      (list minor-mode-alist
            " " mode-line-misc-info
            " " mode-line-end-spaces))

;; This needs to be setq-default to make every buffer use this mode line format.
(setq-default mode-line-format
      '("%e" (:eval (mode-line-align
                     (format-mode-line
                      auralcat/mode-line-left-side)
                     (format-mode-line
                      auralcat/mode-line-right-side)))))
#+END_SRC
* Cursor
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/get-face-foreground-color (face)
  "Return the hex code from the specified FACE."
  (face-attribute face :foreground))

;; Use basic faces to customize Evil cursors based on theme.
(defun auralcat/set-evil-faces-based-on-current-theme ()
  "Changes the faces for Evil modes based on current theme."
  (let
      ((evil-normal-face-color    (auralcat/get-face-foreground-color  'font-lock-builtin-face))
       (evil-insert-face-color    (auralcat/get-face-foreground-color  'font-lock-string-face))
       (evil-motion-face-color    (auralcat/get-face-foreground-color  'font-lock-keyword-face))
       (evil-replace-face-color   (auralcat/get-face-foreground-color  'font-lock-keyword-face))
       (evil-operator-face-color  (auralcat/get-face-foreground-color  'font-lock-constant-face))
       (evil-visual-face-color    (auralcat/get-face-foreground-color  'font-lock-type-face))
       (zoom-window-color    (auralcat/get-face-foreground-color  'font-lock-string-face)))
    (setq  evil-normal-state-cursor    `(,evil-normal-face-color    box))
    (setq  evil-insert-state-cursor    `(,evil-insert-face-color    bar))
    (setq  evil-motion-state-cursor    `(,evil-motion-face-color    box))
    (setq  evil-replace-state-cursor   `(,evil-replace-face-color   hbar))
    (setq  evil-operator-state-cursor  `(,evil-operator-face-color  box))
    (setq  evil-visual-state-cursor    `(,evil-visual-face-color    box))
    (setq  zoom-window-mode-line-color zoom-window-color)))

(add-hook 'circadian-after-load-theme-hook #'(lambda (theme) (auralcat--set-preferred-fonts-for-current-theme)))
(add-hook 'circadian-after-load-theme-hook #'(lambda (theme) (auralcat/set-evil-faces-based-on-current-theme)))
(add-hook 'after-init-hook #'(lambda () (auralcat--set-preferred-fonts-for-current-theme)))
(add-hook 'after-init-hook #'(lambda () (auralcat/set-evil-faces-based-on-current-theme)))

;; This is to be able to tell when I'm in Emacs state.
(setq evil-emacs-state-cursor '("purple" box))

(setq-default blink-cursor-blinks 0)
(setq-default blink-cursor-interval 0.6)
(setq-default blink-cursor-delay 0.2)
#+END_SRC
** Cursor position
Saves where you were in the last time you edited a given file.
This could be a subtle hint about what you were doing.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq save-place-file "~/.places")
(setq save-place-forget-unreadable-files t)
(save-place-mode 1)
#+END_SRC
* Diary
** Last day of month
   #+BEGIN_SRC emacs-lisp :tangle yes
;; ORG-MODE:
;; * My Task
;;   SCHEDULED: <%%(diary-last-day-of-month date)>
;;; DIARY:  %%(diary-last-day-of-month date) Last Day of the Month
;;; See also:  (setq org-agenda-include-diary t)
;;; (diary-last-day-of-month '(2 28 2017))
(defun diary-last-day-of-month (date)
  "Return `t` if DATE is the last day of the month."
  (let* ((day (calendar-extract-day date))
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (last-day-of-month
          (calendar-last-day-of-month month year)))
    (= day last-day-of-month)))

(defun diary-first-weekday-of-month (date)
  (let* ((day (calendar-extract-day date))
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (first-day-date (list month 1 year))
         (first-absolute-day-weekday (calendar-day-of-week first-day-date)))

    (or
     ;; When the first day is Sunday, it's day 2.
     (and (eq first-absolute-day-weekday 0)
          (eq day 2))

     ;; When the first day is Saturday, it's day 3.
     (and (eq first-absolute-day-weekday 6)
          (eq day 3))

     ;; Else, it's day 1 and a weekday.
     (and (memq (calendar-day-of-week date) '(1 2 3 4 5))
          (eq day 1))
     )
    ))

(defun diary-last-weekday-of-month (date)
  (let* ((day-of-week (calendar-day-of-week date))
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (last-month-day (calendar-last-day-of-month month year))
         (month-day (cadr date)))

    (or
     ;; it's the last day of the month & it is a weekday
     (and (eq month-day last-month-day)
          (memq day-of-week '(1 2 3 4 5)))

     ;; it's a friday, and it's the last-but-one or last-but-two day
     ;; of the month
     (and (eq day-of-week 5)
          (or (eq month-day (1- last-month-day))
              (eq month-day (1- (1- last-month-day))))))))

(defun diary-first-working-day-of-month (date)
  "Returns `t` if DATE is the first working day of the month.
  This is defined as the first weekday of the month which is not a holiday."
  (let* ((day (calendar-extract-day date))
         (month (calendar-extract-month date)))
    (if
        ;; If it's May or Jan, check if day 2 is a weekday.
        (and (or (= month 5) (= month 1)))
        (and (= day 2) (memq (calendar-day-of-week date) '(1 2 3 4 5)))
      ;; Else, check if it's the first weekday of the month.
      (diary-first-weekday-of-month date))))
   #+END_SRC
