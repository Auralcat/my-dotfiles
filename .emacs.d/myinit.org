#+TITLE: Emacs configuration file
#+AUTHOR: Auralcat
#+DATE: 2017:05:17
#+LANGUAGE: en

* Startup
  #+BEGIN_SRC emacs-lisp :tangle yes
   ;; Set fallback font
    (set-face-attribute 'default nil :font "Ubuntu Mono" :height 120)
  #+END_SRC
* Midnight mode
  Think of this as a kind of cron for Emacs. It runs a list of
  specified commands every "midnight". What constitutes a "midnight"
  can be defined by the user.
  The default action for ~midnight-hook~ is ~clean-buffer-list~
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package midnight
      :init
      ;; A good time for my "midnight" is 11:45am.
      (midnight-delay-set 'midnight-delay "11:45am")
      )
  #+END_SRC
* Evil Mode
  Yes, I'm committing this heresy
**** Evil-leader
     Add a prefix key to Evil mode, like the Leader key in Vim.
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package evil-leader)
       (load "~/my-dotfiles/.emacs.d/elisp-custom/evil-leader-custom-functions.el")
       (global-evil-leader-mode)
       ;; Evil mode needs to be loaded after evil-leader
       (use-package evil)
       (evil-mode 1)

       ;; Load configs
       (load "~/my-dotfiles/.emacs.d/evilrc")
     #+END_SRC
**** Evil Surround
     Easier manipulation of delimiters, emulation of vim.surround
     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-surround)
     (global-evil-surround-mode)
     #+END_SRC
**** Custom text objects
***** Ruby Block
      Defines a text object for Ruby blocks.
      Credits: [[https://github.com/env0der][@env0der's dotfiles]]
      My modification is just the ~ruby-block-beg-re~ variable.
      #+BEGIN_SRC emacs-lisp :tangle yes
      (evil-define-text-object evil-textobj-outer-ruby-block
        (count &optional beg end type)
        (evil-ruby-block-range beg end type count t))

      (evil-define-text-object evil-textobj-inner-ruby-block
        (count &optional beg end type)
        (evil-ruby-block-range beg end type count nil))

      (defun evil-ruby-block-range (count beg end type &optional inclusive)
        (let ((current-point (point))
          (block-begin (progn (evil-end-of-line) (re-search-backward ruby-block-beg-re nil t)))
          (block-end (progn (evilmi-jump-items) (point))))
          (if inclusive
          (let ((begin (progn (goto-char block-begin) (evil-beginning-of-line) (point)))
            (end (progn (goto-char block-end) (evil-next-line) (evil-beginning-of-line) (if (looking-at "^$") (+ (point) 1) (point)))))
            (progn
              (goto-char current-point)
              (evil-range begin end)))
        (let ((begin (progn (goto-char block-begin) (evil-next-line) (evil-first-non-blank) (point)))
              (end (progn (goto-char block-end) (evil-previous-line) (evil-end-of-line) (+ (point) 1))))
          (progn
            (goto-char current-point)
            (evil-range begin end))))))

    (define-key evil-inner-text-objects-map "r" 'evil-textobj-inner-ruby-block)
    (define-key evil-outer-text-objects-map "r" 'evil-textobj-outer-ruby-block)
      #+END_SRC

* Macros
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; To save a macro, record it with C-x ( (start) and C-x ) (stop),
    ;; give it a name with C-x C-k n (C-k is for maKro) and
    ;; insert it in this file with insert-kbd-macro.
    ;; Then you execute it mapping it to a key! üòä

    (fset 'auralcat/ruby-clone-method
          (lambda (&optional arg) "Clones a def method in Ruby." (interactive "p") (kmacro-exec-ring-item (quote ([86 125 121 103 118 escape 112] 0 "%d")) arg)))

    (fset 'auralcat/search-git-conflict-string
          (lambda (&optional arg) "Searches for a Git conflict string." (interactive "p") (kmacro-exec-ring-item (quote ([134217747 94 91 60 61 62 93 13] 0 "%d")) arg)))
  #+END_SRC
* Mac OS
  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (eq system-type 'darwin) ;; mac specific settings
      ;; Map Command to Meta
      (setq mac-command-modifier 'meta)
      ;; Map Option to Control (I know, smaller key, that's what we have for now. :/)
      (setq mac-option-modifier 'control)
      ;; Increase the font size.
      (set-default-font "Fantasque Sans Mono 14")
      ;; Point the executables in Mac OS to Emacs.
      (add-to-list 'exec-path "/usr/local/bin/")
      ;; Enable EPA
      (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))

      ;; Exec path from shell - Replicates terminal env vars in graphical Emacs
      (use-package exec-path-from-shell
        :init
        (exec-path-from-shell-initialize))

      ;; Use Emacsclient in OS X
      (setq server-socket-dir (format "/tmp/emacs%d" (user-uid))))
  #+END_SRC
* Environment Customizations
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; Sentences end with single spaces for me.
    (setq sentence-end-double-space nil)

    ;; Set locale to Brazilian Portuguese
    (set-locale-environment "pt_BR.UTF-8")

    ;; Change window title
    (setq frame-title-format '("Emacs 26"))

    ;; A small performance improvement
    (setq redisplay-dont-pause t)

    ;; I don't like lockfiles
    (setq create-lockfiles nil)

    ;; Store all backups in a specific folder:
    (setq backup-directory-alist `(("." . "~/file-bouncer/emacs-backups")))

    ;; Manual packages load path
    (add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-themes/")

    ;; Manual Elisp scripts load path
    (add-to-list 'load-path "~/my-dotfiles/.emacs.d/elisp-custom")

    ;; Backup files by copying them
    (setq backup-by-copying t)

    ;; I'm too lazy to type "yes" or "no"
    (fset 'yes-or-no-p 'y-or-n-p)

    ;; Clean whitespace before saving a file
    (add-hook 'before-save-hook 'whitespace-cleanup)

    ;; While you're at it, save automatically when visiting files.
    ;; It's surprisingly useful. The only caveat is when you got an
    ;; open comment like this. It will remove all the whitespace.
    ;; It saves the file after 5 seconds of inactivity.
    (auto-save-visited-mode t)

    ;; Allow only one theme at a time
    (setq custom-theme-allow-multiple-selections nil)

    ;; Enable ido-mode (fewer keystrokes to switch buffers!)
    (ido-mode 1)

    ;; Easier mark cycling, both local and global
    (setq set-mark-command-repeat-pop t)

    ;; ido-mode in the minibuffer
    (icomplete-mode 1)

    ;; Replace the built-in buffer menu with ibuffer
    (global-set-key [24 2] (quote ibuffer))

    ;; Prevent the scratch buffer from being killed
    (with-current-buffer "*scratch*"
      (emacs-lock-mode 'kill))

    ;; Enable auto-revert-mode
    (global-auto-revert-mode t)

    ;; Remove the menu bar in terminal mode
    (when (not (display-graphic-p))
      (menu-bar-mode -1))

    ;; Use Bash as default shell interpreter
    (setq org-babel-sh-command "/bin/bash")

    ;; Activate Company mode
    (add-hook 'after-init-hook 'global-company-mode)

    ;; Enable global Abbrev mode
    (setq-default abbrev-mode t)

    ;; Save last edited place in files
    (require 'saveplace)
    (setq-default save-place t)

    ;; I need a bigger kill ring.
    (setq kill-ring-max 180)

    ;; Use recentf-mode
    (recentf-mode)
  #+END_SRC

* Personal info
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; Load from external file.
    (load "~/.emacs.secrets")
  #+END_SRC
* Abbreviations
  #+BEGIN_SRC emacs-lisp :tangle yes
  (setq abbrev-file-name "~/.abbrev_defs")
  #+END_SRC
* Hooks
  #+BEGIN_SRC emacs-lisp :tangle yes
  ;; Prog-mode is from where all the programming modes are derived from.
  ;; This means that if you call prog-mode-hook, the settings will be
  ;; applied to ALL programming modes in Emacs.

  (defun prog-mode-tweaks ()
    ;; Set line number mode and column number mode for code files
    (if (< (string-to-number emacs-version) 24)
        (line-number-mode 1)
      (display-line-numbers-mode))
      (setq fill-column 80)
    )
  (add-hook 'prog-mode-hook 'prog-mode-tweaks)
  (add-hook 'text-mode-hook 'column-number-mode)

  ;; Ruby
  ;; Activate ruby-tools
  (add-hook 'enh-ruby-mode-hook (quote ruby-tools-mode))

  ;; Create filling for org-mode
  (add-hook 'org-mode-hook 'auto-fill-mode)
  #+END_SRC
* IRC
  Qui Nov  2 19:57:06 BRST 2017 - Tried using IRC inside Emacs, didn't please
  me, too many buffers to work with... for now.
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Use Weechat from Emacs
(use-package weechat
 :bind (:map weechat-mode-map
       ("<up>" . weechat-previous-input)
       ("<down>" . weechat-next-input)
       ("√∞" . delete-other-windows)
       ("‚Äù" . switch-to-buffer)))
  #+END_SRC

* Custom functions
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; Unfill region, AKA leave single huge line
    (defun unfill-region (beg end)
      "Unfill the region, joining text paragraphs into a single
      logical line.  This is useful, e.g., for use with
      `visual-line-mode'."
      (interactive "*r")
      (let ((fill-column (point-max)))
        (fill-region beg end)))

    (load "~/my-dotfiles/.emacs.d/elisp-custom/docker-sync-utils.el")
  #+END_SRC
* Function Aliases
  #+BEGIN_SRC emacs-lisp :tangle yes
;; This is how you define aliases for Elisp functions
(defalias 'plp 'package-list-packages)
  #+END_SRC
* Packages
** Major Modes
*** Elixir-mode
    Elixir support for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package elixir-mode)
    #+END_SRC
*** Sass-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package sass-mode
       ;; Set Sass mode for SASS files and Css mode for SCSS files.
       :config
       (add-to-list 'auto-mode-alist
      '("\\.sass\\'" . sass-mode)))

    #+END_SRC
*** SCSS-mode
    Major mode for SCSS files, together with Sass.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package scss-mode

       :config
       (add-to-list 'auto-mode-alist
      '("\\.scss\\'" . scss-mode)))
    #+END_SRC

*** Js2-mode
    A better default Javascript mode
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package js2-mode)

      ;; Set js2-mode as default mode for JS files
      (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))


      ;; Use Tern for completions. Nowadays it got better and I can configure
      ;; it further.
      (use-package company-tern)

      (defun js2-mode-tweaks ()
        ;; Use company-yas as main backend
        (set (make-local-variable 'company-backends) '(company-tern company-yasnippet company-etags))
        (tern-mode t)
        (company-mode t))

      (add-hook 'js2-mode-hook 'js2-mode-tweaks)

      ;; Set syntax highlight level
      (setq js2-highlight-level 3)
    #+END_SRC

*** PHP-mode
    PHP support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package php-mode)
    (add-hook 'php-mode-hook (lambda() (add-to-list 'company-backends 'company-php)))
    #+END_SRC
*** Enhanced-ruby-mode
    A better ruby-mode.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package enh-ruby-mode)

      ;; No magic comments, please.
      (setq enh-ruby-add-encoding-comment-on-save nil)
      (setq ruby-insert-encoding-magic-comment nil)

      ;; Set it as default mode for Ruby files
      (add-to-list 'auto-mode-alist
      '("\\(?:\\.rb\\|ru\\|rake\\|thor\\|jbuilder\\|gemspec\\|podspec\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'"
      . enh-ruby-mode))

      ;; Map evil's ]m and [m keys to a couple functions
      (evil-define-key 'normal enh-ruby-mode-map
      "[m" 'enh-ruby-beginning-of-defun
      "]m" 'enh-ruby-end-of-defun
      "[b" 'enh-ruby-beginning-of-block
      "]b" 'enh-ruby-end-of-block
      "[u" 'enh-ruby-up-sexp
      "[s" 'enh-ruby-backward-sexp
      "]s" 'enh-ruby-forward-sexp)
    #+END_SRC
*** Web Mode
    I use this for HTML files mostly, works good for PHP too.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package web-mode :ensure t
      :bind (:map web-mode-map
    ("C-<up>"    . web-mode-element-previous)
    ("C-<down>"  . web-mode-element-next)
    ("C-<left>"  . web-mode-element-beginning)
    ("C-<right>" . web-mode-tag-match)
    ("C-S-<up>"  . web-mode-element-parent)
    ("M-<up>"    . web-mode-element-content-select)
    ("C-k"       . web-mode-element-kill)
    ("M-RET"     . complete)))

      ;; File associations
      (add-to-list 'auto-mode-alist '("\\.phtml\\'"  . web-mode))
      (add-to-list 'auto-mode-alist '("\\.php\\'"    . web-mode))
      (add-to-list 'auto-mode-alist '("\\.erb\\'"    . web-mode))
      (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.html?\\'"  . web-mode))
      (add-to-list 'auto-mode-alist '("\\.vue?\\'"   . web-mode))

      ;; Engine associations
      (setq web-mode-engines-alist
      '(("php"    . "\\.phtml\\'")
      ("blade"  . "\\.blade\\.")))

      ;; Highlight tag when editing
      (setq web-mode-enable-current-element-highlight t)

    #+END_SRC
*** YAML-mode
    YAML support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yaml-mode :ensure t)
    #+END_SRC
*** CSV-mode
    CSV support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package csv-mode)
    #+END_SRC
** Minor Modes
*** JS-comint
    Open a REPL using Node.js in another buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package js-comint)

      ;; Call the REPL with C-c C-s in js2-mode
      (define-key js2-mode-map (kbd "C-c C-s") 'run-js)

      ;; Send last JS expression to REPL
      (define-key js2-mode-map (kbd "C-x C-e") 'js-send-last-sexp)
    #+END_SRC
*** Flycheck Inline
    Shows the error when leaving the point over the place where it occurs.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package flycheck-inline
        :config
        (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
    #+END_SRC
*** Ruby-extra-highlight
    Highlight function arguments in Ruby.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ruby-extra-highlight)
      (add-hook 'enh-ruby-mode-hook #'ruby-extra-highlight-mode)
    #+END_SRC
*** Ruby-electric
    Auto-close do-end blocks, as well as braces and parens.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ruby-electric
       :diminish ruby-electric-mode)
      (add-hook 'enh-ruby-mode-hook
           #'(lambda ()
               (setq autopair-dont-activate t) ;; for emacsen < 24
               (autopair-mode -1))             ;; for emacsen >= 24
               )
      (add-hook 'enh-ruby-mode-hook 'ruby-electric-mode)
    #+END_SRC
*** Alchemist
    Elixir helper package integration for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package alchemist :ensure t)
      ;; Activate it in Elixir mode
      (add-hook 'elixir-mode-hook 'alchemist-mode)
    #+END_SRC
*** Projectile
    Manage projects in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package projectile
       :init
       (setq projectile-keymap-prefix (kbd "C-c p")))
       ;; Enable it
       (add-hook 'after-init-hook #'projectile-global-mode)
    #+END_SRC
*** Autopair
    Automatically pair braces and quotes like in TextMate
    #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package autopair
      :init (autopair-global-mode))
    #+END_SRC
*** Emmet-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package emmet-mode)
    #+END_SRC
*** Highlight-numbers mode
    Sets font lock faces to numbers in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-numbers)
    (add-hook 'prog-mode-hook 'highlight-numbers-mode)
    #+END_SRC
*** Flyspell
    Used to check prose.
    I use Markdown to write stuff in English.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package flyspell
        :config
        (add-hook 'text-mode-hook 'turn-on-auto-fill)
        (add-hook 'gfm-mode-hook 'flyspell-mode)
        (add-hook 'markdown-mode-hook 'flyspell-mode)

        (add-hook 'git-commit-mode-hook 'flyspell-mode))
    #+END_SRC

*** Flycheck
    Syntax checker, replaces flymake
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package flycheck
     :config
     ;; turn on flychecking globally
     (add-hook 'after-init-hook #'global-flycheck-mode))
      ;; Disable rubylint on default for Ruby modes.
      ;; If you need it, you can enable it locally using C-u C-c ! v.
      (defun custom-disabled-ruby-checkers ()
       (add-to-list 'flycheck-disabled-checkers 'ruby-rubylint))
       (add-hook 'enh-ruby-mode-hook 'custom-disabled-ruby-checkers)
    #+END_SRC

*** Ruby Tools
    Goodies for Ruby programming modes.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ruby-tools)
    #+END_SRC
*** Helm
    Incremental completion and selection narrowing framework
    #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package helm)
     (require 'helm-config)
     (helm-mode 1)

     ;; Bind the keys I want:
     (global-set-key (kbd "M-y") 'helm-show-kill-ring)
     (global-set-key (kbd "M-x") 'helm-M-x)
     (global-set-key (kbd "¬ª") 'helm-M-x)
     (global-set-key (kbd "C-x C-f") 'helm-find-files)
     (global-set-key (kbd "C-x b") 'helm-buffers-list)

     ;; Enable fuzzy matching
     (setq helm-M-x-fuzzy-match t)
    #+END_SRC

*** Ace Window
    Switch between more than 3 windows (and act on them!) with ease.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ace-window
        :init
        ;; All you need to do is just give a keybinding to the main command.
        (global-set-key (kbd "M-o") 'ace-window))
    #+END_SRC

*** Company
**** Main Config
     *COMPlete ANYthing* inside Emacs.
     I switched to it because it works in GUI Emacs and auto-complete doesn't.
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package company)

       ;; Web-mode needs HTML and CSS completions.
       ;; JS is not satisfactory at this point IMO

       (defun web-mode-tweaks ()
       (require 'company-web-html)
       (set (make-local-variable 'company-backends) '(company-web-html company-css))
       (emmet-mode 1)
       (company-mode t))

       ;; Completion for Ruby mode
       (defun ruby-mode-tweaks ()
       (require 'company-robe)
       (set (make-local-variable 'company-backends) '(company-robe company-etags company-yasnippet)))

       ;; General text writing completion (uses dabbrev and filename completion)
       (defun human-language-mode-tweaks ()
       (set (make-local-variable 'company-backends) '(company-dabbrev company-capf company-files))
       (set (make-local-variable 'company-minimum-prefix-length) 2))

       ;; Add tweaks
       (add-hook 'enh-ruby-mode-hook 'ruby-mode-tweaks)

       ;; Human language writing hooks
       (add-hook 'org-mode-hook 'human-language-mode-tweaks)
       (add-hook 'markdown-mode-hook 'human-language-mode-tweaks)
       (add-hook 'git-commit-setup-hook 'human-language-mode-tweaks)

       ;; Autocompletion for Bootstrap/FontAwesome classes
       (use-package ac-html-bootstrap)

       ;; Web-mode completions
       (use-package company-web)

       ;; Company statistics package
       (use-package company-statistics)
       (company-statistics-mode)

       ;; Company with prescient.el offers better sorting of completion candidates.
       ;; I don't know if it clashes with company-statistics.
       (use-package company-prescient)

       ;; Activate it
       (company-prescient-mode)
     #+END_SRC
**** Front-ends
***** Company-box
      Show icons in Company tooltip and different backends.
      #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company-box
    :diminish company-box-mode
    :if window-system
    :hook (company-mode . company-box-mode))

    ;; Add alternate icon font
    (add-to-list 'load-path "~/.local/share/icons-in-terminal/")

    ;; Temporary fix
    (add-to-list 'load-path "~/.emacs.d/manual-packages/font-lock+/")
    (require 'font-lock+)
    ;; (require 'icons-in-terminal)

    (setq company-box-icons-unknown 'fa_question_circle)

    (setq company-box-icons-elisp
    '((fa_tag :face font-lock-function-name-face) ;; Function
    (fa_cog :face font-lock-variable-name-face) ;; Variable
    (fa_cube :face font-lock-constant-face) ;; Feature
    (md_color_lens :face font-lock-doc-face))) ;; Face

    (setq company-box-icons-yasnippet 'fa_bookmark)
      #+END_SRC
*** Keyfreq
    Shows most used commands in editing session.
    To see the data, run (keyfreq-show) with M-:
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package keyfreq)

    ;; Ignore arrow commands and self-insert-commands
    (setq keyfreq-excluded-commands
    '(self-insert-command
    org-self-insert-command
    weechat-self-insert-command
    abort-recursive-edit
    company-ignore
    forward-char
    backward-char
    previous-line
    next-line))

    ;; Activate it
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1)
    #+END_SRC
*** Diminish
    Free some space in the mode line removing superfluous mode indications.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package diminish :ensure t
     ;; These are loaded at startup, I prefer declaring everything here.
     :diminish flycheck-mode
     :diminish projectile-mode
     :diminish helm-mode
     :diminish company-mode
     :diminish undo-tree-mode
     :diminish auto-revert-mode
     :diminish auto-fill-function
     :diminish wakatime-mode
     :diminish abbrev-mode
     :diminish autopair-mode)
      ;; These are loaded in other moments
      (eval-after-load "editorconfig" '(diminish 'editorconfig-mode))
      (eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
    #+END_SRC
*** Ace Jump
    Allows you to move anywhere in the visible portion of the buffer
    using 2 keystrokes.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ace-jump-mode
        :bind ("C-x j" . ace-jump-mode))
    #+END_SRC

*** Editorconfig
    Helps developers define and maintain consistent coding styles
    between different editors and IDEs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package editorconfig
       :ensure t
       :config
       (editorconfig-mode 1))
    #+END_SRC
*** Nyan-mode
    Put a Nyan Cat in your mode line! :3
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package nyan-mode)
    (nyan-mode 1)
    #+END_SRC
*** Mode Icons
    Indicate modes in the mode line using icons
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package mode-icons
       :init
       (mode-icons-mode))
    #+END_SRC
*** Emojify
    Add emoji support for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package emojify)
    #+END_SRC
** Utilities
*** Beacon
    Blinks when you move the cursor over long distances.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package beacon
        :config
        (beacon-mode 1)
        (setq beacon-blink-when-point-moves-vertically 10))
    #+END_SRC
*** Eyebrowse
    Simple window configuration management in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
      ;; The custom prefix needs to be evaluated _before_ loading eyebrowse. Go figure.
      (setq eyebrowse-keymap-prefix "")

      (use-package eyebrowse
        :diminish eyebrowse-mode
        :config
        (eyebrowse-mode))
    #+END_SRC
*** Prettier.js
    Prettier.js integration for Emacs.
    I want to run this thing when saving .js and web-related files.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package prettier-js
        :hook ((js2-mode sass-mode scss-mode css-mode) . 'prettier-js-mode))

      (setq prettier-js-allowed-modes '(js2-mode sass-mode css-mode scss-mode))

      (defun toggle-prettier-js-save-hook ()
        "Toggles Prettier.js hook when you're working with a mode that supports it. Removes the hook otherwise."
        (if (member major-mode prettier-js-allowed-modes)
        (add-hook 'before-save-hook 'prettier-js)
        (remove-hook 'before-save-hook 'prettier-js)))
      (add-hook 'change-major-mode-hook 'toggle-prettier-js-save-hook)
    #+END_SRC
*** Origami-mode
    Code folding in Emacs. You can use this with Evil by pressing z a
    in normal-mode.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package origami)
      ;; Activate it
      (global-origami-mode)
    #+END_SRC
*** Slack Client
    Run a Slack client inside Emacs. Surprisingly useful at work!
    Credits for the customizations below: [[http://endlessparentheses.com/mold-slack-entirely-to-your-liking-with-emacs.html][Endless Parentheses]]
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package slack
        :commands (slack-start)
        :init
        (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
        (setq slack-prefer-current-team t)
        :config
        ;; Get my teams.
        (load "~/.slack-teams.el")

        ;; Set abbrevs from org-mode
        (abbrev-table-put slack-mode-abbrev-table
                          :parents (list org-mode-abbrev-table))

      (abbrev-table-put slack-thread-message-buffer-mode-abbrev-table
                          :parents (list org-mode-abbrev-table))

      (abbrev-table-put slack-message-compose-buffer-mode-abbrev-table
                          :parents (list org-mode-abbrev-table))

        ;; Expand abbrevs when pressing Enter in slack-modes (it's derived from lui-mode)
        (advice-add #'lui-send-input :before
                    (lambda (&rest _)
                      (ignore-errors (expand-abbrev))))

        (evil-define-key 'normal slack-info-mode-map
          ",u" 'slack-room-update-messages)
        (evil-define-key 'normal slack-mode-map
          "Q" 'bury-buffer
          ",c" 'slack-buffer-kill
          ",ra" 'slack-message-add-reaction
          ",rr" 'slack-message-remove-reaction
          ",rs" 'slack-message-show-reaction-users
          ",pl" 'slack-room-pins-list
          ",pa" 'slack-message-pins-add
          ",pr" 'slack-message-pins-remove
          ",mm" 'slack-message-write-another-buffer
          ",me" 'slack-message-edit
          ",md" 'slack-message-delete
          ",u" 'slack-room-update-messages
          ",2" 'slack-message-embed-mention
          ",3" 'slack-message-embed-channel
          "\C-n" 'slack-buffer-goto-next-message
          "\C-p" 'slack-buffer-goto-prev-message)
        (evil-define-key 'normal slack-edit-message-mode-map
          ",k" 'slack-message-cancel-edit
          ",s" 'slack-message-send-from-buffer
          ",2" 'slack-message-embed-mention
          ",3" 'slack-message-embed-channel))
    #+END_SRC
**** Notifications customization
     #+BEGIN_SRC emacs-lisp :tangle yes
       ;; Channels
       (setq slack-message-notification-title-format-function
             (lambda (_team room threadp)
               (concat (if threadp "Thread in #%s") room)))

       (defun endless/-cleanup-room-name (room-name)
         "Make group-chat names a bit more human-readable."
         (replace-regexp-in-string
          "--" " "
          (replace-regexp-in-string "#mpdm-" "" room-name)))

       ;;; Private messages and group chats
       (setq slack-message-im-notification-title-format-function
             (lambda (_team room threadp)
               (concat (if threadp "Thread in %s")
                       (endless/-cleanup-room-name room))))

       ;; Custom notifications
       (load "~/.slack-custom-notifications.el")
     #+END_SRC
**** Autocompletion
     #+BEGIN_SRC emacs-lisp :tangle yes
       (defun slack-mode-tweaks ()
         ;; Company-slack adds username completion.
              (set (make-local-variable 'company-backends) '(company-dabbrev company-slack-backend company-files))
              ;; Start earlier than in other modes.
              (set (make-local-variable 'company-minimum-prefix-length) 2))

       (add-hook 'slack-mode-hook 'slack-mode-tweaks)
       (add-hook 'slack-message-compose-buffer-mode-hook 'slack-mode-tweaks)
       (add-hook 'slack-message-edit-buffer-mode-hook 'slack-mode-tweaks)
       (add-hook 'slack-thread-message-buffer-mode-hook 'slack-mode-tweaks)
     #+END_SRC
*** Golden Ratio Mode
    Splits windows using the [[https://en.wikipedia.org/wiki/Golden_ratio][Golden Ratio]].
    This makes the focused window a bit larger than usual and the
    smaller ones are easier to read. It makes the multi-window
    experience more pleasing to the eye. Yeah, nature!
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package golden-ratio
       :diminish golden-ratio-mode)

      ;; Get golden-ratio to work with ace-window
      (setq golden-ratio-extra-commands
             (append golden-ratio-extra-commands '(magit-status ace-window aw-flip-window)))
      (golden-ratio-mode 1)
    #+END_SRC

*** Helm-Ag
    Silver Searcher support for Helm.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package helm-ag)
    #+END_SRC
*** Docker
    A Docker command wrapper for Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package docker)

      ;; Extra stuff Docker needs on Mac OS X
      (when (eq system-type 'darwin)
          (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
           (setq exec-path (append exec-path '("/usr/local/bin"))))
    #+END_SRC

*** Projectile Rails
    Rails utilities for Projectile-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package projectile-rails)
    (projectile-rails-global-mode)

    ;; Change the prefix

    #+END_SRC
*** Bundler
    Interact with Bundler from Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package bundler)
    #+END_SRC
*** Wakatime
    Time tracking in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package wakatime-mode
        :diminish wakatime-mode)
      ;; Enable it
      (global-wakatime-mode)
    #+END_SRC
*** Evil-numbers
    Increment and decrement numbers like in Vim.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil-numbers
    :bind ("C-c <up>" . evil-numbers/inc-at-pt)
      ("C-c <down>" . evil-numbers/dec-at-pt))
    #+END_SRC

*** Evil's syntax text object
    Adds a text object defined by same syntax highlight, you can
    operate on it as with any other text objects.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil-textobj-syntax)
    #+END_SRC
*** Diff-Highlight
    Highlights the changed content in buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package diff-hl
       :ensure
       :config
       ;; ((defun hl-diff-tweaks()
       ;;   (diff-hl-mode t)
       ;;   (diff-hl-flydiff-mode t))
       ;;   (add-hook 'prog-mode-hook 'hl-diff-tweaks))
       )
    #+END_SRC
*** Evil-Matchit
    Adds more matching objects for the % operator in evil, such as
    def-end in Ruby/Python and HTML tags.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-matchit
    :ensure t
    :init
    (global-evil-matchit-mode 1))
    #+END_SRC
*** Evil-Snipe
    Highlights line search and allows you to use the s key in normal
    mode to 'snipe' for the char you want, as well as upgrading the
    standard line char search (f and t)
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-snipe
       :init
       ;; I just want override-mode, I use S for substituting an entire line
       ;; (evil-snipe-mode +1)
       (evil-snipe-override-mode +1)
       ;; Make search case insensitive
       (setq evil-snipe-smart-case t)
       ;; Currently this has a conflict with Magit
       (add-hook 'magit-mode-hook 'turn-off-evil-snipe-override-mode))
    #+END_SRC
*** Cheat.sh client
    Access cheat.sh from Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package cheat-sh :ensure t)
    #+END_SRC
*** Writeroom Mode
    Dims the modeline, perfect for focusing on writing text/code
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package writeroom-mode :ensure t)
      ;; Activate it manually, it doesn't play well with Moe modeline globally
    #+END_SRC
*** Restart Emacs
    Restart Emacs from within Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package restart-emacs)
    #+END_SRC
*** ReST Client
    Use it like Postman, but inside Emacs!
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package restclient)
    #+END_SRC
*** Helm-projectile
    Browse through Projectile commands using Helm.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package helm-projectile)
    ;; Activate it.
    (helm-projectile-on)
    #+END_SRC
*** Rainbow Delimiters
    Highlight parentheses, brackets and braces according to their
    depth.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package rainbow-delimiters)
    ;; Add this to prog-mode
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    #+END_SRC
*** Web-beautify
    Format HTML/CSS and JS code with js-beautify
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package web-beautify)

      ;; Format web-mode buffer automatically on save
      (defun format-web-mode-buffer-on-save ()
        ""
        (if (eq major-mode 'web-mode)
            (add-hook 'before-save-hook 'web-beautify-html)
          (remove-hook 'before-save-hook 'web-beautify-html))
        )

      (add-hook 'change-major-mode-hook 'format-web-mode-buffer-on-save)
    #+END_SRC
*** Git Gutter
    Shows (and enables you to navigate between) parts of the code
    which where changed comparing to the current revision in a
    version-controlled project.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package git-gutter
        :when window-system
        :defer t
        :hook ((prog-mode text-mode) . 'git-gutter-mode)
        :diminish ""
        :config
        (use-package git-gutter-fringe
          :ensure t
          :init
          (require 'git-gutter-fringe)
          (when (fboundp 'define-fringe-bitmap)
            (define-fringe-bitmap 'git-gutter-fr:added
              [224 224 224 224 224 224 224 224 224 224 224 224 224
                   224 224 224 224 224 224 224 224 224 224 224 224]
              nil nil 'center)
            (define-fringe-bitmap 'git-gutter-fr:modified
              [224 224 224 224 224 224 224 224 224 224 224 224 224
                   224 224 224 224 224 224 224 224 224 224 224 224]
              nil nil 'center)
            (define-fringe-bitmap 'git-gutter-fr:deleted
              [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
              nil nil 'center)))
        ;; Adding evil-mode bindings
        (define-key evil-normal-state-map (kbd "g h") 'git-gutter:previous-hunk)
        (define-key evil-normal-state-map (kbd "g H") 'git-gutter:next-hunk)
        (define-key evil-normal-state-map (kbd "g @") 'git-gutter:popup-hunk)
        )
    #+END_SRC

*** Magit
    How to win at Git from Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package magit)
    #+END_SRC
*** Eshell configurations
    #+BEGIN_SRC emacs-lisp :tangle yes
    ;; Eshell extras
    (use-package eshell-prompt-extras)

    ;; More configs
    (with-eval-after-load "esh-opt"
    (autoload 'epe-theme-lambda "eshell-prompt-extras")
    (setq eshell-highlight-prompt t
    eshell-prompt-function 'epe-theme-dakrone))
    #+END_SRC
*** Yasnippets
    It originally came with company-mode, it's handy to write faster
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yasnippet-snippets)
    (use-package yasnippet-classic-snippets)
    #+END_SRC
*** Circadian
    Theme changer for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package circadian
      :ensure t
      :config
      (setq circadian-themes '((:sunrise . cosmos)
                               (:sunset  . jazz)))

      (circadian-setup))
    #+END_SRC
*** Robe
    Ruby's autocomplete, navigation and project tools, especially for
    Rails.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package robe)
      (add-hook 'enh-ruby-mode-hook 'robe-mode)

      ;; Integrate with Company
      (defun ruby-completion-tweaks ()
    ;; Robe-mode must be active for this to work.
      (set (make-local-variable 'company-backends) '(company-robe company-yasnippet company-etags company-capf))
      (company-mode t))
      (add-hook 'enh-ruby-mode-hook 'ruby-completion-tweaks)
    #+END_SRC
*** RVM
    Ruby Version Manager. Akin to python's virtualenv.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package rvm)

      (rvm-use-default)
      (rvm-activate-corresponding-ruby)
      ;; Activate RVM for inf-ruby sessions.
      (defadvice inf-ruby-console-auto (before activate-rvm-for-robe activate)
      (rvm-activate-corresponding-ruby))
    #+END_SRC
*** Anzu
    Show search result count in the mode line.
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil-anzu)
    (global-anzu-mode)
    #+END_SRC
*** Vagrant TRAMP
    Open files in running Vagrant box using TRAMP
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package vagrant-tramp)
    #+END_SRC
*** Carbon-now.sh
    Share the region in carbon-now.sh
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package carbon-now-sh)
    #+END_SRC
* Themes
  Remember to _defer_ the loading of the theme packages, otherwise the
  faces might get mixed up and look ugly.
** Jazz
   A warm theme with dark colors.
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package jazz-theme :ensure t
   :defer t)
   #+END_SRC
** Abyss
   Dark contrast theme
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package abyss-theme :ensure :defer t)
   #+END_SRC
** Doom Themes
   A collection of themes from the Doom package
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package doom-themes :ensure :defer t)
   #+END_SRC
** Twilight Bright
   A port of the theme from TextMate.
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package twilight-bright-theme :defer t)
   #+END_SRC
** Organic Green
   A light theme with a light-green background, looks real nice!
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package organic-green-theme :defer t)
   #+END_SRC
** Flat UI
   Flat colors which blend nicely.
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package flatui-theme :defer t)
   #+END_SRC
** Hemisu
   I like the dark theme from here.
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package hemisu-theme :defer t)
   #+END_SRC
* Graphical
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; Set font in graphical mode
    (when (display-graphic-p)
        ;; Use Fantasque Sans Mono when available
        (if (member "Fantasque Sans Mono" (font-family-list))
        (set-face-attribute (quote default) nil :font "Fantasque Sans Mono" :height 120)
        '(set-face-attribute (quote default) nil :font "Ubuntu Mono" :height 120))

        ;; Remove menu and scroll bars in graphical mode
        (menu-bar-mode 0)
        (tool-bar-mode 0)
        (scroll-bar-mode 0)
        ;; Enable emoji images
        (global-emojify-mode)
        ;; Enable them in the mode line as well.
        (global-emojify-mode-line-mode)
        ;; Maximize frame on startup
        (toggle-frame-maximized)
        ;; Space lines and bask in the gloriousness of graphical mode.
        ;; 0.4 feels better for prose, and 0.2 is fine for code.
        (add-hook 'prog-mode-hook (lambda () (setq line-spacing 0.2)))
        (add-hook 'comint-mode-hook (lambda () (setq line-spacing 0.2)))
        (add-hook 'text-mode-hook (lambda () (setq line-spacing 0.4))))
  #+END_SRC
* Keybindings
  #+BEGIN_SRC emacs-lisp :tangle yes
    ;; Remapping the help hotkey so it doesn't clash with Unix backspace.
    ;; Whenever you want to call help you can use M-x help as well. F1
    ;; works too.
    ;; (define-key key-translation-map [?\C-h] [?\C-?])

    ;; Use the menu key for helm-m-x
    (global-set-key [menu] (quote helm-M-x))

    ;; Unfill region
    (define-key global-map "\C-\M-q" 'unfill-region)

    ;; Mapping AltGr-d to delete-other-windows,
    ;; Another symbol I don't use often.
    (global-set-key [240] (quote delete-other-windows))

    ;; Access buffers with Alt-Gr b
    (global-set-key [8221] (quote helm-buffers-list))

    ;; Map the Home and End keys to go to the beginning and end of the buffer
    (global-set-key [home] (quote beginning-of-buffer))
    (global-set-key [end] (quote end-of-buffer))

    ;; Move to beginning of line or indentation
    (defun back-to-indentation-or-beginning () (interactive)
      (if (= (point) (progn (back-to-indentation) (point)))
      (beginning-of-line)))

    ;; We need this to get back to the beginning of the indentation or first word of the line.
    (global-set-key (kbd "C-a") (quote back-to-indentation-or-beginning))

    ;; Quick theme changer
    (global-set-key (kbd "M-`") (quote customize-themes))

    ;; Hippie-Expand: change key to M-SPC; Replace dabbrev-expand
    (global-set-key "\M- " 'hippie-expand)
    (global-set-key "\M-/" 'hippie-expand)

    ;; Eshell configuration
    (defun eshell-tweaks ()
        "Tweaks for the Emacs shell"
        (evil-set-initial-state 'eshell-mode 'emacs))
    (add-hook 'eshell-mode-hook 'eshell-tweaks)
    (add-hook 'term-mode-hook 'eshell-tweaks)

    ;; Evaluate buffer using SPC SPC, depending on major mode.
    (evil-leader/set-key-for-mode 'emacs-lisp-mode "SPC" 'eval-buffer)
    (evil-leader/set-key-for-mode 'enh-ruby-mode "SPC" 'ruby-send-buffer-and-go)
    (evil-leader/set-key-for-mode 'python-mode "SPC" 'python-shell-send-buffer)
    (evil-leader/set-key-for-mode 'js2-mode "SPC" 'js-comint-send-buffer)
  #+END_SRC

* Web-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun web-mode-keybindings ()
        "Define mode-specific keybindings like this."
        (local-set-key (kbd "C-c C-v") 'browse-url-of-buffer)
        (local-set-key (kbd "C-c /") 'sgml-close-tag))

    ;; Add company backends when loading web-mode.
    (defun web-mode-company-load-backends ()
        (company-web-bootstrap+)
        (company-web-fa+))

    (add-hook 'web-mode-hook 'web-mode-keybindings)
    (add-hook 'web-mode-hook 'web-mode-company-load-backends)

    ;; Use tidy to check HTML buffers with web-mode.
    (eval-after-load 'flycheck
       '(flycheck-add-mode 'html-tidy 'web-mode))
  #+END_SRC
* Org-mode
** Main configuration
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; We don't need Flycheck in org-mode buffers. Usually.
     (add-hook 'org-mode-hook '(lambda() (flycheck-mode 0)))

     ;; Change the end of collapsed headings to an arrow.
     (setq org-ellipsis "‚§µ")

     ;; Keep agenda file list in a single file so I can publish my config.
     ;; DO NOT use C-c [ or C-c ] to add/remove files to the agenda otherwise
     ;; Emacs will write the var to init.el
     (setq org-agenda-files "~/file-bouncer/org-agenda-file-list.org")

     ;; When TODOs are ordered, enforce task dependencies
     (setq org-enforce-todo-dependencies t)

     ;; Don't split my lines, thx.
     (setq org-M-RET-may-split-line nil)

     ;; Truncate long task names
     (setq org-clock-heading-function
           (lambda ()
             (let ((str (nth 4 (org-heading-components))))
               (concat (truncate-string-to-width str 27) "...")
               )))

     ;; Organize the bindings
     ;; Use helm-org-in-buffer-headings instead of imenu; it has more actions and
     ;; shows the exact heading you want.
     (evil-leader/set-key-for-mode 'org-mode "h i" 'helm-org-in-buffer-headings)

     ;; Open subheading with C-c RET and invert with M-RET
     (define-key org-mode-map (kbd "C-c RET") 'org-ctrl-c-ret)
     (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)

     ;; Use C-RET to complete words in Org-mode
     (define-key org-mode-map (kbd "C-RET") 'complete)

     ;; Always respect the content of a heading when creating todos!
     (define-key org-mode-map (kbd "<M-S-return>") 'org-insert-todo-heading-respect-content)

     ;; Map C-S-enter to org-insert-todo-subheading
     (define-key org-mode-map (kbd "<C-S-return>") 'org-insert-todo-subheading)

     ;; Use Emacs mode in Org-capture buffers and notes buffer
     (add-hook 'org-capture-mode-hook 'evil-emacs-state)

     ;; Idiot-proofing my configs
     (define-key org-mode-map (kbd "C-c ]") nil)
     (define-key org-mode-map (kbd "C-c [") nil)

     ;; Simplify org-todo in org-mode buffers with <leader> t
     (evil-leader/set-key-for-mode 'org-mode "t" 'org-todo)

     ;; Log when a task was done and when it was rescheduled.
     (setq org-log-done 'time)
     (setq org-log-reschedule 'time)

     ;; Don't write inside invisible area when collapsing headings!
     (setq org-catch-invisible-edits 'error)
   #+END_SRC
** Auto-mark TODO entries as DONE
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; see http://thread.gmane.org/gmane.emacs.orgmode/42715
     (eval-after-load 'org-list
       '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

     ;; Mark a parent TODO entry as DONE when its checkboxes are all ticked
     (defun ndk/checkbox-list-complete ()
       (save-excursion
         (org-back-to-heading t)
         (let ((beg (point)) end)
           (end-of-line)
           (setq end (point))
           (goto-char beg)
           (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
               (if (match-end 1)
                   (if (equal (match-string 1) "100%")
                       ;; all done - do the state change
                       (org-todo 'done)
                     (org-todo 'todo))
                 (if (and (> (match-end 2) (match-beginning 2))
                          (equal (match-string 2) (match-string 3)))
                     (org-todo 'done)
                   (org-todo 'todo)))))))
   #+END_SRC
** Capture templates
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; Load them from a separate file.
     (load "~/.org-capture-templates.el")
   #+END_SRC
** Org-bullets
   Change org-mode's *s to UTF-8 chars
   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org-bullets
      :init
      (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1))))
   #+END_SRC
** Org-babel
*** Elixir
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ob-elixir)
    #+END_SRC
*** Emacs' restclient-mode
    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ob-restclient)
    #+END_SRC

*** Load languages
    #+BEGIN_SRC emacs-lisp :tangle yes
     (org-babel-do-load-languages
     'org-babel-load-languages
     '(
     ;; (sh . t)
    (python . t)
    (ruby . t)
    (elixir . t)
    (plantuml . t)
    (dot . t)
     ))
    #+END_SRC

** Org-pomodoro
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-pomodoro
       :bind ("C-x p" . org-pomodoro))

     ;; Display notification when a pomodoro is completed
     (defun pomodoro-display-notification (title body)
         (if (eq system-type 'darwin)
           (ns-do-applescript (format "display notification \"%s\" with title \"%s\" sound name \"Glass\"" body title))
           (notifications-notify :title title
                 :body body
                 :app-icon "~/my-dotfiles/.emacs.d/org-pomodoro/tomato.png")))

     ;; Use mpv in OS X
     (when (eq system-type 'darwin)
         (setq org-pomodoro-audio-player "/usr/local/bin/mpv"))

     (add-hook 'org-pomodoro-started-hook (lambda() (pomodoro-display-notification "Pomodoro started!" "Concentrate on your task!")))
     (add-hook 'org-pomodoro-finished-hook (lambda() (pomodoro-display-notification "Pomodoro finished" "Time to take a break!")))
   #+END_SRC

** Org-notify
   Desktop notifications for Org-mode.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-alert)
     ;; Use native notifications in Mac.
     (if (eq system-type 'darwin)
       (setq alert-default-style 'osx-notifier)
       ;; Use libnotify to display the alerts in Linux
       (setq alert-default-style 'libnotify))
   #+END_SRC
** Evil-org
   Evil-mode keybindings for org-mode.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-org
       :diminish evil-org-mode
       :hook (org-mode . evil-org-mode)
       )
   #+END_SRC
* Variables
  #+BEGIN_SRC emacs-lisp :tangle yes
  ;; Set Org mode as default mode for new buffers:
  (setq-default major-mode 'org-mode)

  ;; Enable auto-fill mode by default
  (auto-fill-mode 1)

  ;; Set default fill to 119
  (set-fill-column 119)

  ;; Change tab width and change tabs to spaces
  (setq-default tab-width 4)
  (setq-default indent-tabs-mode nil)

  ;; Making Emacs auto-indent
  (define-key global-map (kbd "RET") 'newline-and-indent)

  ;; Shows trailing whitespace, if any:
  (setq-default show-trailing-whitespace t)
  ;; Don't do that for terminal mode!
  (add-hook 'multi-term-mode-hook (setq-default show-trailing-whitespace nil))

  (defun css-mode-tweaks()
    (set (make-local-variable 'company-backends) '(company-css company-yasnippet company-etags))
    (emmet-mode 1)
    (rainbow-mode 1))

  ;; Emmet-mode: activate for html-mode, sgml-mode,
  ;; css-mode, web-mode and sass-mode
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'sass-mode-hook 'css-mode-tweaks)
  (add-hook 'web-mode-hook 'emmet-mode)

  ;; By the way, it's nice to add rainbow-mode for CSS
  (add-hook 'css-mode-hook 'css-mode-tweaks)

  ;; Python: use python3 as default shell interpreter
  (setq python-shell-interpreter "python3")

  #+END_SRC
* Custom functions
** Main
   #+BEGIN_SRC emacs-lisp :tangle yes
   (require 'rails-docker-utils)
   #+END_SRC
** Kill relative file name
   I use that to work with rspec. Projectile has the ~C-c C-k~
   keybinding to kill the file name in a Helm session, when I realize
   I need to get that, I'm in the buffer already.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun auralcat-kill-relative-file-name ()
       "Add the file name relative to the project's root to the kill ring."
       (interactive)
       (let ((relative-file-name (magit-file-relative-name buffer-file-name)))
         (kill-new relative-file-name)
         (message "Current buffer's relative file name copied to kill ring: %s" relative-file-name)))
   #+END_SRC
** Calculate leap year
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun is-leap-year (year)
       "Checks if the given YEAR is a leap year"
       (interactive "P")
       (or
        (and (not (eq (% year 100) 0))
             (eq (% year 4) 0))
        (eq (% year 400) 0))
       )

   #+END_SRC
** Quick org-todo without leaving current buffer
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-org-remote-todo ()
       "Changes the TODO state of the currently clocked heading remotely."
       (interactive)
       (org-clock-goto)
       (org-todo)
       (mode-line-other-buffer)
       )
   #+END_SRC
* Twittering mode
  Use Twitter from within Emacs!
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package twittering-mode
    :bind (:map twittering-mode-map
      ("C-c r" . my-twittering-mode-reply-to-user)
      ("C-c f" . twittering-favorite)
      ("C-c n" . twittering-native-retweet)))

    ;; WIP, needs A LOT of remapping
    ;; Use evil-mode to navigate twittering's frame
    ;; (evil-set-initial-state 'twittering-mode 'emacs)

    ;; Adjust update interval in seconds. It's timeR, not time!
    (setq twittering-timer-interval 3600)

    ;; Display icons (if applicable)
    (setq twittering-icon-mode t)

    ;; Use a master password so you don't have to ask for authentication every time
    (setq twittering-use-master-password t)
  #+END_SRC

* Mode Line
** Telephone Line
   Prettier mode line.
   *To ensure that nothing gets in the way of loading it, leave this*
   *last in your config file*
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package telephone-line :ensure t)

     ;; Mac workaround to render separators correctly.
     (when (eq system-type 'darwin)
       (setq ns-use-srgb-colorspace nil))

     ;; I just want a different indicator in my mode line.
     (telephone-line-defsegment* auralcat-telephone-line-buffer-modified-segment ()
       (if (buffer-modified-p)
           (telephone-line-raw "üíæ")
         (telephone-line-raw "üëç")))

     ;; Custom VC segment
     (telephone-line-defsegment* auralcat-vc-segment ()
       (concat (truncate-string-to-width (telephone-line-raw vc-mode t) 17) "...")
       )

     ;; CI build status indicator.
     (defun auralcat-print-ci-status ()
       "Return the CI status, if any."
       (let ((result (projectile-with-default-dir (projectile-ensure-project (projectile-project-root))
                       (shell-command-to-string "cat .test-result"))))
         (unless (or (string-equal (s-trim result) "null") (s-blank? result))
           (if (string-equal (s-trim result) "passed")
               (telephone-line-raw "üéâ" t)
             (telephone-line-raw "üí•" t)))
         )
       )

     (telephone-line-defsegment* auralcat-ci-build-status-segment ()
       "Indicates the build status for the current branch in the project."
       (if (and (projectile-project-p)
                (file-exists-p (projectile-with-default-dir (projectile-ensure-project (projectile-project-root))
                                 (expand-file-name ".test-result"))))
           (auralcat-print-ci-status)
         )
       )

     ;; Set separator styles
     (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
           telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
           telephone-line-primary-right-separator 'telephone-line-cubed-right
           telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
     ;; Configure the segments
     ;; Left hand side
     (setq telephone-line-lhs
           '((evil   . (telephone-line-evil-tag-segment))
             (accent . (auralcat-telephone-line-buffer-modified-segment
                        auralcat-vc-segment
                        telephone-line-projectile-segment
                        telephone-line-buffer-name-segment))
             (evil   . (telephone-line-airline-position-segment))
             (accent . (telephone-line-major-mode-segment auralcat-ci-build-status-segment))
             (nil    . (telephone-line-simple-minor-mode-segment
                        telephone-line-flycheck-segment
                        telephone-line-nyan-segment))))
     ;; Right hand side
     (setq telephone-line-rhs
           '((nil    . (telephone-line-misc-info-segment))
             (accent . nil)))

     (setq telephone-line-height 24
           telephone-line-evil-use-short-tag t)

     ;; Call the mode last!
     (telephone-line-mode t)

   #+END_SRC
* Diary
** Last day of month
   #+BEGIN_SRC emacs-lisp :tangle yes
        ;;; ORG-MODE:  * My Task
     ;              SCHEDULED: <%%(diary-last-day-of-month date)>
     ;;; DIARY:  %%(diary-last-day-of-month date) Last Day of the Month
     ;;; See also:  (setq org-agenda-include-diary t)
     ;;; (diary-last-day-of-month '(2 28 2017))
     (defun diary-last-day-of-month (date)
       "Return `t` if DATE is the last day of the month."
       (let* ((day (calendar-extract-day date))
              (month (calendar-extract-month date))
              (year (calendar-extract-year date))
              (last-day-of-month
               (calendar-last-day-of-month month year)))
         (= day last-day-of-month)))

     (defun diary-first-weekday-of-month (date)
       (let* ((day (calendar-extract-day date))
              (month (calendar-extract-month date))
              (year (calendar-extract-year date))
              (first-day-date (list month 1 year))
              (first-absolute-day-weekday (calendar-day-of-week first-day-date)))

         (or
          ;; When the first day is Sunday, it's day 2.
          (and (eq first-absolute-day-weekday 0)
               (eq day 2))

          ;; When the first day is Saturday, it's day 3.
          (and (eq first-absolute-day-weekday 6)
               (eq day 3))

          ;; Else, it's day 1 and a weekday.
          (and (memq (calendar-day-of-week date) '(1 2 3 4 5))
               (eq day 1))
          )
          ))

     (defun diary-last-weekday-of-month (date)
       (let* ((day-of-week (calendar-day-of-week date))
              (month (calendar-extract-month date))
              (year (calendar-extract-year date))
              (last-month-day (calendar-last-day-of-month month year))
              (month-day (cadr date)))

         (or
          ;; it's the last day of the month & it is a weekday
          (and (eq month-day last-month-day)
               (memq day-of-week '(1 2 3 4 5)))

          ;; it's a friday, and it's the last-but-one or last-but-two day
          ;; of the month
          (and (eq day-of-week 5)
               (or (eq month-day (1- last-month-day))
                   (eq month-day (1- (1- last-month-day))))))))

     (defun diary-first-working-day-of-month (date)
       "Returns `t` if DATE is the first working day of the month.
        This is defined as the first weekday of the month which is not a holiday."
         (let* ((day (calendar-extract-day date))
              (month (calendar-extract-month date)))
           (if
             ;; If it's May or Jan, check if day 2 is a weekday.
               (and (or (= month 5) (= month 1)))
               (and (= day 2) (memq (calendar-day-of-week date) '(1 2 3 4 5)))
             ;; Else, check if it's the first weekday of the month.
             (diary-first-weekday-of-month date))))
   #+END_SRC
