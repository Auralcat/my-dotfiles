-*- mode: org-english-*-
#+TITLE: Emacs configuration file
#+AUTHOR: Auralcat
#+DATE: 2017:05:17
#+STARTUP: overview

* Environment Customizations
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Take out unused stuff.
(setopt tool-bar-mode nil
      tooltip-mode nil)

;; I don't need the startup screen either.
;; Drop me straight into the scratch buffer.
(setopt inhibit-startup-screen t)

;; Remove the menu bar in terminal mode
(when (not (display-graphic-p))
  (menu-bar-mode -1))

;; Display things faster in the GUI. You might have some weird issues if you
;; do some aggressive scrolling in big files though.
(setopt redisplay-dont-pause t)

;; Sentences end with single spaces for me.
(setopt sentence-end-double-space nil)

;; Set locale to Brazilian Portuguese
(set-locale-environment "pt_BR.UTF-8")

;; Change window title
(setopt frame-title-format (format "%s %s - %s" (nth 1 (split-string (emacs-version)))
       (nth 2 (split-string (emacs-version)))
       (system-name)))

;; Add frame margins. This makes things more pleasant to read.
(setopt default-frame-alist '((internal-border-width . 20)))

;; A small performance improvement
(setopt redisplay-dont-pause t)

;; Since I work only with left-to-right languages, we can set it like this.
(setopt bidi-paragraph-direction 'left-to-right)

;; I don't like lockfiles
(setopt create-lockfiles nil)

;; Starts the Emacs server for emacsclient only if it's not started already
(load "server")
(unless (server-running-p) (server-start))

;; Store all backups in a specific folder:
(setopt backup-directory-alist `(("." . "~/file-bouncer/emacs-backups")))

;; Manual themes load path
(add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-themes/")

;; Manual Elisp scripts load path
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/elisp-custom")
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/manual-packages/")

;; Backup files by copying them
(setopt backup-by-copying t)

;; I'm too lazy to type "yes" or "no"
;; And I'm also too lazy to press y.
(defconst y-or-n-p-ret-yes-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map y-or-n-p-map)
    (define-key map [return] 'act)
    map)
  "A keymap for y-or-n-p with RET meaning \"yes\".")

(fset 'yes-or-no-p 'y-or-n-p)

;; Clean whitespace before saving a file
(add-hook 'before-save-hook 'whitespace-cleanup)

;; When making executable scripts, this function can make the new file
;; executable for you automatically.
;; You'll still need to include the shebang in the start of the file though.
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)

;; Disable it for outline-mode derivatives like Markdown and Org.
(add-hook 'text-mode-hook #'(lambda () (auto-save-visited-mode 0)))

;; Allow only one theme at a time
(setopt custom-theme-allow-multiple-selections nil)

;; Easier mark cycling, both local and global
(setopt set-mark-command-repeat-pop t)

;; Replace the built-in buffer menu with ibuffer
(global-set-key [24 2] (quote ibuffer))

;; Prevent the scratch buffer from being killed
(with-current-buffer "*scratch*"
  (emacs-lock-mode 'kill))

;; Enable auto-revert-mode
(global-auto-revert-mode t)



;; Use Bash as default shell interpreter
(setopt org-babel-sh-command "/bin/bash")
;; Get Emacs to understand your aliases
;; (setopt shell-file-name "bash")
;; For reference, this is the default value:
;; (setopt shell-command-switch "-c")
;; (setopt shell-command-switch "-ic")

;; Save last edited place in files
(require 'saveplace)
(setq-default save-place t)

;; I need a bigger kill ring.
(setopt kill-ring-max 180)

;; Use recentf-mode
(recentf-mode)
(setopt recentf-max-menu-items 100)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
  #+END_SRC
** Garbage collection tweaks
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar file-name-handler-alist-old file-name-handler-alist)

;; https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-12/msg01088.html
;; Long-story short, use select-active-regions 'only to make visual selection faster.
(setq-default gc-cons-threshold (* 100 1024 1024)
      select-active-regions 'only
      file-name-handler-alist nil
      gc-cons-percentage 0.6
      auto-window-vscroll nil
      ;; Improve LSP performance
      read-process-output-max (* 1024 1024)
      message-log-max 16384)

(add-hook 'after-init-hook
      `(lambda ()
     (setopt file-name-handler-alist file-name-handler-alist-old
       gc-cons-threshold (* 100 1024 1024)
       ;; Improve LSP performance
       read-process-output-max (* 1024 1024)
       select-active-regions 'only
       gc-cons-percentage 0.1)
     (garbage-collect)) t)

(setopt inhibit-compacting-font-caches t)

;; Optimize garbage collection
(use-package gcmh
  :custom ((gcmh-verbose nil)
      (gcmh-high-cons-threshold 16777216))
  :hook (after-init . gcmh-mode))
#+END_SRC
* Packages
** Major Modes
*** Markdown-mode
  A couple tweaks to make it more Org-like.
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun markdown-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1))

(use-package markdown-mode
  :hook ((markdown-mode . markdown-mode-tweaks)
      (gfm-mode . markdown-mode-tweaks))
  :bind-keymap (("M-<right>" . 'markdown-demote)
     ("M-<left>" . 'markdown-promote)
     ("M-<up>" . 'markdown-move-up)
     ("M-<down>" . 'markdown-move-down)
     ("C-c 1" . 'markdown-insert-header-atx-1)
     ("C-c 2" . 'markdown-insert-header-atx-2)
     ("C-<return>" . 'auralcat/kmacro-markdown-insert-header-same-level)
     ("C-M-<return>" . 'auralcat/kmacro-markdown-insert-header-nest-one-level)
     ("C-c 3" . 'markdown-insert-header-atx-3))
  :custom  ((markdown-fontify-code-blocks-natively t)
     (markdown-asymmetric-header t)
     (markdown-header-scaling nil))
  :config
  ;; Use fixed-pitch fonts inside code blocks.
  ;; TODO: How to move this out of :config?
  (set-face-attribute 'markdown-code-face nil :inherit 'fixed-pitch))

  #+END_SRC
**** Faces
I couldn't customize this through the ~markdown-header-scaling~ var, so let's try another approach.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/markdown-remap-heading-faces ()
  (face-remap-add-relative 'markdown-header-face-1 :height 2.0)
  (face-remap-add-relative 'markdown-header-face-2 :height 1.7)
  (face-remap-add-relative 'markdown-header-face-3 :height 1.4)
  (face-remap-add-relative 'markdown-header-face-4 :height 1.1)
  (face-remap-add-relative 'markdown-header-face-5 :height 1.0)
  (face-remap-add-relative 'markdown-header-face-6 :height 1.0))

(add-hook 'markdown-mode-hook 'auralcat/markdown-remap-heading-faces)
  #+END_SRC
**** Copy code block contents
This makes it easier for me when reading Markdown files in Emacs to
copy the contents of a code block immediately.

#+begin_src emacs-lisp :tangle yes
  (defun markdown-mark-code-block-contents ()
    "Put mark at end of code block contents, point at beginning.
  Marks only the text inside the code block delimiters ```."
    (interactive)
    (let (block-start block-end)
      ;; Find start of content (after opening ```)
      (save-excursion
    (when (re-search-backward "^```" nil t)
      (forward-line 1)
      (setopt block-start (point))
      ;; Find end of content (before closing ```)
      (when (re-search-forward "^```" nil t)
    (forward-line -1)
    (end-of-line)
    (setopt block-end (point)))))
      (when (and block-start block-end)
    (goto-char block-start)
    (push-mark block-end)
    (activate-mark)
    t)))

  (defun au/markdown-copy-block-content ()
    "Copy the content of the current Markdown code block without moving point."
    (interactive)
    (save-excursion
      (when (markdown-mark-code-block-contents)
    (let ((content (buffer-substring-no-properties (region-beginning) (region-end))))
      (kill-new content)
      (message "Code block content copied to kill ring")
      (deactivate-mark)))))

  (require 'markdown-mode)
  (eval-after-load 'markdown-mode
    (define-key markdown-mode-map (kbd "C-c M-w") #'au/markdown-copy-block-content))
#+end_src
*** Web Mode
    I use this for HTML files mostly.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode
  :bind (:map web-mode-map
      ("C-<up>"    . web-mode-element-previous)
      ("C-<down>"  . web-mode-element-next)
      ("C-<left>"  . web-mode-element-beginning)
      ("C-<right>" . web-mode-tag-match)
      ("C-S-<up>"  . web-mode-element-parent)
      ("M-<up>"    . web-mode-element-content-select)
      ("M-RET"     . complete))
  :custom ((web-mode-enable-auto-closing t)
    (web-mode-enable-auto-pairing nil)
    (web-mode-enable-current-element-highlight t)
    (web-mode-enable-auto-expanding nil)
    ;; Engine associations
    (web-mode-engines-alist
      '(("php"    . "\\.phtml\\'")
     ("blade"  . "\\.blade\\.")))
    ;; Indentation configuration
    (web-mode-markup-indent-offset 2)
    (web-mode-css-indent-offset    2)
    (web-mode-code-indent-offset   2)
    (web-mode-script-padding       2)
    (web-mode-style-padding        2))
  :config
  ;; File associations
  (add-to-list 'auto-mode-alist '(" \\.html.erb\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '(" \\.html.heex\\'" . web-mode))
  (add-to-list 'auto-mode-alist '(" \\.html?\\'"     . web-mode))
  ;; Use tidy to check HTML buffers with web-mode.
  (eval-after-load 'flycheck
    '(flycheck-add-mode 'html-tidy 'web-mode))

  (defun sp-web-mode-is-code-context (id action context)
    (and (eq action 'insert)
     (not (or (get-text-property (point) 'part-side)
      (get-text-property (point) 'block-side)))))

  (sp-local-pair 'web-mode "<" nil :when '(sp-web-mode-is-code-context)))
    #+END_SRC

*** Compilation mode tweaks
This is a built-in mode, but I want to change some stuff there.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun compilation-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1))

(add-hook 'compilation-mode-hook 'compilation-mode-tweaks)

;; Make the compilation buffer scroll to the end on command finish
(setopt compilation-scroll-output t)

;; Colorize output from compilation-mode
;; Taken from https://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html
(require 'ansi-color)
(defun endless/colorize-compilation ()
  "Colorize from `compilation-filter-start' to `point'."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region
     compilation-filter-start (point))))

(add-hook 'compilation-filter-hook
      #'endless/colorize-compilation)
#+END_SRC
*** Makefile-mode
I'm working with Makefiles now, so this is useful.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'makefile-mode-hook #'(lambda () (setq-local indent-tabs-mode t)))
#+END_SRC
*** Js2-mode
    A better default Javascript mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package js2-mode
  :mode "\\.js?\\'"
  :custom ((js-indent-level 2)
       (js2-highlight-level 3)))
    #+END_SRC

*** CSV-mode
    CSV support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package csv-mode)
    #+END_SRC
*** MermaidJS
[[http://mermaid-js.github.io/mermaid/][MermaidJS]] is a Markdown syntax to generate flowcharts and diagrams.
It's quite handy to use whenever you need to explain complex concepts to other people.

To install it, run the command below.
I'm not installing it automatically when Emacs starts because that takes up init time.
#+BEGIN_SRC shell
npm install -g @mermaid-js/mermaid-cli
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mermaid-mode
  :mode "\\.mermaid\\'")

(use-package ob-mermaid
  :custom ((ob-mermaid-cli-path (string-trim (shell-command-to-string "command -v mmdc")))))
#+END_SRC

***** Expand-region
This one is a classic in the Emacs community.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+END_SRC
***** Avy
It's a supercharged version of =ace-jump=, with batteries included and better performance!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package avy
  :config
  (avy-setup-default)
  (global-set-key (kbd "M-g j") 'avy-resume)
  (global-set-key (kbd "M-3") 'avy-goto-char))
#+END_SRC
***** Exec path from shell
  Replicates terminal env vars in graphical Emacs.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns x))
  :custom
  (exec-path-from-shell-check-startup-files nil)
  (exec-path-from-shell-variables '("PATH" "MANPATH"))
  :hook
  (after-init . exec-path-from-shell-initialize))
  #+END_SRC
***** Git-Link
Create links to Github/GitLab files from the comfort of your Emacs buffer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-link)
#+END_SRC
***** Magit delta
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-delta
  :hook (magit-mode . magit-delta-mode))
#+END_SRC
***** Smartparens
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :hook ((ruby-mode inf-elixir-mode emacs-lisp-mode shell-script-mode) . smartparens-mode)
  :bind (:map smartparens-mode-map
     ([remap backward-sexp] . sp-backward-sexp)
     ([remap forward-sexp] . sp-forward-sexp)
     ([remap kill-sexp] . sp-kill-sexp)
     ([remap mark-sexp] . sp-mark-sexp)
     ([remap transpose-sexp] . sp-transpose-sexp)
     ([remap kill-region] . sp-kill-region)
     ([remap kill-whole-line] . sp-kill-whole-line))
  :config
  (require 'smartparens-config))
#+END_SRC

***** Golden Ratio Mode
    Splits windows using the [[https://en.wikipedia.org/wiki/Golden_ratio][Golden Ratio]].
    This makes the focused window a bit larger than usual and the
    smaller ones are easier to read. It makes the multi-window
    experience more pleasing to the eye. Yeah, nature!
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package golden-ratio
  :diminish golden-ratio-mode
  :custom ((golden-ratio-extra-commands
     (append golden-ratio-extra-commands '(magit-status aw-flip-window))))
  :hook (after-init . golden-ratio-mode))
    #+END_SRC

***** Restart Emacs
    Restart Emacs from within Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package restart-emacs)
    #+END_SRC
***** Magit
    How to win at Git from Emacs.
    The configuration for each part is below in separate headings.
    #+BEGIN_SRC emacs-lisp :tangle yes
;; 2024-09-06 git-commit is distributed with magit now.
(defun git-commit-tweaks ()
  "Ensures that the commit body does not exceed 72 characters."
  (setopt fill-column 72)
  (setq-local comment-auto-fill-only-comments nil))

(use-package magit
  :defer t
  :hook ((git-commit . git-commit-tweaks)
     (magit-diff . visual-line-mode))
  :custom ((git-commit-summary-max-length 50)
    (magit-diff-refine-hunk t)))
    #+END_SRC
***** Yasnippets
    It originally came with company-mode, it's handy to write faster
    #+BEGIN_SRC emacs-lisp :tangle yes
(defun do-not-add-newline-for-snippets ()
  "What is says on the tin."
  (setq-local require-final-newline nil))

;; Combined YASnippet configuration
(use-package yasnippet
  :defer t
  :hook ((prog-mode . yas-minor-mode)
     (after-init . yas-global-mode))
  :config
  ;; Load snippet packages inside the :config block
  (use-package yasnippet-snippets)
  (use-package yasnippet-classic-snippets
    :hook (snippet-mode . do-not-add-newline-for-snippets))
  ;; Set the snippet directories after all packages are loaded
  (setq yas-snippet-dirs
    '("~/.emacs.d/snippets"
       yasnippet-snippets-dir
       yasnippet-classic-snippets-dir))
  ;; Initialize yasnippet
  (yas-reload-all))
    #+END_SRC
***** Circadian
    Theme changer for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package circadian
  ;; This is the heaviest package to load currently, so we can ask use-package
  ;; to load it LAST for us!
  :defer 1
  :config
  (setopt circadian-themes
      (cond
       ((eq system-type 'darwin)
        '((:sunrise . modus-operandi)
          (:sunset  . modus-vivendi)))
       ;; Personal Linux machine
       ((and (string-equal (system-name) auralcat/personal-system-name)
         (eq system-type 'gnu/linux))
        '((:sunrise . ef-day)
          (:sunset  . ef-dream)))
       (t '((:sunrise . modus-operandi)
        (:sunset  . modus-vivendi)))))
  (circadian-setup))
    #+END_SRC

***** Electric pair mode
This _built-in_ mode adds paired characters when you type brackets and
other things.

It's got a better performance than ~smartparens-mode~. Use it when you
don't need any specific features from ~smartparens-mode~.

#+begin_src emacs-lisp :tangle yes
(add-hook 'js-mode-hook 'electric-pair-mode)
(add-hook 'json-mode-hook 'electric-pair-mode)
(add-hook 'outline-mode-hook 'electric-pair-mode)
(add-hook 'markdown-mode-hook 'electric-pair-mode)
(add-hook 'org-mode-hook 'electric-pair-mode)
#+end_src

***** Auto package update
I honestly don't know why Emacs doesn't support this out of the box yet, but oh well.
You can put ~auto-package-update-async~ in the ~midnight-hook~.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-package-update
  :custom ((auto-package-update-at-time "11:30am")
       (auto-package-update-delete-old-versions t)))
#+END_SRC
** Minor Modes
*** Flycheck Inline
    Shows the error when leaving the point over the place where it occurs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-inline
  :hook (flycheck-mode . flycheck-inline-mode))
    #+END_SRC
*** Projectile
    Manage projects in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :hook (after-init . projectile-mode)
  :custom
  (projectile-keymap-prefix (kbd "C-c p"))
  (projectile-tags-command "ctags -eR .")
  (projectile-track-known-projects-automatically nil)
  (projectile-switch-project-action 'projectile-vc)
  (tags-revert-without-query t)
  :config
  (setopt projectile-globally-ignored-directories
    (append '(".git" ".svn" ".hg" "node_modules" "dist" "build" "__pycache__")
      projectile-globally-ignored-directories))
  :bind (:map global-map
      ("C-c p" . projectile-command-map)))
    #+END_SRC
*** Keyfreq
    Shows most used commands in editing session.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package keyfreq
  :hook (after-init . (keyfreq-mode keyfreq-autosave-mode))
  :custom ((keyfreq-excluded-commands
     '(self-insert-command
    org-self-insert-command
    weechat-self-insert-command
    isearch-printing-char
    markdown-enter-key
    abort-recursive-edit
    lsp-ui-doc--handle-mouse-movement))))
    #+END_SRC
*** Diminish
    Free some space in the mode line removing superfluous mode indications.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  ;; These are loaded at startup, I prefer declaring everything here.
  :diminish flycheck-mode
  :diminish projectile-mode
  :diminish auto-revert-mode
  :diminish auto-fill-mode
  :diminish abbrev-mode)
;; These are loaded in other moments
(eval-after-load "editorconfig" '(diminish 'editorconfig-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
    #+END_SRC
** Utilities
*** Deadgrep
Search with ~ripgrep~, this is much faster!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package deadgrep
  :bind (:map global-map ("C-c d" . deadgrep)))
#+END_SRC
*** Insert kaomoji
Because kaomoji is fun! ヽ(*⌒▽⌒*)ﾉ
#+begin_src emacs-lisp :tangle yes
(use-package insert-kaomoji
  :bind (:map global-map
      ("C-x 8 k" . insert-kaomoji)))
#+end_src
*** Ace window
#+begin_src emacs-lisp tangle: yes
(use-package ace-window
  :bind ("M-o" . ace-window)
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g)))
#+end_src
* Personal info
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Load from external file.
(load "~/.emacs.secrets")
  #+END_SRC

* Save command history
  It's a good idea to save the previous commands' history, for a couple reasons:
  - Check the complex commands you use most often and improve your workflow
    based on that
  - Store cumbersome commands for specific situations that don't
    appear too often

    #+BEGIN_SRC emacs-lisp :tangle yes
(setopt history-length 1024)
(setopt history-delete-duplicates t)
(setopt savehist-mode 1)
    #+END_SRC

* Enabled complex commands
Emacs comes with some commands disabled by default to not confuse new users.
So I need to enable them like this to not get pestered by it when trying to use them.

#+BEGIN_SRC emacs-lisp :tangle yes
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC
* Browse-url
  This is a command to open the browser for the URL at point.
  #+begin_src emacs-lisp :tangle yes
  (setopt browse-url-browser-display nil
    ;; As of July 2025, the order of browsers that browse-url chooses with `browse-url-default-browser' is _hardcoded_:
    ;; 1. Firefox
    ;; 2. Chromium
    ;; 3. KDE browser
    ;; 4. Google Chrome
    ;; 5. Webpositive
    ;; 6. Xterm
    ;; So this is why we need to add `browse-url-chrome' directly here to use it as the default browser for `browse-url'.
    browse-url-browser-function 'browse-url-chrome
    browse-url-firefox-program "firefox"
    browse-url-chrome-program "chrome-flatpak.sh")
  #+end_src

** Flatpak trick
~executable-find~ is not able to find Flatpak packages directly.
You'll need to put a script like this in your PATH:
#+begin_src sh
#!/bin/bash
exec flatpak run com.google.Chrome "$@"
#+end_src

Then set ~(setopt browse-url-chrome-program "<script_name>")~.
* Bookmarks
  It's a quicker way to navigate through files you visit often.
  #+BEGIN_SRC emacs-lisp :tangle yes
(setopt bookmark-default-file "~/emacs-bookmarks")
;; Every time bookmarks are changed, save them
(setopt bookmark-save-flag 1)
  #+END_SRC
* Occur
Occur is useful for when you want to keep a list of code points of interest in a
given buffer or a set of buffers with ~multi-occur-in-matching-buffers~. I was
used to doing this multi search through ~ibuffer~, but you can call this function
from ~M-x~ and get the same result if you want.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Source: https://www.reddit.com/r/emacs/comments/l9b049/comment/glheho5
(defun rename-occur-buffer ()
  "Rename *Occur* buffers more descriptively."
  (interactive) ; if you want to do it manually
  (save-excursion
    (save-match-data
      (goto-char (point-min))
      (when
      (search-forward-regexp
       "^[0-9]+ matches for \"\\(.*\\)\" in buffer: \\(.*\\)$"
       (line-end-position)
       nil)
    (rename-buffer
     (format "*Occur %s: %s*" (match-string 2) (match-string 1)))))))

(add-hook 'occur-hook #'(lambda () (occur-rename-buffer t nil)))
#+END_SRC
* Dired
  A couple customizations.
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Customize Dired list switches.
(setopt dired-listing-switches "-alh")

;; Kill selected subdir with C-M-k
(add-hook 'dired-mode-hook #'(lambda () (define-key dired-mode-map (kbd "C-M-k") 'dired-kill-subdir)))
  #+END_SRC
* Programming
** General configuration
*** Manual customization
#+BEGIN_SRC emacs-lisp :tangle yes
;; Manual completion for you.
(define-key prog-mode-map (kbd "M-<return>") 'dabbrev-expand)

;; Save automatically when visiting source code files.
(add-hook 'prog-mode-hook #'(lambda () (auto-save-visited-mode 1)))

(defun prog-mode-tweaks ()
  ;; Set line number mode and column number mode for code files
  (display-line-numbers-mode)
  (setopt fill-column 80))

(add-hook 'prog-mode-hook 'prog-mode-tweaks)
#+END_SRC
*** Comint tweaks
When you are working in the comint/REPL buffer, you normally want the
output to be visible at all times.

We need to make it scroll to the bottom of the comint buffer
automatically.

#+begin_src emacs-lisp :tangle yes
(setopt comint-scroll-to-bottom-on-input t)
(setopt comint-scroll-to-bottom-on-output t)
(setopt comint-move-point-for-output t)
#+end_src
*** LSP mode
We need this nowadays.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :custom ((lsp-keymap-prefix "C-c l")
    (lsp-idle-delay 0.5)
    (lsp-enable-symbol-highlighting t)
    ;; Not supported by company capf, which is the recommended company backend
    (lsp-enable-snippet nil)
    (lsp-completion-enable t)
    ;; Python LSP configuration
    (lsp-pyls-plugins-flake8-enabled nil)
    (lsp-pyls-plugins-black-enabled t)
    (lsp-pylsp-plugins-ruff-enabled t)
    (lsp-pyls-plugins-rope-autoimport-enabled t)
    ;; Pylsp formatter config
    (lsp-pylsp-plugins-black-line-length 88)
    ;; Terraform LSP configuration
    (lsp-terraform-ls-prefill-required-fields t)
    (lsp-enable-links t)
    (lsp-semantic-tokens-honor-refresh-requests t)
    (lsp-register-custom-settings
      '(("pyls.plugins.pyls_black.enabled" t t)
     ("pyls.plugins.pyls_isort.enabled" t t)
     ("pylsp.plugins.rope_autoimport.enabled" t t)
     ("pylsp.plugins.rope_completion.enabled" t t))))
  :hook ((python-mode
      ruby-mode
      web-mode
      typescript-mode
      json-mode
      cfn-mode
      terraform-mode) . lsp)
  :commands lsp)

(use-package lsp-ui
  :custom ((lsp-ui-sideline-show-hover t)
    (lsp-ui-sideline-delay 0.5)
    (lsp-ui-doc-delay 5)
    (lsp-ui-sideline-ignore-duplicates t)
    (lsp-ui-doc-position 'bottom)
    (lsp-ui-doc-alignment 'frame)
    (lsp-ui-doc-header nil)
    (lsp-ui-doc-include-signature t)
    (lsp-ui-doc-use-childframe t))
  :commands lsp-ui-mode)
#+end_src
**** Web mode indentation fix
~web-mode~ has its own indentation configuration. We shouldn't use the
LSP indentation, it messes things up. And that brings a lot of pain
and suffering when developing with stuff like Vue and Svelte.

#+begin_src emacs-lisp :tangle yes
(add-hook 'web-mode-hook
      (lambda ()
    (setq-local lsp-enable-indentation nil)))
#+end_src

*** Highlight TODO
This is a package to highlight TODO keywords in any given mode, not just on ~org-mode~.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hl-todo
  :hook ((prog-mode . hl-todo-mode)))
#+END_SRC
*** Highlight line
This does not require any extra packages as of Emacs 21. Great thing to know where you are at a given point when programming.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC
*** Highlight-numbers mode
    Sets font lock faces to numbers in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-numbers
  :after prog-mode
  :hook ((prog-mode . highlight-numbers-mode)))
    #+END_SRC
*** Indent-bars mode
A new package on the block that is faster than ~highlight-indentation~.
#+begin_src emacs-lisp :tangle yes
(use-package indent-bars
  :hook ((prog-mode) . indent-bars-mode))
#+end_src
*** Editorconfig
    Helps developers define and maintain consistent coding styles
    between different editors and IDEs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :after prog-mode
  :hook (after-init . editorconfig-mode))
    #+END_SRC
*** Diff-Highlight
    Highlights the changed content in buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :hook ((prog-mode . diff-hl-mode)
     (dired-mode . diff-hl-dired-mode)
     (magit-post-refresh . diff-hl-magit-post-refresh)))
    #+END_SRC
*** Rainbow Delimiters
    Highlight parentheses, brackets and braces according to their
    depth.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :after prog-mode
  :hook ((prog-mode . rainbow-delimiters-mode)
     (ielm-mode . rainbow-delimiters-mode)
     (slime-repl-mode . rainbow-delimiters-mode)))
    #+END_SRC
*** Git Gutter
    Shows (and enables you to navigate between) parts of the code
    which where changed comparing to the current revision in a
    version-controlled project.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-gutter
  :when window-system
  :hook ((prog-mode . git-gutter-mode))
  :diminish ""
  :config
  (use-package git-gutter-fringe
    :after git-gutter
     :init
    (require 'git-gutter-fringe)
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added
    [224 224 224 224 224 224 224 224 224 224 224 224 224
     224 224 224 224 224 224 224 224 224 224 224 224]
    nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:modified
    [224 224 224 224 224 224 224 224 224 224 224 224 224
     224 224 224 224 224 224 224 224 224 224 224 224]
    nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:deleted
    [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
    nil nil 'center))))
    #+END_SRC
** Treesitter
#+begin_src emacs-lisp :tangle yes
;; Configure tree-sitter language sources
(setopt treesit-language-source-alist
      '((json "https://github.com/tree-sitter/tree-sitter-json")
        (python "https://github.com/tree-sitter/tree-sitter-python")
        (ruby "https://github.com/tree-sitter/tree-sitter-ruby")))

;; Automatically remap modes to use tree-sitter versions
(setopt major-mode-remap-alist
      '((json-mode . json-ts-mode)
        (python-mode . python-ts-mode)
        (ruby-mode . ruby-ts-mode)))

;; Function to install the grammars
(defun my/install-language-grammars ()
  "Install tree-sitter grammars for Ruby, Python, and JSON."
  (interactive)
  (dolist (lang '(json python ruby))
    (unless (treesit-language-available-p lang)
      (message "Installing %s grammar..." lang)
      (treesit-install-language-grammar lang))))

;; Optionally, install grammars automatically on startup
;; Uncomment the next line if you want automatic installation
;; (my/install-language-grammars)
#+end_src

** Claude Code
Use ~claude-code~ straight from the comfort of your Emacs!
#+begin_src emacs-lisp :tangle yes
(use-package claude-code
  :ensure t
  :bind (:map global-map ("C-c c" . claude-code-transient)))
#+end_src

** Termint
Use a dedicated terminal in Emacs for comint modes! This works GREAT with ~vterm~!
#+begin_src emacs-lisp :tangle yes
(use-package termint
  :demand t
  :after python
  :bind
  (:map python-ts-mode-map
   ("C-c s" . termint-ipython-start))

  :config
  (termint-define "ipython" "ipython" :bracketed-paste-p t
                  :source-syntax termint-ipython-source-syntax-template)

  ;; C-c m s: `termint-ipython-start'
  ;; C-c m e: `termint-ipython-send-string'
  ;; C-c m r: `termint-ipython-send-region' (or `termint-ipython-send-region-operator' if evil is installed.)
  ;; C-c m p: `termint-ipython-send-paragraph'
  ;; C-c m b: `termint-ipython-send-buffer'
  ;; C-c m f: `termint-ipython-send-defun'
  ;; C-c m R: `termint-ipython-source-region' (or `termint-ipython-source-region-operator' if evil is installed.)
  ;; C-c m P: `termint-ipython-source-paragraph'
  ;; C-c m B: `termint-ipython-source-buffer'
  ;; C-c m F: `termint-ipython-source-defun'
  ;; C-c m h: `termint-ipython-hide-window'
  (define-key python-ts-mode-map (kbd "C-c m") termint-ipython-map))
#+end_src

** Terraform
#+begin_src emacs-lisp :tangle yes
(use-package terraform-mode
  :custom
  (terraform-format-on-save t)
  :mode "\\.tf\\'")
#+end_src

** Ruby
*** Main configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ruby-mode
  :bind-keymap (("C-c SPC" . ruby-send-buffer))
  :hook (ruby . (flycheck-mode)))
#+END_SRC
*** Projectile Rails
Rails utilities for Projectile-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile-rails
  :after projectile
  :hook (ruby-mode . projectile-rails-mode))
#+END_SRC
*** Bundler
Interact with Bundler from Emacs
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ruby-mode
  :defer t
  :mode "\\.rb\\'"
  :interpreter "ruby")
#+END_SRC
*** Rcodetools
This is a gem that you can install and copy the ~rcodetools.el~ file to your ~load-path~ to add bindings to Emacs.
When you run ~comment-dwim~ twice in a ~ruby-mode~ buffer, it will output a comment like this: ~# =>~
Then you can run the ~xmp~ function to have Ruby evaluate that snippet of code right in your buffer, without having to run ~inf-ruby~.

To install the ~rcodetools~ gem, run:
#+BEGIN_SRC shell :eval never
gem install rcodetools
#+END_SRC

Then copy ~rcodetools.el~ from the gem directory to your Emacs' ~load-path~:
#+BEGIN_SRC shell :eval never
cp /path/to/rcodetools.el ~/emacs.d/manual-packages/rcodetools.el
#+END_SRC

After that, we can require it in our configuration:
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ruby-mode
    :mode "\\.rb\\'"
    :init
    (add-to-list 'load-path "~/my-dotfiles/.emacs.d/manual-packages")
    :config
    (require 'rcodetools)
    (define-key ruby-mode-map (kbd "C-c C-c") 'xmp))
#+END_SRC

*** Robe
Robe provides references for code evaluated in runtime. It unpacks all
the metaprogramming definitions that you may have in the project and
points you to where the original code is defined.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package robe
  :hook (ruby . robe-mode))
#+END_SRC
*** Rspec-mode
I use ~RSpec~ quite a lot now.
#+begin_src emacs-lisp :tangle yes
(use-package rspec-mode
  :after ruby-mode
  :hook ((after-init . inf-ruby-switch-setup)
     (ruby . rspec-mode)
     (rspec . rspec-install-snippets)))
#+end_src
** Python
I'm starting to work with machine learning lately, so I'll need to set
up my Python config and brush up my Python-fu.

#+begin_src emacs-lisp :tangle yes
(use-package python-mode
  :bind-keymap (("C-c SPC" . 'python-shell-send-buffer)
      ("C-x C-e" . 'python-shell-send-statement)))
#+end_src
*** python-pytest
Run your Python unit tests straight from Emacs.
Note that there are two packages for running tests from Python
projects in MELPA: ~python-pytest~ and simply ~pytest~.
~python-pytest~ lets you run tests in a "do what I mean" (DWIM)
fashion, so this is why I chose it.

#+begin_src emacs-lisp :tangle yes
(use-package python-pytest
  :after python-mode
  :bind (:map python-mode-map
      ("C-c t f" . python-pytest-function)
     ("C-c t t" . python-pytest-file)
     ("C-c t r" . python-pytest-repeat)))
#+end_src

*** Format all
Format your code with ~black~.
You will need to have the ~black~ lib installed in your Python
interpreter:
#+begin_src sh :noeval
pip3 install black
#+end_src

NOTE: Format all does not work well with Rubocop, so that's why
I'm not using it for Ruby.

#+begin_src emacs-lisp :tangle yes
(use-package format-all
  :commands format-all-mode
  :hook (python-mode . format-all-mode)
  :custom (format-all-formatters
    '(("Python"     (black)))))
#+end_src
*** Poetry
~poetry~ is a Python library that is like ~bundler~ for Ruby.
It's a better approach for dependency management and isolation than
using plain ~pip~ with ~virtualenv~.
~poetry~ is also smart enough to create its own virtual environment to
isolate its dependencies. This means one less hurdle to work with
Python in Emacs!

#+begin_src emacs-lisp :tangle yes
(use-package poetry
  :after python-mode
  :commands (poetry-venv-toggle poetry-venv-workon poetry-track-virtualenv)
  :hook (python-mode . poetry-tracking-mode))
#+end_src
*** IPython with Jupyter Notebook kernel
To run the kernel with code from your project, do this:

#+begin_src sh
cd ~/your-project-dir
ipython kernel
#+end_src

And we also add a function to either use IPython or the first running
Jupyter Notebook Python kernel.
#+begin_src emacs-lisp :tangle yes
(defun jupyter-notebook-running-p ()
  "Check if a Jupyter notebook is running."
  (string-match-p "http://\\(localhost\\|127.0.0.1\\):[0-9]+"
      (shell-command-to-string "jupyter notebook list")))

(defun auralcat/run-python ()
  "Runs IPython if no Jupyter Notebook instance is running.
Otherwise, use the running Jupyter Notebook kernel."
  (interactive)
  (if (jupyter-notebook-running-p)
      (setopt python-shell-interpreter "jupyter"
              python-shell-interpreter-args "console --existing --simple-prompt")
    (setopt python-shell-interpreter "ipython"
            python-shell-interpreter-args "--simple-prompt"))
  (run-python)
  (pop-to-buffer "*Python*"))

;; Need this to have the Python shell scroll results to the bottom
(add-hook 'inferior-python-mode-hook
      (lambda ()
    (setopt comint-move-point-for-output t)))

(defun auralcat/python-display-buffer-function (buffer alist)
  "Smart display function for Python buffers based on frame size."
  (cond
   ((> (frame-width) 160)
    (display-buffer-in-direction buffer (append '((direction . right) (window-width . 0.5)) alist)))
   ((> (frame-height) 40)
    (display-buffer-in-direction buffer (append '((direction . below) (window-height . 0.3)) alist)))
   (t
    (display-buffer-same-window buffer alist))))

(add-to-list 'display-buffer-alist
             '("\\*Python\\*"
               auralcat/python-display-buffer-function))

(with-eval-after-load 'python
  (define-key python-mode-map (kbd "C-c C-p") 'auralcat/run-python))
#+end_src

** YAML
*** Main configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :hook ((yaml-mode . display-line-numbers-mode)
     (yaml-mode . hl-line-mode)))
#+END_SRC
*** Indent-tools
Necessary to work in a sane way with YAML files.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package indent-tools
  :hook ((yaml-mode . indent-tools-minor-mode)))
#+END_SRC
** Vue.js
For Vue, we can use ~web-mode~. It's smart enough to work with multiple frameworks, so we just need to add it to ~auto-mode-alist~ here.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.vue\\'"  . web-mode))
#+END_SRC
** Typescript
#+begin_src emacs-lisp :tangle yes
(setopt typescript-indent-level 2)
#+end_src
** Svelte
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.svelte\\'"  . web-mode))
  ;; We want to use ESLint to check our syntax and stuff.
  ;; To have eslint work, you'll need to have a .eslintrc file in your project root.
  (eval-after-load 'flycheck
    '(flycheck-add-mode 'javascript-eslint 'web-mode))
  (add-hook 'web-mode-hook 'flycheck-mode)
#+END_SRC
** JSON
Turns out that the built-in ~electric-pair-mode~ behaves better than ~smartparens~ when you're writing JSON.
#+begin_src emacs-lisp :tangle yes
(use-package json
  :custom (js-indent-level 2))
#+end_src
** Lisp
Some Lisp configuration to make it easier to use it.
#+BEGIN_SRC emacs-lisp :tangle yes
(setopt lisp-indent-function 'common-lisp-indent-function)
(setopt lisp-indent-offset 2)
#+END_SRC
** Prettier
This is pretty useful to pretty-format HTML, CSS and JS files locally.
Remember to install the ~prettier~ NPM package in your machine:

#+begin_src shell
npm install -g prettier
#+end_src

Invoke it in Emacs with ~prettier-prettify~.

#+begin_src emacs-lisp :tangle yes
(use-package prettier)
#+end_src
* Mac OS
  #+BEGIN_SRC emacs-lisp :tangle yes
(when (eq system-type 'darwin) ;; mac specific settings
  ;; Use bigger fonts because of that Retina display
  (if (member "Monofur" (font-family-list))
      (set-face-attribute (quote default) nil :font "Monofur" :height 120)
    (set-face-attribute (quote default) nil :font "Monaco" :height 120))
  ;; Map Command to Meta
  (setopt mac-command-modifier 'meta)
  ;; Map Option to Control (I know, smaller key, that's what we have for now. :/)
  (setopt mac-option-modifier 'control)
  ;; Map Control key in OS X to Super
  (setopt mac-control-modifier 'super)
  ;; Map Fn key in OS X to Hyper
  (setopt ns-function-modifier 'hyper)
  ;; Point the executables in Mac OS to Emacs.
  (add-to-list 'exec-path "/usr/local/bin/")
  ;; Enable EPA
  (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))

  ;; Use Emacsclient in OS X
  (setopt server-socket-dir (format "/tmp/emacs%d" (user-uid))))
  #+END_SRC

* IRC
** RCIRC general settings
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rcirc
  :commands (rcirc)
  :hook (rcirc . rcirc-track-minor-mode)
  :custom (;; Enable logging if desired
    (rcirc-log-directory "~/rcirc-logs")
    (rcirc-log-flag t)
    (rcirc-auto-authenticate-flag t)
    (rcirc-who-requery-timeout nil)
    (rcirc-auto-who-list nil)))
#+END_SRC

** Color nicks
I want my colors please! 💅
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rcirc-color
  :after rcirc
  :hook (rcirc . rcirc-color-mode))
#+END_SRC
** Track chats with ibuffer
~ibuffer~ is a nice way to list buffers for you. We can use it to
track IRC channels in a centralized view, besides using ~C-c C-@~ to
jump between chats. And ~C-c C-a~ to jump to the first unread line.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ibuffer-rcirc
  :after (ibuffer rcirc)
  :custom (ibuffer-formats
       '((mark modified read-only rcirc-activity-status-one-char " "
           (name 18 18 :left :elide)
           " "
           (size 9 -1 :right)
           " "
           (mode 16 16 :left :elide)
           " "
           (rcirc-activity-status 20 18 :left) " "
           filename-and-process))))
#+END_SRC
* Minibuffer completion
Currently I'm using ~ido-mode~ to provide completion in the
minibuffer.
~ido-everywhere~ allows you to use ~ido~'s functionality in any function that uses
the minibuffer, not only the ones that are directly supported.

<2023-10-08 Sun> Turns out ~icomplete-mode~ was hogging too much CPU on
large buffers and slowing Emacs down. Then I removed it.
#+BEGIN_SRC emacs-lisp :tangle yes
(ido-mode 1)
(ido-everywhere 1)
(setopt ido-enable-flex-matching nil)
#+END_SRC
* Create scratch buffers
I'm doing this a lot recently. Need to make it faster.
#+begin_src emacs-lisp :tangle yes
;; Stop Ido from prompting me when I want to create a new buffer
  (setopt confirm-nonexistent-file-or-buffer nil)
  ;; For IDO
  (setopt ido-create-new-buffer 'always)
#+end_src
* REPL
We need to do some customizations to comint-related buffers to improve performance.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun comint-mode-tweaks ()
  ;; Font-lock is the one that takes the biggest toll on performance.
  (font-lock-mode -1)
  (auto-composition-mode -1)
  (auto-compression-mode -1)
  (column-number-mode -1)
  (auto-save-visited-mode -1))

(add-hook 'comint-mode-hook 'comint-mode-tweaks)
#+END_SRC

** termint
This is a HUGE boost in the REPL experience in Emacs!
This allows you to leverage packages like ~vterm~ and ~eat~ to run the comint REPLs in them instead of the standard Emacs shell!
Be amazed by the world of 256 colors in your terminal by default, and autocompletion!
Get all the goodies you have in the standard terminals from the comfort of your Emacs!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package vterm
  :custom
  ;; Allow compilation of the vterm module
  (vterm-always-compile-module t)
  ;; Increase scrollback
  (vterm-max-scrollback 10000)
  ;; Customize appearance
  (vterm-buffer-name-string "vterm %s")
  ;; Prevent libvterm issues by using bundled version
  (vterm-module-cmake-args "-DUSE_SYSTEM_LIBVTERM=no"))

(use-package termint
  :after '(python ruby)
  :custom
  (termint-backend 'vterm)
  :bind ((:map python-mode-map
         ("C-c s" . termint-ipython-start)
          ("C-c r" . termint-ipython-map))
        (:map ruby-mode-map
         ("C-c s" . termint-irb-start)
          ("C-c r" . termint-irb-map)))
  :config
  (termint-define "ipython" "ipython"
                  :bracketed-paste-p t
                  :source-syntax termint-ipython-source-syntax-template)
  (termint-define "irb" "irb"
                  :bracketed-paste-p t
                  :source-syntax termint-ruby-source-syntax-template)
  ;; For Evil mode users
  (when (featurep 'evil)
    (evil-define-key '(normal visual)
      python-mode-map (kbd "SPC r s") #'termint-ipython-send-region-operator)
    (evil-define-key '(normal visual)
      python-mode-map (kbd "SPC r b") #'termint-ipython-send-buffer)
    (evil-define-key '(normal visual)
      python-mode-map (kbd "SPC r f") #'termint-ipython-source-region-operator)
    (evil-define-key '(normal visual)
      ruby-mode-map (kbd "SPC r s") #'termint-irb-send-region-operator)
    (evil-define-key '(normal visual)
      ruby-mode-map (kbd "SPC r b") #'termint-irb-send-buffer)
    (evil-define-key '(normal visual)
      ruby-mode-map (kbd "SPC r f") #'termint-irb-source-region-operator)))

;; Optional: Define a helper for Ruby source syntax if not provided by termint
(defvar termint-ruby-source-syntax-template
  "tmp_file=%s
load tmp_file
File.delete(tmp_file)")

;; Configure window display rules for REPL buffers
(add-to-list 'display-buffer-alist
             '("\\*ipython\\*"
               (display-buffer-in-side-window)
               (window-width . 0.5)
               (side . right)
               (slot . 0)))

(add-to-list 'display-buffer-alist
             '("\\*irb\\*"
               (display-buffer-in-side-window)
               (window-width . 0.5)
               (side . right)
               (slot . 1)))
#+END_SRC
* Abbreviations
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Enable global Abbrev mode
(setq-default abbrev-mode t)

;; Don't ask to save new abbrevs, just save them.
(setopt save-abbrevs 'silently)

;; Location of the abbrev definition file
(setopt abbrev-file-name "~/.abbrev_defs")
  #+END_SRC
* Custom derived modes
I use those for creating new namespaces for abbrevs or special functions in them
without affecting the respective parent mode.
** Org-English mode
This is a derived mode to hold English abbrevs.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode org-english-mode org-mode "Org-EN"
  "Org-mode used to hold English abbrevs. Does everything that plain org-mode does.")

(add-to-list 'auto-mode-alist '("\\.org\\.en?\\'" . org-english-mode))

;; Disable it for outline-mode derivatives like Markdown and Org.
(add-hook 'org-english-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC
** Livemd mode
This mode was created to offer support for =.livemd= files. These are generated by Livebook.

Livebook uses a special kind of Markdown, but for us there is no change
whatsoever from the usual ~gfm-mode~. It also has special keybindings in the
original implementation to add Elixir, Markdown or Mermaid blocks to the file.
In our case when implementing this in Emacs, we just need a keybinding to add
the Mermaid and Elixir code blocks.

Livebook supports Elixir code as a first class citizen as well as Mermaid diagrams.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode livemd-mode gfm-mode "Livebook"
  "A Markdown-flavored mode for editing Livebook notebook files."
(define-key livemd-mode-map (kbd "C-c e") 'livemd/insert-elixir-block)
(define-key livemd-mode-map (kbd "C-c m") 'livemd/insert-mermaid-block)
(define-key livemd-mode-map (kbd "C-c n") 'markdown-insert-header-atx-2)
(add-to-list '
auto-mode-alist '("\\.livemd?\\'" . livemd-mode))
(add-hook 'livemd-mode-hook #'(lambda () (auto-revert-mode 1)))
(add-hook 'livemd-mode-hook #'(lambda () (auto-save-visited-mode 0))))

(defun livemd/insert-elixir-block (args)
  "Inserts an Elixir code block."
  (interactive "P")
  (markdown-insert-gfm-code-block "elixir" nil))

(defun livemd/insert-mermaid-block (args)
  "Inserts a Mermaid diagram block."
  (interactive "P")
  (markdown-insert-gfm-code-block "mermaid" nil))
#+END_SRC
** Markdown-portuguese mode
An extra namespace for ~markdown-mode~ so I can store abbrevs and ~yasnippet~ snippets in Portuguese for ~markdown-mode~.

I'm leaving this mode to be toggled manually for now.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode markdown-portuguese-mode markdown-mode "Markdown-PT"
  "Markdown-mode used to hold Portuguese abbrevs. Does everything that plain markdown-mode does."
  (setq-local ispell-local-dictionary "pt_BR"))

(add-hook 'markdown-portuguese-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC

** Gfm-portuguese mode
An extra namespace for ~gfm-mode~ so I can store abbrevs and ~yasnippet~ snippets in Portuguese for ~gfm-mode~.

I'm leaving this mode to be toggled manually for now.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode gfm-portuguese-mode gfm-mode "Gfm-PT"
  "Gfm-mode used to hold Portuguese abbrevs. Does everything that plain gfm-mode does."
  (setq-local ispell-local-dictionary "pt_BR"))

(add-hook 'gfm-portuguese-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC

* Org-mode
** Main configuration
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; Allow alphabetical lists please
      (setopt org-list-allow-alphabetical t)
     (define-key global-map (kbd "C-c a") 'org-agenda)
     (define-key global-map (kbd "C-c k") 'org-capture)

     (setopt org-hierarchical-todo-statistics nil
       org-src-fontify-natively t
       org-todo-keywords '((sequence "TODO" "DONE"))
       org-agenda-scheduled-leaders '("Scheduled: " "Sched. previously %2dx: ")
       org-agenda-skip-scheduled-if-done t
       org-agenda-start-on-weekday 0)

     ;; Start indented.
     ;; (setopt org-startup-indented t)

     ;; Change the end of collapsed headings to an arrow.
     (setopt org-ellipsis "⤵")

     ;; Don't split my lines, thx.
     (setopt org-M-RET-may-split-line nil)

     ;; Truncate long task names
     (setopt org-clock-heading-function
       #'(lambda ()
     (let ((str (nth 4 (org-heading-components))))
       (concat (truncate-string-to-width str 27) "...")
       )))

     ;; Organize the bindings
     ;; Open subheading with C-c RET and invert with M-RET
     (define-key org-mode-map (kbd "C-c RET") 'org-ctrl-c-ret)
     (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)

     ;; Use C-RET to complete words in Org-mode
     (define-key org-mode-map (kbd "C-RET") 'complete)

     ;; Map C-S-enter to org-insert-todo-subheading
     (define-key org-mode-map (kbd "<C-S-return>") 'org-insert-todo-subheading)

     ;; Dummy-proofing my configs
     (define-key org-mode-map (kbd "C-c ]") nil)
     (define-key org-mode-map (kbd "C-c [") nil)

     ;; Log when a task was done and when it was rescheduled.
     (setopt org-log-done 'time)
     (setopt org-log-reschedule 'time)

     ;; Don't write inside invisible area when collapsing headings!
     (setopt org-catch-invisible-edits 'error)

     ;; Refile items to the same buffer along with the agenda files
     (setopt org-refile-targets '((nil :maxlevel . 3)
    (org-agenda-files :maxlevel . 3)))
   #+END_SRC

** Tables
Use the fixed-pitch font for tables.
#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+END_SRC

Also allow me to highlight columns and rows please!
Need to call the functions that highlight the columns and rows manually.
Pretty nifty!
#+begin_src emacs-lisp :tangle yes
(use-package org-table-highlight
  :vc (:url "https://www.github.com/llcc/org-table-highlight" :rev :newest)
  :hook ((org-mode . org-table-highlight-mode)
         (after-init . org-table-highlight-load-metadata)))
#+end_src

** Quick capture to inbox
Borrowed and adapted from https://macowners.club/posts/org-capture-from-everywhere-macos/#capture-an-url-from-safari
#+begin_src emacs-lisp :tangle yes
(defun timu-func-make-capture-frame ()
  "Create a new frame and run `org-capture'."
  (interactive)
  (make-frame '((name . "capture")
    (top . 300)
    (left . 700)
    (width . 80)
    (height . 25)))
  (select-frame-by-name "capture")
  (delete-other-windows)
  (require 'noflet)
  (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
    ;; Customize your org-capture function here
      (org-capture nil "i")))

(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame."
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame."
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))
#+end_src

** Org-agenda configuration
Colorize the agenda: https://llazarek.com/2018/07/improving-the-agenda.html
#+BEGIN_SRC emacs-lisp :tangle yes
;; Display holidays from calendar into agenda
(setopt org-agenda-include-diary t)

;; Set agenda as sticky. This makes the buffers persistent, and load faster if
;; you open them all the time.
(setopt org-agenda-sticky t)

;; Keep agenda file list in a single file so I can publish my config.
;; DO NOT use C-c [ or C-c ] to add/remove files to the agenda otherwise
;; Emacs will write the var to init.el
(setopt org-agenda-files "~/file-bouncer/org-agenda-file-list.org")

(defun ll/org/agenda/color-headers-with (tag fg-col bg-col)
  "Color agenda lines matching TAG with color FG-COL."
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward tag nil t)
    (unless (find-in-line "\\[#[A-Z]\\]")
      (let ((todo-end (or (ll/org/agenda/find-todo-word-end)
      (point-at-bol)))
    (tags-beginning (or (find-in-line " :" t)
    (point-at-eol))))
    (add-text-properties todo-end
     tags-beginning
     `(face (:foreground ,fg-col :background ,bg-col)))))))

;; Helper definitions
(setopt ll/org/agenda-todo-words
      '("TODO" "GOAL" "NEXT" "STARTED" "WAITING" "REVIEW" "SUBMIT"
    "DONE" "DEFERRED" "CANCELLED"))
(defun find-in-line (needle &optional beginning count)
  "Find the position of the start of NEEDLE in the current line.
  If BEGINNING is non-nil, find the beginning of NEEDLE in the current
  line. If COUNT is non-nil, find the COUNT'th occurrence from the left."
  (save-excursion
    (beginning-of-line)
    (let ((found (re-search-forward needle (point-at-eol) t count)))
      (if beginning
      (match-beginning 0)
    found))))
(defun ll/org/agenda/find-todo-word-end ()
  (reduce (lambda (a b) (or a b))
      (mapcar #'find-in-line ll/org/agenda-todo-words)))
#+END_SRC
*** Custom agenda commands
#+BEGIN_SRC emacs-lisp :tangle yes
(setopt org-agenda-custom-commands
      '(("i" "Inbox items"
    ((tags "inbox")))))
#+END_SRC
** Org-babel
*** General settings
- Do not ask me if I want to run the source block
- Output the results in _scripting_ mode, instead of eval mode.
- Wrap them in an example block (for exporting)
  Important: the default header args will be:
  =:noweb :results output verbatim replace :exports both=
- Also display the contents of the source code block in a monospace font when possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-org-confirm-babel-evaluate (lang body)
  "Don't confirm squat."
  (not (member lang '("sh" "elisp" "ruby" "elixir" "shell"))))

;; A few more tweaks for org-babel.
(setopt org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate
      org-src-preserve-indentation t
      org-babel-min-lines-for-block-output 1
      org-babel-default-header-args
      (cons '(:noweb . "yes")
    (assq-delete-all :noweb org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:exports . "both")
    (assq-delete-all :exports org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:results . "output verbatim replace")
    (assq-delete-all :results org-babel-default-header-args)))
#+END_SRC
*** ob-async
This is to run org source code blocks asynchronously.
Backends like Python implement their own asynchronous way of running
things, so you need to add extra configuration when using them.
Not the case right now, though.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-async)
#+END_SRC

*** Elixir
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-elixir)
    #+END_SRC
*** Load languages
    #+BEGIN_SRC emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (shell . t)
   (python . t)
   (sql . t)
   (ruby . t)
   (elixir . t)
   (plantuml . t)
   (dot . t)))
    #+END_SRC
*** CUSTOM: Copy block content
I'm seeing code displayed in browser UIs lately. I noticed that they
have a button to copy the contents of the code block. That is very
useful to me since I need to copy code often. I would like to have
this same feature in org-mode as well.

#+begin_src emacs-lisp :tangle yes
(defun au/org-babel-copy-block-content ()
  "Copy the content of the current org-babel source block without moving point."
  (interactive)
  (save-excursion
    (when (org-babel-mark-block)
      (let ((content (buffer-substring-no-properties (region-beginning) (region-end))))
    (kill-new content)
    (message "Source block content copied to kill ring")
    (deactivate-mark)))))

(define-key org-mode-map (kbd "C-c C-v M-w") #'au/org-babel-copy-block-content)
#+end_src

* Function Aliases
  #+BEGIN_SRC emacs-lisp :tangle yes
;; This is how you define aliases for Elisp functions. These are useful for when
;; you don't need to bind a command to a specific key, but you call that
;; function through M-x often.
(defalias 'plp 'package-list-packages)
(defalias 'kfs 'keyfreq-show)
  #+END_SRC
* PDFs
You also need to compile ~epdfinfo~ in Emacs for this to work.
Run it with ~(pdf-tools-install)~.
#+begin_src emacs-lisp :tangle yes
(use-package pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :commands (pdf-view-mode)
  :custom (pdf-tools-handle-upgrades nil)  ;; Disable automatic upgrades
  ;; :config
  ;; (pdf-tools-install :no-query)
  )
#+end_src
* Themes
  Remember to _defer_ the loading of the theme packages, otherwise the
  faces might get mixed up and look ugly.

  This function makes it easier to change themes quickly. You can bind it to a
  keychord or whatnot and use it as you wish.

  NOTE: If you want to run extra functions when changing themes,
  *you should add the function calls to the change theme function below*,
  otherwise the changes you want to happen won't take effect!
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/set-fringe-face-to-default-bg ()
  "Sets the fringe's background to the current theme's background color for the 'default face."
  (set-face-attribute 'fringe nil :background (face-attribute 'default :background)))

;; Set the fringe face function Circadian's change hook.
;; That way whenever the theme changes automatically, the fringe gets updated as
;; well.
(add-hook 'circadian-after-load-theme-hook 'auralcat/set-fringe-face-to-default-bg)

(defun auralcat/change-theme (new-theme)
  "Disables the current theme in the session, loads and enables the NEW-THEME."
  ;; This is the code Emacs uses to load themes in custom.el
  (interactive
   (list
    (intern (completing-read "Change to theme: "
     (mapcar #'symbol-name
     (custom-available-themes))))))
  (let* (
     (current-theme (car custom-enabled-themes))
     (new-theme-loaded-p (memq new-theme custom-enabled-themes)))
    (disable-theme current-theme)
    (if new-theme-loaded-p
    (enable-theme new-theme)
      (load-theme new-theme))
    ;; We should do this here because not every theme defines a fringe face and
    ;; I customized the fringe on my end.
    (auralcat/set-fringe-face-to-default-bg))
  ;; We should also set the preferred fonts here because this function does not
  ;; run any hooks.
  (auralcat--set-preferred-fonts-for-current-theme))

;; Add the hook on circadian
;; Bind it to a keychord.
(global-set-key (kbd "M-`") 'auralcat/change-theme)
  #+END_SRC
** Modus themes customization
The ~modus-themes~ come with Emacs since version 28, so you don't need
to install it through ~use-package~ anymore.

#+BEGIN_SRC emacs-lisp :tangle yes
(setopt modus-themes-deuteranopia t)
(setopt modus-themes-syntax '(green-strings)
      modus-themes-mode-line '(3d accented borderless)
      modus-themes-diffs 'desaturated)
#+END_SRC

** Zenburn
The Zenburn theme is the only theme I found so far that is _balanced
enough_ for both light and dark settings!
#+begin_src emacs-lisp :tangle yes
(use-package zenburn-theme
  :defer 1)
#+end_src
** EF Themes
Also from Prot. These look great!
#+begin_src emacs-lisp :tangle yes
(use-package ef-themes
  :defer 1)
#+end_src

* Fonts
It's better to set the fonts here instead of hard-coding them in init.el or in
the themes themselves.
** Default
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set fonts for each system if the extra ones are installed.
;; Otherwise use the system's default fonts.
(defun auralcat--set-fixed-pitch-fonts (font-name height)
  "Sets the fixed pitch fonts with the FONT-NAME family and the height as HEIGHT for both the 'default and 'fixed-pitch faces."
  (set-face-attribute 'default nil :family font-name :height height)
  (set-face-attribute 'fixed-pitch nil :family font-name :height height)
  (set-face-attribute 'org-block nil :family font-name :height height)
  (set-face-attribute 'org-table nil :family font-name :height height))

(defun auralcat--set-preferred-fonts-for-current-theme ()
  "Sets the preferred fonts for the current theme depending on the system Emacs is used in."
  (cond
   ((eq system-type 'darwin)
    (if (font-info "B612 Mono")
    (auralcat--set-fixed-pitch-fonts "B612 Mono" 90)
      (auralcat--set-fixed-pitch-fonts "Monaco" 120)))
   ((eq system-type 'gnu/linux)
    ;; Pure GTK Emacs does not play well with multiple frames.
    ;; This is not a problem for the personal setup, but I use 2 displays at work.
    (auralcat--set-fonts-for-gnu-linux 120))))

(defun auralcat--set-fonts-for-gnu-linux (height)
  "Sets fonts for GNU/Linux machines with HEIGHT."
  (if (font-info "Consolas")
      (auralcat--set-fixed-pitch-fonts "Consolas" height)
    (auralcat--set-fixed-pitch-fonts "Ubuntu Mono" height)))

;; Use Helvetica as the sans-serif font when available.
(when (font-info "Helvetica")
    (set-face-attribute 'variable-pitch nil :family "Helvetica" :height 120)
    ;; Use the Helvetica font as well for Emacs 29 mode line.
    (set-face-attribute 'mode-line nil :family "Helvetica"))

  #+END_SRC

* Graphical
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set font in graphical mode
(when (display-graphic-p)
  ;; Remove menu and scroll bars in graphical mode
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  ;; Maximize frame on startup
  (toggle-frame-maximized)
  ;; Space lines and bask in the gloriousness of graphical mode.
  (setopt line-spacing 0.2))
  #+END_SRC
* Multiplexing
This involves window and tab management.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Set rules for displaying buffers in windows.
(setopt display-buffer-alist
      ;; Press q in the Magit buffer and the window vanishes!
      `(("^magit: .*$"
     (display-buffer-reuse-mode-window display-buffer-reuse-window display-buffer-at-bottom)
     (window-height . 0.5)
     (window-parameters . ((delete-window . t)))
     )
    ("^magit-diff: .*$"
     (display-buffer-use-some-frame display-buffer-reuse-mode-window display-buffer-reuse-window)
     (reusable-frames . t)
     (window-parameters . ((delete-window . t)))
     )
    ("^magit-revision: .*$"
     (display-buffer-reuse-mode-window display-buffer-reuse-window display-buffer-use-some-frame)
     (reusable-frames . t)
     (window-parameters . ((delete-window . t)))
     )
    ;; Search buffers tend to be more useful when they're in the same frame as the code.
    ("\\(^\\*ag search text:.*\\*$\\|\\^*Occur.*\\*$\\)"
     (display-buffer-reuse-mode-window display-buffer-reuse-window)
     )
    ("^\\*Org .*Export\\*$"
     (display-buffer-reuse-window display-buffer-in-side-window)
     (window-height . 0.5)
     (window-parameters . ((delete-window . t)))
     )))
#+END_SRC
** Splitting windows
#+begin_src emacs-lisp :tangle yes
;; Set thresholds for smart splitting
(setopt split-width-threshold 160)    ; Split horizontally if window is wider than 160 columns
(setopt split-height-threshold 80)    ; Split vertically if window is taller than 80 lines

;; Use the built-in sensible splitting function
(setopt split-window-preferred-function 'split-window-sensibly)

;; Optional: Prevent really narrow windows
(setopt window-min-width 80)          ; Minimum window width
(setopt window-min-height 20)         ; Minimum window height

;; Optional: Make newly split windows more balanced
(setopt window-combination-resize t)   ; Resize windows proportionally
#+end_src

* Keybindings
** Translation keymap
The keys in my personal machine are bound to the corresponding
bindings using ~AltGr~ so this is necessary to use the Meta key on the
right button as well.

 #+BEGIN_SRC emacs-lisp :tangle yes
;; Translate the compose keys
(define-key key-translation-map (kbd "¹") (kbd "M-1"))
(define-key key-translation-map (kbd "²") (kbd "M-2"))
(define-key key-translation-map (kbd "³") (kbd "M-3"))
(define-key key-translation-map (kbd "£") (kbd "M-4"))
(define-key key-translation-map (kbd "¢") (kbd "M-5"))
(define-key key-translation-map (kbd "ð") (kbd "M-d"))
(define-key key-translation-map (kbd "ß") (kbd "M-s"))
(define-key key-translation-map (kbd "»") (kbd "M-x"))
(define-key key-translation-map (kbd "«") (kbd "M-z"))
(define-key key-translation-map (kbd "C-«") (kbd "C-M-z"))
(define-key key-translation-map (kbd "C-»") (kbd "C-M-x"))
(define-key key-translation-map (kbd "ŋ") (kbd "M-g"))
(define-key key-translation-map (kbd "<M-S-dead-grave>") (kbd "M-`"))
(define-key key-translation-map (kbd "„") (kbd "M-v"))
(define-key key-translation-map (kbd "‘") (kbd "M-S-v"))
(define-key key-translation-map (kbd "C-„") (kbd "C-M-v"))
(define-key key-translation-map (kbd "C-‘") (kbd "C-S-M-v"))
(define-key key-translation-map (kbd "æ") (kbd "M-a"))
(define-key key-translation-map (kbd "C-æ") (kbd "C-M-a"))
(define-key key-translation-map (kbd "ŧ") (kbd "M-t"))
(define-key key-translation-map (kbd "C-ŧ") (kbd "C-M-t"))
(define-key key-translation-map (kbd "Æ") (kbd "M-S-a"))
(define-key key-translation-map (kbd "°") (kbd "M-e"))
(define-key key-translation-map (kbd "C-°") (kbd "C-M-e"))
(define-key key-translation-map (kbd "đ") (kbd "M-f"))
(define-key key-translation-map (kbd "ª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "C-đ") (kbd "C-M-f"))
(define-key key-translation-map (kbd "C-ª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "”") (kbd "M-b"))
(define-key key-translation-map (kbd "’") (kbd "M-S-b"))
(define-key key-translation-map (kbd "C-”") (kbd "C-M-b"))
(define-key key-translation-map (kbd "C-’") (kbd "C-M-S-b"))
(define-key key-translation-map (kbd "©") (kbd "M-c"))
(define-key key-translation-map (kbd "C-©") (kbd "C-M-c"))
(define-key key-translation-map (kbd "C-ß") (kbd "C-M-s"))
(define-key key-translation-map (kbd "C-®") (kbd "C-M-r"))
(define-key key-translation-map (kbd "®") (kbd "M-r"))
(define-key key-translation-map (kbd "M-°") (kbd "M-S-e"))
;; C-M-number translations.
(define-key key-translation-map (kbd "⅜") (kbd "M-%"))
(define-key key-translation-map (kbd "C-⅜") (kbd "C-M-%"))
(define-key key-translation-map (kbd "¼") (kbd "M-$"))
(define-key key-translation-map (kbd "C-¼") (kbd "C-M-$"))
(define-key key-translation-map (kbd "¾") (kbd "M-#"))
(define-key key-translation-map (kbd "C-¾") (kbd "C-M-#"))
(define-key key-translation-map (kbd "½") (kbd "M-@"))
(define-key key-translation-map (kbd "C-½") (kbd "C-M-@"))
(define-key key-translation-map (kbd "¡") (kbd "M-!"))
(define-key key-translation-map (kbd "C-¡") (kbd "C-M-!"))

;; Some speed commands
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'ido-switch-buffer)
(global-set-key (kbd "M-4") 'switch-to-buffer-other-window)
(global-set-key (kbd "M-5") 'tab-bar-switch-to-tab)

(define-key comint-mode-map (kbd "M-1") 'delete-other-windows)
(define-key comint-mode-map (kbd "M-4") 'switch-to-buffer-other-window)

;; Improve the case change commands with built-in DWIM
(global-set-key (kbd "M-u") 'upcase-dwim)
(global-set-key (kbd "M-l") 'downcase-dwim)
(global-set-key (kbd "M-c") 'capitalize-dwim)

;; Resize the frame with ease
(global-set-key [M-f11] (quote toggle-frame-fullscreen))
(global-set-key [M-f10] (quote toggle-frame-maximized))

(global-set-key (kbd "M-\"") (quote abbrev-prefix-mark))

;; Scroll other windows' pages easier
(define-key global-map (kbd "M-]") 'scroll-other-window)
(define-key global-map (kbd "M-[") 'scroll-other-window-down)

;; Mapping AltGr-d to delete-other-windows,
;; Another symbol I don't use often.
(global-set-key [240] (quote delete-other-windows))

;; Map the Home and End keys to go to the beginning and end of the buffer
(global-set-key [home] (quote beginning-of-buffer))
(global-set-key [end] (quote end-of-buffer))

;; Move to beginning of line or indentation
(defun back-to-indentation-or-beginning (args)
  (interactive "P")
  (if (= (point) (progn (back-to-indentation) (point)))
      (beginning-of-line args)))

;; We need this to get back to the beginning of the indentation or first word of the line.
(global-set-key (kbd "C-a") (quote back-to-indentation-or-beginning))

;; Hippie-Expand: change key to M-SPC; Replace dabbrev-expand
(global-set-key "\M- " 'hippie-expand)
(global-set-key "\M-/" 'hippie-expand)

;; Use replace-string instead of query-replace in M-%
(global-set-key "\M-%" 'replace-string)
  #+END_SRC

** Personal keymap
I need these keybindings to call quick functions I use often.

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar auralcat-map
  (let ((map (make-sparse-keymap)))
    ;; Your keybindings go here.
    (define-key map (kbd "fo") #'(lambda () (find-file "~/.emacs.d/myinit.org")))
    (define-key map (kbd "fs") #'(lambda () (switch-to-buffer (get-buffer "*scratch*"))))
    (define-key map (kbd "fm") #'(lambda () (switch-to-buffer (get-buffer "*Messages*"))))
    (define-key map (kbd "j") 'jump-to-register)
    (define-key map (kbd "p") 'projectile-command-map)
    map)
  "My personal keymap.")

(global-set-key (kbd "C-\\") auralcat-map)
#+END_SRC

** Remappings
#+BEGIN_SRC emacs-lisp :tangle yes
;; I use zap-up-to-char much more than zap-to-char.
(define-key global-map (kbd "M-z") 'zap-up-to-char)
(define-key global-map (kbd "C-M-z") 'zap-to-char)
;; More navigation aids that are not bound to any key by default
(define-key global-map (kbd "M-g ,") 'goto-last-change-reverse)
(define-key global-map (kbd "M-g .") 'goto-last-change)
(define-key global-map (kbd "M-g u") 'browse-url)
#+END_SRC

** Append to buffer
Buffers are the common communication medium in Emacs. Make it easier for you to use them!
#+begin_src emacs-lisp :tangle yes
(define-key global-map (kbd "C-x x a") 'append-to-buffer)
#+end_src
* Variables
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set Fundamental mode as default mode for new buffers:
(setq-default major-mode 'fundamental-mode)
(setopt initial-major-mode 'fundamental-mode)

;; When toggling a buffer into read-only mode, activate view-mode immediately.
(setopt view-read-only t)

;; Change tab width and change tabs to spaces
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)

;; Making Emacs auto-indent
(define-key global-map (kbd "RET") 'newline-and-indent)

;; Shows trailing whitespace, if any:
(setq-default show-trailing-whitespace t)

;; Python: use python3 as default shell interpreter
(setopt python-shell-interpreter "python3")

  #+END_SRC
** Project-local variables
Disable the ~risky-variable~ check. I know what I'm doing.
This can be reverted later with ~(advice-remove)~ though.
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add 'risky-local-variable-p :override #'ignore)
#+END_SRC
* Repeat-mode maps
These are for the new ~repeat-mode~ added to Emacs 28.
First we need to enable repeat-mode globally:

#+BEGIN_SRC emacs-lisp :tangle yes
(repeat-mode 1)

;; We're also defining a macro to reduce code duplication in this config.
(defmacro auralcat/macro-make-map-for-repeat-commands (map-symbol key-commands-alist)
  (require 'cl-lib)
  `(setopt ,map-symbol
     (let ((map (make-sparse-keymap)))
       (cl-loop for (key . command) in ,key-commands-alist
    do (define-key map (kbd key) command)
    (put command 'repeat-map ',map-symbol))
       map)))
#+END_SRC

** General
#+BEGIN_SRC emacs-lisp :tangle yes
;; TODO: undo-redo is not loaded on startup through this macro. Need to figure out why.
(auralcat/macro-make-map-for-repeat-commands undo-repeat-map
     '(("u" . undo)
       ("r" . undo-redo)))

;; TODO: why are these keys not bound to scroll-up-command and scroll-down-command?
(auralcat/macro-make-map-for-repeat-commands scroll-map
     '(("n" . scroll-up-command)
       ("p" . scroll-down-command)))

(auralcat/macro-make-map-for-repeat-commands scroll-other-window-map
     '(("]" . scroll-other-window)
       ("[" . scroll-other-window-down)))

(auralcat/macro-make-map-for-repeat-commands control-meta-navigation-map
     '(("n" . forward-list)
       ("p" . backward-list)
       ("a" . beginning-of-defun)
       ("e" . end-of-defun)
       ("f" . forward-sexp)
       ("b" . backward-sexp)))

(auralcat/macro-make-map-for-repeat-commands goto-change-map
     '(("." . goto-last-change)
       ("," . goto-last-change-reverse)))
#+END_SRC

** Org-mode repeat maps
#+BEGIN_SRC emacs-lisp :tangle yes
(auralcat/macro-make-map-for-repeat-commands org-link-repeat-map
     '(("n" . org-next-link)
       ("p" . org-previous-link)))

(auralcat/macro-make-map-for-repeat-commands org-heading-navigation-map
     '(("n" . org-next-visible-heading)
       ("p" . org-previous-visible-heading)
       ("f" . org-forward-heading-same-level)
       ("b" . org-backward-heading-same-level)))
#+END_SRC

** Markdown repeat maps
#+BEGIN_SRC emacs-lisp :tangle yes
(auralcat/macro-make-map-for-repeat-commands markdown-heading-repeat-map
     '(("n" . markdown-outline-next)
       ("p" . markdown-outline-previous)
       ("f" . markdown-outline-next-same-level)
       ("b" . markdown-outline-previous-same-level)))
#+END_SRC

* Custom functions
** Auto create missing directories
Taken from https://emacsredux.com/blog/2022/06/12/auto-create-missing-directories/
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun er-auto-create-missing-dirs ()
  (let ((target-dir (file-name-directory buffer-file-name)))
    (unless (file-exists-p target-dir)
      (make-directory target-dir t))))

(add-to-list 'find-file-not-found-functions #'er-auto-create-missing-dirs)
   #+END_SRC

** Copy text from prog-modes into Markdown code block
This is useful when you want to copy some lines of code from Emacs to paste on Github comments or in a chat tool. That way you don't have to type `s and paste the text in there. Makes the process much smoother and faster.

#+NAME: auralcat/prog-copy-region-in-named-gfm-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-named-gfm-code-block (beg end)
  "Copy the selected region inside a named GFM code block with the major mode name to the clipboard."
  (interactive (if (use-region-p)
       (list (region-beginning) (region-end))
     (list nil nil)))
  (let ((major-mode-basename (string-replace "-mode" "" (prin1-to-string major-mode)))
    (region-raw-string (buffer-substring-no-properties beg end)))
      (kill-new (format "```%s
%s
```" major-mode-basename region-raw-string))
  (message (format "Region copied to clipboard inside GFM %s code block!" major-mode-basename))))
#+END_SRC

The ~diff~ block is handy when you want to highlight a single line of code when explaining things in GitHub.

#+NAME: auralcat/prog-copy-region-in-diff-md-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-diff-gfm-code-block (beg end)
  "Copy the selected region inside a GFM `diff` code block to the clipboard.

   This is useful to highlight a single line in your message or comment."
  (interactive (if (use-region-p)
       (list (region-beginning) (region-end))
     (list nil nil)))
  (kill-new (format "```%s
%s
```" "diff" (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside GFM `diff` code block!"))
#+END_SRC

We can also create the special ~suggestion~ GFM code block here. This is interpreted by GitHub as a code suggestion that the author of the pull request can incorporate into the branch with a single click. This makes the process of applying suggestions much faster and painless.

#+NAME: auralcat/prog-copy-region-in-suggestion-gfm-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-suggestion-gfm-code-block (beg end)
  "Copy the selected region inside a `suggestion` GFM code block with the major mode name to the clipboard.

  This block is interpreted by GitHub as a suggestion to the pull request, so the author or maintainers can apply the suggestions to the branch with a single click."
  (interactive (if (use-region-p)
       (list (region-beginning) (region-end))
     (list nil nil)))
  (kill-new (format "```%s
%s
```" "suggestion" (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside a `suggestion` GFM code block!"))
#+END_SRC

For other cases where GFM code blocks don't get interpreted correctly, we can use the plain fenced Markdown code block:

#+NAME: auralcat/prog-copy-region-in-plain-md-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-plain-md-code-block (beg end)
  "Copy the selected region inside a plain Markdown code block."
  (interactive (if (use-region-p)
       (list (region-beginning) (region-end))
     (list nil nil)))
  (kill-new (format "```
%s
```"  (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside plain Markdown code block!"))
#+END_SRC
** Open a new line before point
Just like O in Vim.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/open-line (args)
  (interactive "p")
  "Inserts a new line before the line where point is.
   Keeps point in the same column as it was before."
  (save-excursion
    (move-beginning-of-line 1)
    (newline args)))

(global-set-key (kbd "C-o") 'auralcat/open-line)
#+END_SRC
** Copy text from whole buffer
I copy and paste the contents of the entire buffer pretty often. And I wanna do that with a single keystroke.
Pressing M-< C-x h M-w is too much for me.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun copy-whole-buffer ()
  "Copy the entire buffer to the kill ring."
  (interactive)
  (kill-new (buffer-string))
  (message "✧*｡٩(ˊᗜˋ*)و✧*｡ Buffer copied to clipboard! ✧*｡٩(ˊᗜˋ*)و✧*｡"))

;; Gonna use the function keys for that.
(global-set-key (kbd "<f5>") 'copy-whole-buffer)
#+END_SRC
* Speed dial files
# TODO: If we add more files in here, we can create a generic function
# to speed dial through files!

** This config file
We need to have access to this file on speed dial.
This is a huge quality of life improvement!
#+begin_src emacs-lisp :tangle yes
(defun auralcat/open-config-file ()
  "Opens your Emacs configuration file."
  (interactive)
  ;; This is how you check if a buffer is opened.
  (if (buffer-live-p (get-buffer "myinit.org"))
      (switch-to-buffer "myinit.org")
    ;; If the buffer is not open, visit the file
    (find-file "~/.emacs.d/myinit.org")))

;; We also need to bind this to a key
(global-set-key (kbd "M-g e") 'auralcat/open-config-file)
(global-set-key (kbd "M-g M-e") 'auralcat/open-config-file)
#+end_src
** Secrets file
#+begin_src emacs-lisp :tangle yes
(defun auralcat/open-secrets-file ()
  "Opens your Emacs secrets file."
  (interactive)
  ;; This is how you check if a buffer is opened.
  (if (buffer-live-p (get-buffer ".emacs.secrets"))
      (switch-to-buffer ".emacs.secrets")
    ;; If the buffer is not open, visit the file
    (find-file "~/.emacs.secrets")))

;; We also need to bind this to a key
(global-set-key (kbd "M-g s") 'auralcat/open-secrets-file)
(global-set-key (kbd "M-g M-s") 'auralcat/open-secrets-file)
#+end_src

* Mode Line
** VC mode customizations
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add #'vc-git-mode-line-string :filter-return #'my-replace-git-status)
(defun my-replace-git-status (tstr)
  (let* ((tstr (replace-regexp-in-string "Git" "" tstr))
     (first-char (substring tstr 0 1))
     (rest-chars (substring tstr 1)))
    (cond
     ((string= ":" first-char) ;;; Modified
      (replace-regexp-in-string "^:" "⚡️" tstr))
     ((string= "-" first-char) ;; No change
      (replace-regexp-in-string "^-" "✔️" tstr))
     (t tstr))))
#+END_SRC
** Custom code
[[https://github.com/rnkn/olivetti/issues/39#issuecomment-660606677][Source]]
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mode-line-align (left right)
  "Return a string with LEFT and RIGHT at the edges of the
  current window."
  (format (format "%%s %%%ds" (- (window-total-width) (length left) 2))
      left right))

(defun get-theme-color (state fallback)
  "Get color from current theme if available, otherwise use fallback."
  (cond
   ;; Modus themes
   ((or (member 'modus-operandi custom-enabled-themes)
    (member 'modus-vivendi custom-enabled-themes))
    (pcase state
      ('normal (face-foreground 'modus-themes-fg-blue nil t))
      ('insert (face-foreground 'modus-themes-fg-green nil t))
      ('visual (face-foreground 'modus-themes-fg-yellow nil t))
      ('emacs (face-foreground 'modus-themes-fg-magenta nil t))
      ('motion (face-foreground 'modus-themes-fg-cyan nil t))
      ('operator (face-foreground 'modus-themes-fg-red nil t))
      ('replace (face-foreground 'modus-themes-fg-red-warmer nil t))
      (_ fallback)))

   ;; EF themes
   ((string-match-p "^ef-" (symbol-name (car custom-enabled-themes)))
    (pcase state
      ('normal (face-foreground 'ef-themes-heading-4 nil t)) ;; blue-ish in most EF themes
      ('insert (face-foreground 'ef-themes-heading-2 nil t)) ;; green-ish in most EF themes
      ('visual (face-foreground 'ef-themes-heading-3 nil t)) ;; yellow-ish in most EF themes
      ('emacs (face-foreground 'ef-themes-heading-1 nil t))  ;; purple-ish in most EF themes
      ('motion (face-foreground 'ef-themes-heading-5 nil t))
      ('operator (face-foreground 'ef-themes-heading-6 nil t))
      ('replace (face-foreground 'ef-themes-heading-7 nil t))
      (_ fallback)))

   ;; Default fallback
   (t fallback)))

;; Define custom faces for different Evil states with your preferred colors
(defface evil-normal-state-face
  '((t (:foreground "blue" :weight bold)))
  "Face for Evil normal state indicator in mode line.")

(defface evil-insert-state-face
  '((t (:foreground "green" :weight bold)))
  "Face for Evil insert state indicator in mode line.")

(defface evil-visual-state-face
  '((t (:foreground "yellow" :weight bold)))
  "Face for Evil visual state indicator in mode line.")

(defface evil-emacs-state-face
  '((t (:foreground "purple" :weight bold)))
  "Face for Evil emacs state indicator in mode line.")

(defface evil-motion-state-face
  '((t (:foreground "cyan" :weight bold)))
  "Face for Evil motion state indicator in mode line.")

(defface evil-operator-state-face
  '((t (:foreground "red" :weight bold)))
  "Face for Evil operator state indicator in mode line.")

(defface evil-replace-state-face
  '((t (:foreground "brown" :weight bold)))
  "Face for Evil replace state indicator in mode line.")

;; Function to generate colored Evil mode tag
(defun colored-evil-mode-line-tag ()
  "Return a colored Evil mode line tag based on current state."
  (if (and (featurep 'evil) (bound-and-true-p evil-mode))
    (let* ((state (if evil-mode
            (if (boundp 'evil-state) evil-state nil)
          nil))
     (state-info
      (cond
       ((eq state 'normal)
        (cons 'normal " [NORMAL] "))
       ((eq state 'insert)
        (cons 'insert " [INSERT] "))
       ((eq state 'visual)
        (cons 'visual " [VISUAL] "))
       ((eq state 'emacs)
        (cons 'emacs " [EMACS] "))
       ((eq state 'motion)
        (cons 'motion " [MOTION] "))
       ((eq state 'operator)
        (cons 'operator " [OPERATOR] "))
       ((eq state 'replace)
        (cons 'replace " [REPLACE] "))
       (t (cons nil ""))))
     (state-type (car state-info))
     (tag (cdr state-info)))
    (if state-type
    (let ((color (get-theme-color state-type
                     (face-foreground
                      (intern (format "evil-%s-state-face" state-type))
                      nil t))))
      (propertize tag 'face `(:foreground ,color :weight bold)))
      ""))))

(setopt auralcat/mode-line-left-side
      '(
    " " mode-line-buffer-identification
    " " mode-line-modified
    (:eval (colored-evil-mode-line-tag))  ;; Add the colored Evil state indicator
    " " mode-name
    " " mode-line-position
    " " (vc-mode vc-mode)
    ))

(setopt auralcat/mode-line-right-side
      (list minor-mode-alist
    " " mode-line-misc-info
    " " mode-line-end-spaces))

;; This needs to be setq-default to make every buffer use this mode line format.
(setq-default mode-line-format
      '("%e" (:eval (mode-line-align
     (format-mode-line
      auralcat/mode-line-left-side)
     (format-mode-line
      auralcat/mode-line-right-side)))))
#+END_SRC

* Cursor
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/get-face-foreground-color (face)
  "Return the hex code from the specified FACE."
  (face-attribute face :foreground))

(add-hook 'circadian-after-load-theme-hook #'(lambda (theme) (auralcat--set-preferred-fonts-for-current-theme)))
(add-hook 'after-init-hook #'(lambda () (auralcat--set-preferred-fonts-for-current-theme)))

(setq-default blink-cursor-blinks 0)
(setq-default blink-cursor-interval 0.6)
(setq-default blink-cursor-delay 0.2)
#+END_SRC
