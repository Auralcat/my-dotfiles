-*- mode: org-english-*-
#+TITLE: Emacs configuration file
#+AUTHOR: Auralcat
#+DATE: 2017:05:17
#+STARTUP: overview

* Personal info
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Load from external file.
(load "~/.emacs.secrets")
  #+END_SRC

* Save command history
  It's a good idea to save the previous commands' history, for a couple reasons:
  - Check the complex commands you use most often and improve your workflow
    based on that
  - Store cumbersome commands for specific situations that don't
    appear too often

    #+BEGIN_SRC emacs-lisp :tangle yes
(setopt history-length 1024)
(setopt history-delete-duplicates t)
(setopt savehist-mode 1)
    #+END_SRC

* Enabled complex commands
Emacs comes with some commands disabled by default to not confuse new users.
So I need to enable them like this to not get pestered by it when trying to use them.

#+BEGIN_SRC emacs-lisp :tangle yes
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC
* Browse-url
  This is a command to open the browser for the URL at point.
  #+begin_src emacs-lisp :tangle yes
  (setopt browse-url-browser-display nil
    browse-url-browser-function 'browse-url-default-browser
    browse-url-firefox-program "firefox")
  #+end_src
* Bookmarks
  It's a quicker way to navigate through files you visit often.
  #+BEGIN_SRC emacs-lisp :tangle yes
(setopt bookmark-default-file "~/emacs-bookmarks")
;; Every time bookmarks are changed, save them
(setopt bookmark-save-flag 1)
  #+END_SRC
* Occur
Occur is useful for when you want to keep a list of code points of interest in a
given buffer or a set of buffers with ~multi-occur-in-matching-buffers~. I was
used to doing this multi search through ~ibuffer~, but you can call this function
from ~M-x~ and get the same result if you want.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Source: https://www.reddit.com/r/emacs/comments/l9b049/comment/glheho5
(defun rename-occur-buffer ()
  "Rename *Occur* buffers more descriptively."
  (interactive) ; if you want to do it manually
  (save-excursion
    (save-match-data
      (goto-char (point-min))
      (when
      (search-forward-regexp
       "^[0-9]+ matches for \"\\(.*\\)\" in buffer: \\(.*\\)$"
       (line-end-position)
       nil)
    (rename-buffer
     (format "*Occur %s: %s*" (match-string 2) (match-string 1)))))))

(add-hook 'occur-hook #'(lambda () (occur-rename-buffer t nil)))
#+END_SRC
* Dired
  A couple customizations.
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Customize Dired list switches.
(setopt dired-listing-switches "-alh")

;; Kill selected subdir with C-M-k
(add-hook 'dired-mode-hook #'(lambda () (define-key dired-mode-map (kbd "C-M-k") 'dired-kill-subdir)))
  #+END_SRC
* Programming
** General configuration
*** LSP mode
We need this nowadays.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :init
  (setopt lsp-keymap-prefix "C-c l")
  :hook ((python-mode
      ruby-mode
      web-mode
      typescript-mode
      json-mode
      cfn-mode
      terraform-mode) . lsp)
  :config
  (setopt lsp-idle-delay 0.5
    lsp-enable-symbol-highlighting t
    lsp-enable-snippet nil  ;; Not supported by company capf, which is the recommended company backend
    lsp-completion-enable t
    ;; Python LSP configuration
    lsp-pyls-plugins-flake8-enabled nil
    lsp-pyls-plugins-black-enabled t
    lsp-pylsp-plugins-ruff-enabled t
    lsp-pyls-plugins-rope-autoimport-enabled t
    ;; Terraform LSP configuration
    lsp-terraform-ls-prefill-required-fields t
    lsp-enable-links t
    lsp-semantic-tokens-honor-refresh-requests t)
  (lsp-register-custom-settings
   '(("pyls.plugins.pyls_black.enabled" t t)
     ("pyls.plugins.pyls_isort.enabled" t t)
     ("pylsp.plugins.rope_autoimport.enabled" t t)
     ("pylsp.plugins.rope_completion.enabled" t t)))
  :commands lsp)

(use-package lsp-ui
  :config (setopt lsp-ui-sideline-show-hover t
        lsp-ui-sideline-delay 0.5
        lsp-ui-doc-delay 5
        lsp-ui-sideline-ignore-duplicates t
        lsp-ui-doc-position 'bottom
        lsp-ui-doc-alignment 'frame
        lsp-ui-doc-header nil
        lsp-ui-doc-include-signature t
        lsp-ui-doc-use-childframe t)
  :commands lsp-ui-mode)
#+end_src
**** Web mode indentation fix
~web-mode~ has its own indentation configuration. We shouldn't use the
LSP indentation, it messes things up. And that brings a lot of pain
and suffering when developing with stuff like Vue and Svelte.

#+begin_src emacs-lisp :tangle yes
(add-hook 'web-mode-hook
          (lambda ()
            (setq-local lsp-enable-indentation nil)))
#+end_src

*** DAP mode
This goes hand in hand with ~lsp-mode~, since it implements the Debug
Adapter Protocol from the LSP specification.

Seriously, this will make your life easier when debugging things.

#+begin_src emacs-lisp :tangle yes
(use-package dap-mode
  ;; Comment/uncomment the config below if you want all UI panes to be hidden by default!
  :custom
  (lsp-enable-dap-auto-configure nil)
  :config
  (dap-ui-mode 1)

  :config
  ;; Set up Node debugging
  (require 'dap-python)
  ;; You need to install debugpy first.
  ;; pip install "debugpy"
  (setopt dap-python-debugger 'debugpy))

(define-key lsp-mode-map (kbd "C-c l d") 'dap-hydra)
#+end_src

*** Manual customization
#+BEGIN_SRC emacs-lisp :tangle yes
;; Manual completion for you.
(define-key prog-mode-map (kbd "M-<return>") 'dabbrev-expand)

;; Save automatically when visiting source code files.
(add-hook 'prog-mode-hook #'(lambda () (auto-save-visited-mode 1)))

(defun prog-mode-tweaks ()
  ;; Set line number mode and column number mode for code files
  (display-line-numbers-mode)
  (setopt fill-column 80))

(add-hook 'prog-mode-hook 'prog-mode-tweaks)
#+END_SRC
*** Highlight TODO
This is a package to highlight TODO keywords in any given mode, not just on ~org-mode~.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hl-todo
  :hook ((prog-mode . hl-todo-mode)))
#+END_SRC
*** Highlight line
This does not require any extra packages as of Emacs 21. Great thing to know where you are at a given point when programming.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC
*** Highlight-numbers mode
    Sets font lock faces to numbers in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-numbers
  :after (prog-mode)
  :defer t
  :config
  (add-hook 'prog-mode-hook 'highlight-numbers-mode))
    #+END_SRC
*** Indent-bars mode
A new package on the block that is faster than ~highlight-indentation~.
#+begin_src emacs-lisp :tangle yes
(use-package indent-bars
  :hook ((prog-mode) . indent-bars-mode))
#+end_src
*** Editorconfig
    Helps developers define and maintain consistent coding styles
    between different editors and IDEs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :after (prog-mode)
  :defer t
  :config
  (editorconfig-mode 1))
    #+END_SRC
*** Diff-Highlight
    Highlights the changed content in buffer.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :defer t)
    #+END_SRC
*** Rainbow Delimiters
    Highlight parentheses, brackets and braces according to their
    depth.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :after (prog-mode)
  :defer t
  :init
  ;; Add this to prog-mode
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'slime-repl-mode-hook #'rainbow-delimiters-mode))
    #+END_SRC
*** Git Gutter
    Shows (and enables you to navigate between) parts of the code
    which where changed comparing to the current revision in a
    version-controlled project.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-gutter
  :when window-system
  :hook ((prog-mode . git-gutter-mode))
  :diminish ""
  :config
  (use-package git-gutter-fringe
    :after (git-gutter)
    :defer t
    :init
    (require 'git-gutter-fringe)
    (when (fboundp 'define-fringe-bitmap)
      (define-fringe-bitmap 'git-gutter-fr:added
    [224 224 224 224 224 224 224 224 224 224 224 224 224
     224 224 224 224 224 224 224 224 224 224 224 224]
    nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:modified
    [224 224 224 224 224 224 224 224 224 224 224 224 224
     224 224 224 224 224 224 224 224 224 224 224 224]
    nil nil 'center)
      (define-fringe-bitmap 'git-gutter-fr:deleted
    [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
    nil nil 'center))))
    #+END_SRC
** AWS CloudFormation
[2024-07-22 seg] Currently the packages available in Emacs support
linting and working with the YAML version of CFN templates out of the
box.

YAML is also easier to read and write than JSON, and also easier to maintain.
You just need to be careful with the indentation in it though.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package cfn-mode)
  (use-package flycheck-cfn
    :after (flycheck cfn-mode)
    :config
    (with-eval-after-load 'flycheck
      (add-hook 'cfn-mode-hook 'flycheck-cfn-setup)))

  (use-package cfn-mode)
#+END_SRC

** Terraform
#+begin_src emacs-lisp :tangle yes
(use-package terraform-mode
  :config
  (setopt terraform-format-on-save t))
#+end_src

** Ruby
*** Main configuration
#+BEGIN_SRC emacs-lisp :tangle yes
;; Completion for Ruby mode
(defun ruby-mode-tweaks ()
  ;; Enable flycheck
  (flycheck-mode 1))

(add-hook 'ruby-mode-hook 'ruby-mode-tweaks)
#+END_SRC

*** Projectile Rails
Rails utilities for Projectile-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile-rails
  :after (projectile)
  :defer t
  :init
  (add-hook 'ruby-mode-hook 'projectile-rails-mode))
#+END_SRC
*** Bundler
Interact with Bundler from Emacs
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package bundler
  :defer t)
#+END_SRC
*** Rcodetools
This is a gem that you can install and copy the ~rcodetools.el~ file to your ~load-path~ to add bindings to Emacs.
When you run ~comment-dwim~ twice in a ~ruby-mode~ buffer, it will output a comment like this: ~# =>~
Then you can run the ~xmp~ function to have Ruby evaluate that snippet of code right in your buffer, without having to run ~inf-ruby~.

To install the ~rcodetools~ gem, run:
#+BEGIN_SRC shell :eval never
gem install rcodetools
#+END_SRC

Then copy ~rcodetools.el~ from the gem directory to your Emacs' ~load-path~:
#+BEGIN_SRC shell :eval never
cp /path/to/rcodetools.el ~/emacs.d/manual-packages/rcodetools.el
#+END_SRC

After that, we can require it in our configuration:
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ruby-mode
    :mode "\\.rb\\'"
    :init
    (add-to-list 'load-path "~/my-dotfiles/.emacs.d/manual-packages")
    :config
    (require 'rcodetools)
    (define-key ruby-mode-map (kbd "C-c C-c") 'xmp))
#+END_SRC

*** Robe
Robe provides references for code evaluated in runtime. It unpacks all
the metaprogramming definitions that you may have in the project and
points you to where the original code is defined.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package robe
  :hook ((ruby-mode) . robe-mode))
#+END_SRC
*** Rspec-mode
I use ~RSpec~ quite a lot now.
#+begin_src emacs-lisp :tangle yes
(use-package rspec-mode
  :hook ((after-init) . 'inf-ruby-switch-setup)
  :config
  (eval-after-load 'rspec-mode
    '(rspec-install-snippets)))
#+end_src
*** REPL
#+begin_src emacs-lisp :tangle yes
(define-key ruby-mode-map (kbd "C-c SPC") 'ruby-send-buffer)
#+end_src
** General configuration
When you are working in the comint/REPL buffer, you normally want the
output to be visible at all times.

We need to make it scroll to the bottom of the comint buffer
automatically.

#+begin_src emacs-lisp :tangle yes
(setopt comint-scroll-to-bottom-on-input t)
(setopt comint-scroll-to-bottom-on-output t)
(setopt comint-move-point-for-output t)
#+end_src
** Python
I'm starting to work with machine learning lately, so I'll need to set
up my Python config and brush up my Python-fu.

#+begin_src emacs-lisp :tangle yes
(use-package python-mode
  :bind (:map python-mode-map
              ("C-c SPC" . 'python-shell-send-buffer)
              ("C-x C-e" . 'python-shell-send-statement)
              ))
#+end_src
*** python-pytest
Run your Python unit tests straight from Emacs.
Note that there are two packages for running tests from Python
projects in MELPA: ~python-pytest~ and simply ~pytest~.
~python-pytest~ lets you run tests in a "do what I mean" (DWIM)
fashion, so this is why I chose it.

#+begin_src emacs-lisp :tangle yes
  (use-package python-pytest
    :after python
    :init
    (define-key python-mode-map (kbd "C-c t f") 'python-pytest-function)
    (define-key python-mode-map (kbd "C-c t t") 'python-pytest-file)
    (define-key python-mode-map (kbd "C-c t r") 'python-pytest-repeat))
#+end_src

*** Format all
Format your code with ~black~.
You will need to have the ~black~ lib installed in your Python
interpreter:
#+begin_src sh :noeval
pip3 install black
#+end_src

NOTE: Format all does not work well with Rubocop, so that's why
I'm not using it for Ruby.

#+begin_src emacs-lisp :tangle yes
(use-package format-all
  :commands format-all-mode
  :hook (python-mode . format-all-mode)
  :config
  (setq-default format-all-formatters
                '(("Python"     (black)))))
#+end_src
*** Poetry
~poetry~ is a Python library that is like ~bundler~ for Ruby.
It's a better approach for dependency management and isolation than
using plain ~pip~ with ~virtualenv~.
~poetry~ is also smart enough to create its own virtual environment to
isolate its dependencies. This means one less hurdle to work with
Python in Emacs!

#+begin_src emacs-lisp :tangle yes
(use-package poetry)
#+end_src
*** IPython with Jupyter Notebook kernel
To run the kernel with code from your project, do this:

#+begin_src sh
cd ~/your-project-dir
ipython kernel
#+end_src

And we also add a function to either use IPython or the first running
Jupyter Notebook Python kernel.
#+begin_src emacs-lisp :tangle yes
(defun jupyter-notebook-running-p ()
  "Check if a Jupyter notebook is running."
  (string-match-p "http://\\(localhost\\|127.0.0.1\\):[0-9]+"
                  (shell-command-to-string "jupyter notebook list")))

(defun auralcat/run-python ()
  (interactive)
  "Runs IPython if no Jupyter Notebook instance is running.
Otherwise, use the running Jupyter Notebook kernel."
  (if (jupyter-notebook-running-p)
      (setopt python-shell-interpreter "jupyter"
            python-shell-interpreter-args "console --existing --simple-prompt")
    (setopt python-shell-interpreter "ipython"
          python-shell-interpreter-args "--simple-prompt"))
  (run-python))

;; Need this to have the Python shell scroll results to the bottom
(add-hook 'inferior-python-mode-hook
          (lambda ()
            (setopt comint-move-point-for-output t)))
#+end_src

** Elixir
*** Main configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package elixir-mode
  :defer t
  :config
  (define-key elixir-mode-map (kbd "C-c C-l") 'inf-elixir-send-line)
  (define-key elixir-mode-map (kbd "C-c C-r") 'inf-elixir-send-region))

(add-hook 'elixir-mode-hook 'ruby-mode-tweaks)
#+END_SRC
*** Mix
A wrapper around Elixir's ~mix~ for Emacs
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mix
  :config
  (define-prefix-command 'elixir-mix-map)
    (define-key 'elixir-mix-map "t" 'auralcat/mix-test)
    (define-key 'elixir-mix-map (kbd "SPC") 'auralcat/mix-test-current-buffer)
    (define-key 'elixir-mix-map "." 'auralcat/mix-test-current-test)
    (define-key 'elixir-mix-map "c" 'mix-compile)
    (define-key 'elixir-mix-map "x" 'mix-execute-task)
    (define-key 'elixir-mix-map "w" 'auralcat/mix-test-watch-current-buffer)
    (define-key 'elixir-mix-map (kbd "C-,") 'mix-last-command))

  (add-hook 'elixir-mode-hook #'(lambda ()
         (local-set-key (kbd "C-,") 'elixir-mix-map)))

;; Wrappers around mix-test functions to use the umbrella app flag when necessary.
(defun auralcat/mix-test (prefix)
  "A wrapper around mix-test to pick up umbrella apps automatically."
  (interactive "P")
  (if (mix--umbrella-apps)
      (mix-test prefix t)
      (mix-test prefix)))

(defun auralcat/mix-test-current-test (prefix)
  "A wrapper around mix-test-current-test to pick up umbrella apps automatically."
  (interactive "P")
  (if (mix--umbrella-apps)
      (mix-test-current-test prefix t)
      (mix-test-current-test prefix)))

(defun auralcat/mix-test-current-buffer (prefix)
  "A wrapper around mix-test-current-buffer to pick up umbrella apps automatically."
  (interactive "P")
  (if (mix--umbrella-apps)
      (mix-test-current-buffer prefix t)
      (mix-test-current-buffer prefix)))

(defun auralcat/mix-test-watch-current-buffer (prefix)
  "Runs mix test.watch for the current buffer and respects umbrella app strucuture."
  (interactive "P")
  (mix--start
   "test"
   (format "test.watch --seed 0 --max-failures 1 %s" (kill-new (expand-file-name (buffer-file-name))))
   (mix--find-closest-mix-file-dir (expand-file-name (buffer-file-name)))
   prefix))
#+END_SRC

** YAML
*** Main configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :hook ((yaml-mode . display-line-numbers-mode)
     (yaml-mode . hl-line-mode)))
#+END_SRC
*** Indent-tools
Necessary to work in a sane way with YAML files.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package indent-tools
  :hook ((yaml-mode . indent-tools-minor-mode)))
#+END_SRC
** Vue.js
For Vue, we can use ~web-mode~. It's smart enough to work with multiple frameworks, so we just need to add it to ~auto-mode-alist~ here.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'auto-mode-alist '("\\.vue\\'"  . web-mode))
#+END_SRC
** Typescript
#+begin_src emacs-lisp :tangle yes
(setopt typescript-indent-level 2)
#+end_src
** Svelte
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.svelte\\'"  . web-mode))
  ;; We want to use ESLint to check our syntax and stuff.
  ;; To have eslint work, you'll need to have a .eslintrc file in your project root.
  (eval-after-load 'flycheck
    '(flycheck-add-mode 'javascript-eslint 'web-mode))
  (add-hook 'web-mode-hook 'flycheck-mode)
#+END_SRC
** JSON
Turns out that the built-in ~electric-pair-mode~ behaves better than ~smartparens~ when you're writing JSON.
#+begin_src emacs-lisp :tangle yes
(use-package json
  :config
  (setopt js-indent-level 2))
#+end_src
** Lisp
Some Lisp configuration to make it easier to use it.
#+BEGIN_SRC emacs-lisp :tangle yes
(setopt lisp-indent-function 'common-lisp-indent-function)
(setopt lisp-indent-offset 2)
#+END_SRC
* Macros
  #+BEGIN_SRC emacs-lisp :tangle yes
;; To save a macro, record it with C-x ( (start) and C-x ) (stop),
;; give it a name with C-x C-k n (C-k is for maKro) and
;; insert it in this file with insert-kbd-macro.
;; Then you execute it mapping it to a key!

;; This package allows you to override a couple functions.
(use-package noflet)
(lambda (&optional arg) "Extracts a variable from an it clause and puts in a let statement." (interactive "p") (kmacro-exec-ring-item (quote ([100 100 134217745 134217729 112 99 87 108 101 116 40 58 25 escape 102 61 50 120 67 123 25 escape 86 61 15 15 48 119] 0 "%d")) arg))

;; Adds a byebug line to Ruby code
(fset 'auralcat/kmacro-ruby/add-byebug-line
      (kmacro-lambda-form [?O ?b ?y ?e ?b ?u ?g escape return] 0 "%d"))

(fset 'auralcat/kmacro-ruby-clone-method
      (lambda (&optional arg) "Clones a def method in Ruby." (interactive "p") (kmacro-exec-ring-item (quote ([86 125 121 103 118 escape 112] 0 "%d")) arg)))

(fset 'auralcat/kmacro-search-git-conflict-string
      (lambda (&optional arg) "Searches for a Git conflict string." (interactive "p") (kmacro-exec-ring-item (quote ([134217747 94 91 60 61 62 93 13] 0 "%d")) arg)))

(fset (quote sample-macro)
      (lambda (&optional arg) "Sample description" (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-exec-ring-item (quote ([100 87 65 32 35 32 65 110 111 116 104 101 114 32 109 97 99 114 111 32 99 97 108 108 46 escape 134217730 return 112 45] 0 "%d")) arg)
      )
    (undo-boundary)
    ))

;; Some macros to adjust Ruby blocks
(fset 'auralcat/kmacro-ruby-move-defun-backward
      (lambda (&optional arg) "Moves a DEF block backwards in the class definition." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-exec-ring-item (quote ([26 167772166 23 134217820 16 4 134217820 4 2 134217730 16 return 25 return 134217730 26] 0 "%d")) arg)
      )
    (undo-boundary)
    ))

(fset 'auralcat/kmacro-ruby-move-block-forward
      (lambda (&optional arg) "Moves a Ruby block forward in the current nesting level." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-lambda-form [?\C-z ?\C-  ?\C-\M-n ?\C-e ?\C-w ?\C-\M-n ?\C-m ?\C-/ ?\C-e ?\C-m ?\C-m ?\C-y ?\C-u ?\C-  ?\C-  ?\C-k ?\C-k ?\C-i ?\C-z] 0 "%d")
      )
    (undo-boundary)
    )
      )

;; Removes a Ruby block wrapping another block.
(fset 'auralcat/kmacro-ruby-block-vanish
      (kmacro-lambda-form [?m ?m ?% ?d ?d ?\' ?m ?d ?d ?\C-x ?\C-x ?=] 0 "%d"))

;; Remove links in an Org entry
(fset 'auralcat/kmacro-org-remove-link
      (kmacro-lambda-form [?d ?s ?\] ?d ?f ?\] ?d ?s ?\]] 0 "%d"))

;; Copy the link at point in Org mode buffers
(fset 'org-copy-link-at-point
   (kmacro-lambda-form [?\C-c ?\C-l ?\C-  ?\C-a ?\M-w return return] 0 "%d"))

;; Paste the content from the kill ring into the next and previous lines
(fset 'auralcat/kmacro-yank-content-into-next-line
      (lambda (&optional arg) "Paste the content from the kill ring into the next line." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-lambda-form [?\C-z return ?\C-p ?\C-y ?\C-a ?\C-n ?\C-z] 0 "%d"))
    (undo-boundary)))

(fset 'auralcat/kmacro-yank-content-into-previous-line
      (lambda (&optional arg) "Paste the content from the kill ring into the previous line." (interactive "p")
    (undo-boundary)
    (noflet ((undo-boundary ()))
      (kmacro-lambda-form [?\C-z ?\C-e return ?\C-y ?\C-a ?\C-p ?\C-z] 0 "%d"))
    (undo-boundary)))

  #+END_SRC

** General
#+BEGIN_SRC emacs-lisp :tangle yes
;; Trim questions dump text from Udemy.
;; You need to pull an `occur` buffer first.
(defalias 'auralcat/udemy-trim-question-explanation
   (kmacro "M-o C-s E x p l a n a t i o n <return> C-a C-SPC M-o n M-o C-w C-l M-o g M-o C-s C-w C-w <return> M-o C-s C-s C-a"))

(defalias 'auralcat/udemy-format-question-org-headings
   (kmacro "C-c @ M-q C-n C-d C-p C-c C-n"))


#+END_SRC

** Writing modes
#+BEGIN_SRC emacs-lisp :tangle yes
(defalias 'auralcat/kmacro-markdown-wrap-region-code
   (kmacro "C-w ` C-y C-x C-x C-b C-SPC C-SPC"))

(defalias 'auralcat/kmacro-markdown-insert-header-same-level
   (kmacro "C-e <return> <return> C-c C-t h"))

(defalias 'auralcat/kmacro-markdown-insert-header-nest-one-level
   (kmacro "C-e <return> <return> C-c C-t h M-<right> C-e"))

;; Not really a macro but behaves like one.
(defun auralcat/kmacro-markdown-convert-list-region (arg)
  "Converts a region to a list."
  (interactive "p")
  (apply-macro-to-region-lines (region-beginning) (region-end) "- "))
#+END_SRC

** Elixir
#+BEGIN_SRC emacs-lisp :tangle yes
;; Changes a one-line function like:
;; def something(foo), do: "yay!"
;;
;; to:
;;
;; def something(foo) do
;;   "yay!"
;; end
(fset 'auralcat/elixir-change-one-line-function-to-multiline
      (kmacro-lambda-form [?f ?: ?F ?, ?x ?E ?x ?i return escape ?o ?e ?n ?d return escape ?\M-a return] 0 "%d"))

;; Calls IEx.pry in the line above the cursor.
(fset 'auralcat/elixir-iex-pry
      (kmacro-lambda-form [?O ?r ?e ?q ?u ?i ?r ?e ?  ?I ?E ?x ?\; ?  ?I ?E ?x ?. ?p ?r ?y escape] 0 "%d"))
#+END_SRC
** Ruby
#+BEGIN_SRC emacs-lisp :tangle yes
(defalias 'auralcat/kmacro-ruby-extract-region-to-rspec-before-each-block
   (kmacro "C-w C-d TAB C-r d e s RET C-n TAB RET C-p TAB b e f o r e ( : e a c h C-f SPC d o RET C-y C-n RET C-r d e s RET C-M-n C-x r SPC r C-M-p C-s i t RET C-a C-SPC C-x r j r Â» k i l l - m a t c h i n g - l i n e s RET C-y RET"))
#+END_SRC

* Mac OS
  #+BEGIN_SRC emacs-lisp :tangle yes
(when (eq system-type 'darwin) ;; mac specific settings
  ;; Use bigger fonts because of that Retina display
  (if (member "Monofur" (font-family-list))
      (set-face-attribute (quote default) nil :font "Monofur" :height 120)
    (set-face-attribute (quote default) nil :font "Monaco" :height 120))
  ;; Map Command to Meta
  (setopt mac-command-modifier 'meta)
  ;; Map Option to Control (I know, smaller key, that's what we have for now. :/)
  (setopt mac-option-modifier 'control)
  ;; Map Control key in OS X to Super
  (setopt mac-control-modifier 'super)
  ;; Map Fn key in OS X to Hyper
  (setopt ns-function-modifier 'hyper)
  ;; Point the executables in Mac OS to Emacs.
  (add-to-list 'exec-path "/usr/local/bin/")
  ;; Enable EPA
  (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))

  ;; Use Emacsclient in OS X
  (setopt server-socket-dir (format "/tmp/emacs%d" (user-uid))))
  #+END_SRC

* Environment Customizations
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Take out unused stuff.
(setopt tool-bar-mode nil
      tooltip-mode nil)

;; I don't need the startup screen either.
;; Drop me straight into the scratch buffer.
(setopt inhibit-startup-screen t)

;; Remove the menu bar in terminal mode
(when (not (display-graphic-p))
  (menu-bar-mode -1))

;; Display things faster in the GUI. You might have some weird issues if you
;; do some aggressive scrolling in big files though.
(setopt redisplay-dont-pause t)

;; Sentences end with single spaces for me.
(setopt sentence-end-double-space nil)

;; Set locale to Brazilian Portuguese
(set-locale-environment "pt_BR.UTF-8")

;; Change window title
(setopt frame-title-format (format "%s %s - %s" (nth 1 (split-string (emacs-version)))
           (nth 2 (split-string (emacs-version)))
           (system-name)))

;; Add frame margins. This makes things more pleasant to read.
(setopt default-frame-alist '((internal-border-width . 20)))

;; A small performance improvement
(setopt redisplay-dont-pause t)

;; Since I work only with left-to-right languages, we can set it like this.
(setopt bidi-paragraph-direction 'left-to-right)

;; I don't like lockfiles
(setopt create-lockfiles nil)

;; Starts the Emacs server for emacsclient only if it's not started already
(load "server")
(unless (server-running-p) (server-start))

;; Store all backups in a specific folder:
(setopt backup-directory-alist `(("." . "~/file-bouncer/emacs-backups")))

;; Manual themes load path
(add-to-list 'custom-theme-load-path "~/my-dotfiles/.emacs.d/manual-themes/")

;; Manual Elisp scripts load path
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/elisp-custom")
(add-to-list 'load-path "~/my-dotfiles/.emacs.d/manual-packages/")

;; Backup files by copying them
(setopt backup-by-copying t)

;; I'm too lazy to type "yes" or "no"
;; And I'm also too lazy to press y.
(defconst y-or-n-p-ret-yes-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map y-or-n-p-map)
    (define-key map [return] 'act)
    map)
  "A keymap for y-or-n-p with RET meaning \"yes\".")

(fset 'yes-or-no-p 'y-or-n-p)

;; Clean whitespace before saving a file
(add-hook 'before-save-hook 'whitespace-cleanup)

;; When making executable scripts, this function can make the new file
;; executable for you automatically.
;; You'll still need to include the shebang in the start of the file though.
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)

;; Disable it for outline-mode derivatives like Markdown and Org.
(add-hook 'text-mode-hook #'(lambda () (auto-save-visited-mode 0)))

;; Allow only one theme at a time
(setopt custom-theme-allow-multiple-selections nil)

;; Easier mark cycling, both local and global
(setopt set-mark-command-repeat-pop t)

;; Replace the built-in buffer menu with ibuffer
(global-set-key [24 2] (quote ibuffer))

;; Prevent the scratch buffer from being killed
(with-current-buffer "*scratch*"
  (emacs-lock-mode 'kill))

;; Enable auto-revert-mode
(global-auto-revert-mode t)



;; Use Bash as default shell interpreter
(setopt org-babel-sh-command "/bin/bash")
;; Get Emacs to understand your aliases
;; (setopt shell-file-name "bash")
;; For reference, this is the default value:
;; (setopt shell-command-switch "-c")
;; (setopt shell-command-switch "-ic")

;; Save last edited place in files
(require 'saveplace)
(setq-default save-place t)

;; I need a bigger kill ring.
(setopt kill-ring-max 180)

;; Use recentf-mode
(recentf-mode)
(setopt recentf-max-menu-items 100)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
  #+END_SRC
** Garbage collection tweaks
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar file-name-handler-alist-old file-name-handler-alist)

;; https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-12/msg01088.html
;; Long-story short, use select-active-regions 'only to make visual selection faster.
(setq-default gc-cons-threshold 800000
          select-active-regions 'only
          file-name-handler-alist nil
          gc-cons-percentage 0.6
          auto-window-vscroll nil
          message-log-max 16384)

(add-hook 'after-init-hook
      `(lambda ()
     (setopt file-name-handler-alist file-name-handler-alist-old
       gc-cons-threshold 80000
       select-active-regions 'only
       gc-cons-percentage 0.1)
     (garbage-collect)) t)

(setopt inhibit-compacting-font-caches t)

;; Optimize garbage collection
(use-package gcmh
  :disabled t
  :init
  (setopt gcmh-verbose nil)
  :config
  (gcmh-mode 1))
#+END_SRC
* IRC
** RCIRC general settings
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rcirc
  :hook ((rcirc-mode) . 'rcirc-track-minor-mode)
  :init
  ;; Enable logging if desired
  (setopt rcirc-log-directory "~/rcirc-logs")
  (setopt rcirc-log-flag t)

  ;; Auto-identify with NickServ (if needed)
  (setopt rcirc-auto-authenticate-flag t)

  ;; Disable automatic WHO queries.
  ;; These flood the IRC buffer.
  (setopt rcirc-who-requery-timeout nil)
  ;; Don't track user info automatically
  (setopt rcirc-auto-who-list nil))
#+END_SRC

** Color nicks
I want my colors please! ðŸ’…
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rcirc-color
  :hook ((rcirc-mode) . 'rcirc-color-mode))
#+END_SRC
** Track chats with ibuffer
~ibuffer~ is a nice way to list buffers for you. We can use it to
track IRC channels in a centralized view, besides using ~C-c C-@~ to
jump between chats. And ~C-c C-a~ to jump to the first unread line.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ibuffer-rcirc
  :config
  (setopt ibuffer-formats
      '((mark modified read-only rcirc-activity-status-one-char " "
          (name 18 18 :left :elide)
          " "
          (size 9 -1 :right)
          " "
          (mode 16 16 :left :elide)
          " "
          (rcirc-activity-status 20 18 :left) " "
          ;; (rcirc-activity-status-mini 5 3 :center) " "
          filename-and-process))))
#+END_SRC
* Minibuffer completion
Currently I'm using ~ido-mode~ to provide completion in the
minibuffer.
~ido-everywhere~ allows you to use ~ido~'s functionality in any function that uses
the minibuffer, not only the ones that are directly supported.

<2023-10-08 Sun> Turns out ~icomplete-mode~ was hogging too much CPU on
large buffers and slowing Emacs down. Then I removed it.
#+BEGIN_SRC emacs-lisp :tangle yes
(ido-mode 1)
(ido-everywhere 1)
(setopt ido-enable-flex-matching nil)
#+END_SRC
* Create scratch buffers
I'm doing this a lot recently. Need to make it faster.
#+begin_src emacs-lisp :tangle yes
;; Stop Ido from prompting me when I want to create a new buffer
  (setopt confirm-nonexistent-file-or-buffer nil)
  ;; For IDO
  (setopt ido-create-new-buffer 'always)
#+end_src
* REPL
We need to do some customizations to comint-related buffers to improve performance.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun comint-mode-tweaks ()
  ;; Font-lock is the one that takes the biggest toll on performance.
  (font-lock-mode -1)
  (auto-composition-mode -1)
  (auto-compression-mode -1)
  (column-number-mode -1)
  (auto-save-visited-mode -1)
  )

(add-hook 'comint-mode-hook 'comint-mode-tweaks)
#+END_SRC

* Abbreviations
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Enable global Abbrev mode
(setq-default abbrev-mode t)

;; Don't ask to save new abbrevs, just save them.
(setopt save-abbrevs 'silently)

;; Location of the abbrev definition file
(setopt abbrev-file-name "~/.abbrev_defs")
  #+END_SRC
* Packages
** Major Modes
*** Markdown-mode
  A couple tweaks to make it more Org-like.
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun markdown-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1))

(use-package markdown-mode
  :hook ((markdown-mode . markdown-mode-tweaks)
     (gfm-mode . markdown-mode-tweaks))
  :bind (:map markdown-mode-map
      ("M-<right>" . 'markdown-demote)
      ("M-<left>" . 'markdown-promote)
      ("M-<up>" . 'markdown-move-up)
      ("M-<down>" . 'markdown-move-down)
      ("C-c 1" . 'markdown-insert-header-atx-1)
      ("C-c 2" . 'markdown-insert-header-atx-2)
      ("C-<return>" . 'auralcat/kmacro-markdown-insert-header-same-level)
      ("C-M-<return>" . 'auralcat/kmacro-markdown-insert-header-nest-one-level)
      ("C-c 3" . 'markdown-insert-header-atx-3))
  :config
  (setopt markdown-fontify-code-blocks-natively t
    markdown-asymmetric-header t
    markdown-header-scaling nil)

  ;; Use fixed-pitch fonts inside code blocks.
  (set-face-attribute 'markdown-code-face nil :inherit 'fixed-pitch))
  #+END_SRC
**** Faces
I couldn't customize this through the ~markdown-header-scaling~ var, so let's try another approach.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/markdown-remap-heading-faces ()
  (face-remap-add-relative 'markdown-header-face-1 :height 2.0)
  (face-remap-add-relative 'markdown-header-face-2 :height 1.7)
  (face-remap-add-relative 'markdown-header-face-3 :height 1.4)
  (face-remap-add-relative 'markdown-header-face-4 :height 1.1)
  (face-remap-add-relative 'markdown-header-face-5 :height 1.0)
  (face-remap-add-relative 'markdown-header-face-6 :height 1.0))

(add-hook 'markdown-mode-hook 'auralcat/markdown-remap-heading-faces)
  #+END_SRC
**** Copy code block contents
This makes it easier for me when reading Markdown files in Emacs to
copy the contents of a code block immediately.

#+begin_src emacs-lisp :tangle yes
(defun markdown-mark-code-block-contents ()
  "Put mark at end of code block contents, point at beginning.
Marks only the text inside the code block delimiters ```."
  (interactive)
  (let (block-start block-end)
    ;; Find start of content (after opening ```)
    (save-excursion
      (when (re-search-backward "^```" nil t)
        (forward-line 1)
        (setopt block-start (point))
        ;; Find end of content (before closing ```)
        (when (re-search-forward "^```" nil t)
          (forward-line -1)
          (end-of-line)
          (setopt block-end (point)))))
    (when (and block-start block-end)
      (goto-char block-start)
      (push-mark block-end)
      (activate-mark)
      t)))

(defun au/markdown-copy-block-content ()
  "Copy the content of the current Markdown code block without moving point."
  (interactive)
  (save-excursion
    (when (markdown-mark-code-block-contents)
      (let ((content (buffer-substring-no-properties (region-beginning) (region-end))))
        (kill-new content)
        (message "Code block content copied to kill ring")
        (deactivate-mark)))))

(define-key markdown-mode-map (kbd "C-c M-w") #'au/markdown-copy-block-content)
#+end_src
*** Web Mode
    I use this for HTML files mostly.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode
  :bind (:map web-mode-map
      ("C-<up>"    . web-mode-element-previous)
      ("C-<down>"  . web-mode-element-next)
      ("C-<left>"  . web-mode-element-beginning)
      ("C-<right>" . web-mode-tag-match)
      ("C-S-<up>"  . web-mode-element-parent)
      ("M-<up>"    . web-mode-element-content-select)
      ("M-RET"     . complete))
  :config
  ;; File associations
  (add-to-list 'auto-mode-alist '(" \\.html.erb\\'"  . web-mode))
  (add-to-list 'auto-mode-alist '(" \\.html.heex\\'" . web-mode))
  (add-to-list 'auto-mode-alist '(" \\.html?\\'"     . web-mode))

  (setopt web-mode-enable-auto-closing t
    web-mode-enable-auto-expanding nil)

  ;; Engine associations
  (setopt web-mode-engines-alist
    '(("php"    . "\\.phtml\\'")
      ("blade"  . "\\.blade\\.")))
  ;; Indentation configuration
  (setopt web-mode-markup-indent-offset 2
    web-mode-css-indent-offset    2
    web-mode-code-indent-offset   2
    web-mode-script-padding       2
    web-mode-style-padding        2)
  ;; Use tidy to check HTML buffers with web-mode.
  (eval-after-load 'flycheck
    '(flycheck-add-mode 'html-tidy 'web-mode))

  ;; Use smartparens with web-mode
  (defun my-web-mode-hook ()
    (setopt web-mode-enable-auto-pairing nil))

  (add-hook 'web-mode-hook  'my-web-mode-hook)

  (defun sp-web-mode-is-code-context (id action context)
    (and (eq action 'insert)
     (not (or (get-text-property (point) 'part-side)
          (get-text-property (point) 'block-side)))))

  (sp-local-pair 'web-mode "<" nil :when '(sp-web-mode-is-code-context))

  ;; Highlight tag when editing
  (setopt web-mode-enable-current-element-highlight t))
    #+END_SRC

*** Compilation mode tweaks
This is a built-in mode, but I want to change some stuff there.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun compilation-mode-tweaks ()
  (visual-line-mode 1)
  (auto-fill-mode -1))

(add-hook 'compilation-mode-hook 'compilation-mode-tweaks)

;; Make the compilation buffer scroll to the end on command finish
(setopt compilation-scroll-output t)

;; Colorize output from compilation-mode
;; Taken from https://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html
(require 'ansi-color)
(defun endless/colorize-compilation ()
  "Colorize from `compilation-filter-start' to `point'."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region
     compilation-filter-start (point))))

(add-hook 'compilation-filter-hook
      #'endless/colorize-compilation)
#+END_SRC
*** Nov-mode
This is a mode for reading .epub files.
It's quite comfortable when you want to read longform books in the computer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nov
  :defer t
  :mode "\\.epub\\'"
  :init
  ;; Set the width to 80 chars, this is better to read.
  (setopt nov-text-width 80)
  ;; Remove the mode line in the book's buffer.
  (add-hook 'nov-mode-hook #'(lambda ()
           (setq-local mode-line-format nil)
           (setq-local show-trailing-whitespace nil)
           )))
#+END_SRC
*** Makefile-mode
I'm working with Makefiles now, so this is useful.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'makefile-mode-hook #'(lambda () (setq-local indent-tabs-mode t)))
#+END_SRC
*** Js2-mode
    A better default Javascript mode
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package js2-mode
  :defer t
  :mode "\\.js?\\'"
  :init
  (setopt js-indent-level 2))

;; Set syntax highlight level
(setopt js2-highlight-level 3)
    #+END_SRC

*** CSV-mode
    CSV support for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package csv-mode
  :defer t)
    #+END_SRC
*** MermaidJS
[[http://mermaid-js.github.io/mermaid/][MermaidJS]] is a Markdown syntax to generate flowcharts and diagrams.
It's quite handy to use whenever you need to explain complex concepts to other people.

To install it, run the command below.
I'm not installing it automatically when Emacs starts because that takes up init time.
#+BEGIN_SRC shell
npm install -g @mermaid-js/mermaid-cli
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mermaid-mode
:mode "\\.mermaid\\'")

(use-package ob-mermaid
  :config
  ;; We need to install the mermaid CLI to be able to compile Mermaid files into diagrams.
  (setopt ob-mermaid-cli-path (string-trim (shell-command-to-string "command -v mmdc"))))
#+END_SRC

***** Play nice with ASDF
I found this manual package called[[https://github.com/tabfugnic/asdf.el/][ asdf.el]] that makes Emacs identify binaries
installed through ASDF in the system.

You just need to make sure that the cloned repo is in your ~load-path~.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/my-dotfiles/.emacs.d/manual-packages/emacs-asdf")
  (require 'asdf)
  (asdf-enable)
#+END_SRC

***** Expand-region
This one is a classic in the Emacs community.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+END_SRC
***** Avy
It's a supercharged version of =ace-jump=, with batteries included and better performance!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package avy
  :config
  (avy-setup-default)
  (global-set-key (kbd "M-g j") 'avy-resume)
  (global-set-key (kbd "M-3") 'avy-goto-char))
#+END_SRC
***** Exec path from shell
  Replicates terminal env vars in graphical Emacs.
  #+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns x))  ; Only use on graphical Linux/macOS
  :config
  ;; Faster startup
  (setopt exec-path-from-shell-check-startup-files nil)
  (setopt exec-path-from-shell-variables '("PATH" "MANPATH"))
  (exec-path-from-shell-initialize))
  #+END_SRC
***** Git-Link
Create links to Github/GitLab files from the comfort of your Emacs buffer.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-link
  :defer t)
#+END_SRC
***** Magit delta
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-delta
  :hook (magit-mode . magit-delta-mode))
#+END_SRC
***** Smartparens
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :hook ((ruby-mode inf-elixir-mode) . 'smartparens-mode)
  :config
  (require 'smartparens-config)
  ;; Remap standard Emacs functions to smartparens equivalents
  (define-key smartparens-mode-map [remap backward-sexp]   'sp-backward-sexp)
  (define-key smartparens-mode-map [remap forward-sexp]    'sp-forward-sexp)
  (define-key smartparens-mode-map [remap kill-sexp]       'sp-kill-sexp)
  (define-key smartparens-mode-map [remap mark-sexp]       'sp-mark-sexp)
  (define-key smartparens-mode-map [remap transpose-sexp]  'sp-transpose-sexp)
  (define-key smartparens-mode-map [remap kill-region]     'sp-kill-region)
  (define-key smartparens-mode-map [remap kill-whole-line] 'sp-kill-whole-line))
#+END_SRC

***** Golden Ratio Mode
    Splits windows using the [[https://en.wikipedia.org/wiki/Golden_ratio][Golden Ratio]].
    This makes the focused window a bit larger than usual and the
    smaller ones are easier to read. It makes the multi-window
    experience more pleasing to the eye. Yeah, nature!
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package golden-ratio
  :diminish golden-ratio-mode
  :config
  (setopt golden-ratio-extra-commands
    (append golden-ratio-extra-commands '(magit-status aw-flip-window)))
  (golden-ratio-mode 1))
    #+END_SRC

***** Restart Emacs
    Restart Emacs from within Emacs
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package restart-emacs
  :defer t)
    #+END_SRC
***** Magit
    How to win at Git from Emacs.
    The configuration for each part is below in separate headings.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package magit
    :defer t
    :hook (git-commit-mode . git-commit-tweaks)
    :custom (git-commit-summary-max-length 50)
    :config
    ;; Highlight what changed in diffs.
    (setopt magit-diff-refine-hunk t)
    ;; 2024-09-06 git-commit is distributed with magit now.
    :preface
    (defun git-commit-tweaks ()
      "Ensures that the commit body does not exceed 72 characters."
      (setopt fill-column 72)
      (setq-local comment-auto-fill-only-comments nil)))
    #+END_SRC
****** Viewing diffs
#+BEGIN_SRC emacs-lisp :tangle yes
;; Wrap those long lines.
(add-hook 'magit-diff-mode-hook 'visual-line-mode)
#+END_SRC
****** Open files for code review
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/magit-open-changed-files-from-main (args)
  "Opens the buffers visiting files that were changed compared to the main branch in the current branch.
   Requires M-x server-start first.

   It's highly recommended to update and pull changes from the remote repository into the master/main branch before running this command."
  (interactive "P")
  (let* ((default-directory (projectile-project-root))
     (git-changed-files-command "git --no-pager diff --name-only main $(git branch --show-current)"))
    (message "Opening changed files in the current branch compared to the master/main branch...")
    (projectile-run-async-shell-command-in-root (format "find $(%s) -exec emacsclient -n {} \\;" git-changed-files-command))))
#+END_SRC
***** Yasnippets
    It originally came with company-mode, it's handy to write faster
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package yasnippet-snippets)
(use-package yasnippet-classic-snippets)

(setopt yas-snippet-dirs
      '("~/.emacs.d/snippets" yasnippet-snippets-dir yasnippet-classic-snippets-dir))

(defun do-not-add-newline-for-snippets ()
  "What is says on the tin."
  (setq-local require-final-newline nil)
  )

(add-hook 'snippet-mode-hook 'do-not-add-newline-for-snippets)
    #+END_SRC
***** Circadian
    Theme changer for Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package circadian
  :config
  (cond
   ((eq system-type 'darwin)
    (setopt circadian-themes '((:sunrise . modus-operandi)
         (:sunset  . modus-vivendi))))
   ;; Personal Linux machine
   ((and (string-equal system-name auralcat/personal-system-name) (eq system-type 'gnu/linux))
    (setopt circadian-themes '((:sunrise . ef-cyprus)
         (:sunset  . ef-maris-dark)))))
  (circadian-setup))
    #+END_SRC

***** Electric pair mode
This _built-in_ mode adds paired characters when you type brackets and
other things.

It's got a better performance than ~smartparens-mode~. Use it when you
don't need any specific features from ~smartparens-mode~.

#+begin_src emacs-lisp :tangle yes
(add-hook 'js-mode-hook 'electric-pair-mode)
(add-hook 'json-mode-hook 'electric-pair-mode)
(add-hook 'outline-mode-hook 'electric-pair-mode)
(add-hook 'markdown-mode-hook 'electric-pair-mode)
#+end_src

***** Auto package update
I honestly don't know why Emacs doesn't support this out of the box yet, but oh well.
You can put ~auto-package-update-async~ in the ~midnight-hook~.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-package-update
  :config
  (auto-package-update-at-time "11:30am")
  (setopt auto-package-update-delete-old-versions t))
#+END_SRC
** Minor Modes
*** Flycheck Inline
    Shows the error when leaving the point over the place where it occurs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-inline
  :defer t
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))
    #+END_SRC
*** Projectile
    Manage projects in Emacs.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :defer t
  :init
  (setopt projectile-keymap-prefix (kbd "C-c p")
    ;; I use Universal ctags, so this needs some adjustment.
    projectile-tags-command "ctags -eR ."
    projectile-switch-project-action 'projectile-vc
    ;; We don't need to be prompted if we want to re-read the tags.
    tags-revert-without-query t)
  (define-key global-map (kbd "C-c p") projectile-command-map))

;; Enable it
(add-hook 'after-init-hook #'projectile-global-mode)
    #+END_SRC
**** Tracking projects
By default, projectile tracks all projects in your machine and runs
~projectile-track-known-projects-find-file-hook~ in the background.

If you are writing in org-mode in a project with more than 1800 files,
this slows down the buffer in GUI Emacs. Here's how to fix that:

#+BEGIN_SRC emacs-lisp :tangle yes
(setopt projectile-track-known-projects-automatically nil)

;; Add the projects you want to track like this:
;; (projectile-add-known-project "~/.emacs.d")
#+END_SRC

*** Keyfreq
    Shows most used commands in editing session.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package keyfreq
  :config
  ;; Ignore arrow commands and self-insert-commands
  (setopt keyfreq-excluded-commands
    '(self-insert-command
      org-self-insert-command
      weechat-self-insert-command
      isearch-printing-char
      markdown-enter-key
      abort-recursive-edit
      lsp-ui-doc--handle-mouse-movement
      ))

  ;; Activate it
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
    #+END_SRC
*** Diminish
    Free some space in the mode line removing superfluous mode indications.
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  :defer t
  ;; These are loaded at startup, I prefer declaring everything here.
  :diminish flycheck-mode
  :diminish projectile-mode
  :diminish auto-revert-mode
  :diminish auto-fill-mode
  :diminish abbrev-mode)
;; These are loaded in other moments
(eval-after-load "editorconfig" '(diminish 'editorconfig-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
    #+END_SRC
** Utilities
*** Deadgrep
Search with ~ripgrep~, this is much faster!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package deadgrep
  :config
  (define-key global-map (kbd "C-c d") 'deadgrep))
#+END_SRC
*** Insert kaomoji
Because kaomoji is fun! ãƒ½(*âŒ’â–½âŒ’*)ï¾‰
#+begin_src emacs-lisp :tangle yes
(use-package insert-kaomoji
  :config
  (define-key global-map (kbd "C-x 8 k") 'insert-kaomoji))
#+end_src
* Custom derived modes
I use those for creating new namespaces for abbrevs or special functions in them
without affecting the respective parent mode.
** Org-English mode
This is a derived mode to hold English abbrevs.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode org-english-mode org-mode "Org-EN"
  "Org-mode used to hold English abbrevs. Does everything that plain org-mode does.")

(add-to-list 'auto-mode-alist '("\\.org\\.en?\\'" . org-english-mode))

;; Disable it for outline-mode derivatives like Markdown and Org.
(add-hook 'org-english-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC
** Livemd mode
This mode was created to offer support for =.livemd= files. These are generated by Livebook.

Livebook uses a special kind of Markdown, but for us there is no change
whatsoever from the usual ~gfm-mode~. It also has special keybindings in the
original implementation to add Elixir, Markdown or Mermaid blocks to the file.
In our case when implementing this in Emacs, we just need a keybinding to add
the Mermaid and Elixir code blocks.

Livebook supports Elixir code as a first class citizen as well as Mermaid diagrams.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode livemd-mode gfm-mode "Livebook"
  "A Markdown-flavored mode for editing Livebook notebook files."
(define-key livemd-mode-map (kbd "C-c e") 'livemd/insert-elixir-block)
(define-key livemd-mode-map (kbd "C-c m") 'livemd/insert-mermaid-block)
(define-key livemd-mode-map (kbd "C-c n") 'markdown-insert-header-atx-2)
(add-to-list '
auto-mode-alist '("\\.livemd?\\'" . livemd-mode))
(add-hook 'livemd-mode-hook #'(lambda () (auto-revert-mode 1)))
(add-hook 'livemd-mode-hook #'(lambda () (auto-save-visited-mode 0))))

(defun livemd/insert-elixir-block (args)
  "Inserts an Elixir code block."
  (interactive "P")
  (markdown-insert-gfm-code-block "elixir" nil))

(defun livemd/insert-mermaid-block (args)
  "Inserts a Mermaid diagram block."
  (interactive "P")
  (markdown-insert-gfm-code-block "mermaid" nil))
#+END_SRC
** Markdown-portuguese mode
An extra namespace for ~markdown-mode~ so I can store abbrevs and ~yasnippet~ snippets in Portuguese for ~markdown-mode~.

I'm leaving this mode to be toggled manually for now.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode markdown-portuguese-mode markdown-mode "Markdown-PT"
  "Markdown-mode used to hold Portuguese abbrevs. Does everything that plain markdown-mode does."
  (setq-local ispell-local-dictionary "pt_BR"))

(add-hook 'markdown-portuguese-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC

** Gfm-portuguese mode
An extra namespace for ~gfm-mode~ so I can store abbrevs and ~yasnippet~ snippets in Portuguese for ~gfm-mode~.

I'm leaving this mode to be toggled manually for now.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-derived-mode gfm-portuguese-mode gfm-mode "Gfm-PT"
  "Gfm-mode used to hold Portuguese abbrevs. Does everything that plain gfm-mode does."
  (setq-local ispell-local-dictionary "pt_BR"))

(add-hook 'gfm-portuguese-mode-hook #'(lambda () (auto-save-visited-mode 0)))
#+END_SRC

* Org-mode
** Main configuration
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; Allow alphabetical lists please
          (setopt org-list-allow-alphabetical t)
     (define-key global-map (kbd "C-c a") 'org-agenda)
     (define-key global-map (kbd "C-c k") 'org-capture)

     (setopt org-hierarchical-todo-statistics nil
       org-src-fontify-natively t
       org-todo-keywords '((sequence "TODO" "DONE"))
       org-agenda-scheduled-leaders '("Scheduled: " "Sched. previously %2dx: ")
       org-agenda-skip-scheduled-if-done t
       org-agenda-start-on-weekday 0)

     ;; Start indented.
     ;; (setopt org-startup-indented t)

     ;; Change the end of collapsed headings to an arrow.
     (setopt org-ellipsis "â¤µ")

     ;; Don't split my lines, thx.
     (setopt org-M-RET-may-split-line nil)

     ;; Truncate long task names
     (setopt org-clock-heading-function
       #'(lambda ()
     (let ((str (nth 4 (org-heading-components))))
       (concat (truncate-string-to-width str 27) "...")
       )))

     ;; Organize the bindings
     ;; Open subheading with C-c RET and invert with M-RET
     (define-key org-mode-map (kbd "C-c RET") 'org-ctrl-c-ret)
     (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-subheading)

     ;; Use C-RET to complete words in Org-mode
     (define-key org-mode-map (kbd "C-RET") 'complete)

     ;; Map C-S-enter to org-insert-todo-subheading
     (define-key org-mode-map (kbd "<C-S-return>") 'org-insert-todo-subheading)

     ;; Dummy-proofing my configs
     (define-key org-mode-map (kbd "C-c ]") nil)
     (define-key org-mode-map (kbd "C-c [") nil)

     ;; Log when a task was done and when it was rescheduled.
     (setopt org-log-done 'time)
     (setopt org-log-reschedule 'time)

     ;; Don't write inside invisible area when collapsing headings!
     (setopt org-catch-invisible-edits 'error)

     ;; Refile items to the same buffer along with the agenda files
     (setopt org-refile-targets '((nil :maxlevel . 3)
                                (org-agenda-files :maxlevel . 3)))
   #+END_SRC

** Tables
Use the fixed-pitch font for tables.
#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
#+END_SRC
** Capture templates
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Load them from a separate file.
(load "~/.org-capture-templates.el")
   #+END_SRC

** Quick capture to inbox
Borrowed and adapted from https://macowners.club/posts/org-capture-from-everywhere-macos/#capture-an-url-from-safari
#+begin_src emacs-lisp :tangle yes
(defun timu-func-make-capture-frame ()
  "Create a new frame and run `org-capture'."
  (interactive)
  (make-frame '((name . "capture")
        (top . 300)
        (left . 700)
        (width . 80)
        (height . 25)))
  (select-frame-by-name "capture")
  (delete-other-windows)
  (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
    ;; Customize your org-capture function here
      (org-capture nil "i")))

(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame."
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame."
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))
#+end_src

** Org-agenda configuration
Colorize the agenda: https://llazarek.com/2018/07/improving-the-agenda.html
#+BEGIN_SRC emacs-lisp :tangle yes
;; Display holidays from calendar into agenda
(setopt org-agenda-include-diary t)

;; Set agenda as sticky. This makes the buffers persistent, and load faster if
;; you open them all the time.
(setopt org-agenda-sticky t)

;; Keep agenda file list in a single file so I can publish my config.
;; DO NOT use C-c [ or C-c ] to add/remove files to the agenda otherwise
;; Emacs will write the var to init.el
(setopt org-agenda-files "~/file-bouncer/org-agenda-file-list.org")

(defun ll/org/agenda/color-headers-with (tag fg-col bg-col)
  "Color agenda lines matching TAG with color FG-COL."
  (interactive)
  (goto-char (point-min))
  (while (re-search-forward tag nil t)
    (unless (find-in-line "\\[#[A-Z]\\]")
      (let ((todo-end (or (ll/org/agenda/find-todo-word-end)
          (point-at-bol)))
    (tags-beginning (or (find-in-line " :" t)
        (point-at-eol))))
    (add-text-properties todo-end
         tags-beginning
         `(face (:foreground ,fg-col :background ,bg-col)))))))

;; Helper definitions
(setopt ll/org/agenda-todo-words
      '("TODO" "GOAL" "NEXT" "STARTED" "WAITING" "REVIEW" "SUBMIT"
    "DONE" "DEFERRED" "CANCELLED"))
(defun find-in-line (needle &optional beginning count)
  "Find the position of the start of NEEDLE in the current line.
  If BEGINNING is non-nil, find the beginning of NEEDLE in the current
  line. If COUNT is non-nil, find the COUNT'th occurrence from the left."
  (save-excursion
    (beginning-of-line)
    (let ((found (re-search-forward needle (point-at-eol) t count)))
      (if beginning
      (match-beginning 0)
    found))))
(defun ll/org/agenda/find-todo-word-end ()
  (reduce (lambda (a b) (or a b))
      (mapcar #'find-in-line ll/org/agenda-todo-words)))

;; Load my tag colors
(load "~/.agenda-colors")
#+END_SRC
*** Custom agenda commands
#+BEGIN_SRC emacs-lisp :tangle yes
(setopt org-agenda-custom-commands
      '(("i" "Inbox items"
    ((tags "inbox")))))
#+END_SRC
** Org-babel
*** General settings
- Do not ask me if I want to run the source block
- Output the results in _scripting_ mode, instead of eval mode.
- Wrap them in an example block (for exporting)
  Important: the default header args will be:
  =:noweb :results output verbatim replace :exports both=
- Also display the contents of the source code block in a monospace font when possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-org-confirm-babel-evaluate (lang body)
  "Don't confirm squat."
  (not (member lang '("sh" "elisp" "ruby" "elixir" "shell"))))

;; A few more tweaks for org-babel.
(setopt org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate
      org-src-preserve-indentation t
      org-babel-min-lines-for-block-output 1
      org-babel-default-header-args
      (cons '(:noweb . "yes")
    (assq-delete-all :noweb org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:exports . "both")
    (assq-delete-all :exports org-babel-default-header-args))
      org-babel-default-header-args
      (cons '(:results . "output verbatim replace")
    (assq-delete-all :results org-babel-default-header-args)))
#+END_SRC
*** ob-async
This is to run org source code blocks asynchronously.
Backends like Python implement their own asynchronous way of running
things, so you need to add extra configuration when using them.
Not the case right now, though.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-async)
#+END_SRC

*** Elixir
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-elixir)
    #+END_SRC
*** Load languages
    #+BEGIN_SRC emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (shell . t)
   (python . t)
   (sql . t)
   (ruby . t)
   (elixir . t)
   (plantuml . t)
   (dot . t)))
    #+END_SRC
*** CUSTOM: Copy block content
I'm seeing code displayed in browser UIs lately. I noticed that they
have a button to copy the contents of the code block. That is very
useful to me since I need to copy code often. I would like to have
this same feature in org-mode as well.

#+begin_src emacs-lisp :tangle yes
(defun au/org-babel-copy-block-content ()
  "Copy the content of the current org-babel source block without moving point."
  (interactive)
  (save-excursion
    (when (org-babel-mark-block)
      (let ((content (buffer-substring-no-properties (region-beginning) (region-end))))
        (kill-new content)
        (message "Source block content copied to kill ring")
        (deactivate-mark)))))

(define-key org-mode-map (kbd "C-c C-v M-w") #'au/org-babel-copy-block-content)
#+end_src

* Function Aliases
  #+BEGIN_SRC emacs-lisp :tangle yes
;; This is how you define aliases for Elisp functions. These are useful for when
;; you don't need to bind a command to a specific key, but you call that
;; function through M-x often.
(defalias 'plp 'package-list-packages)
(defalias 'kfs 'keyfreq-show)
  #+END_SRC
* PDFs
You also need to compile ~epdfinfo~ in Emacs for this to work.
Run it with ~(pdf-tools-install)~.
#+begin_src emacs-lisp :tangle yes
(use-package pdf-tools
  :init
  ;; Open PDF files with pdf-view-mode
  (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode)))
#+end_src
* Themes
  Remember to _defer_ the loading of the theme packages, otherwise the
  faces might get mixed up and look ugly.

  This function makes it easier to change themes quickly. You can bind it to a
  keychord or whatnot and use it as you wish.

  NOTE: If you want to run extra functions when changing themes,
  *you should add the function calls to the change theme function below*,
  otherwise the changes you want to happen won't take effect!
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/set-fringe-face-to-default-bg ()
  "Sets the fringe's background to the current theme's background color for the 'default face."
  (set-face-attribute 'fringe nil :background (face-attribute 'default :background)))

;; Set the fringe face function Circadian's change hook.
;; That way whenever the theme changes automatically, the fringe gets updated as
;; well.
(add-hook 'circadian-after-load-theme-hook 'auralcat/set-fringe-face-to-default-bg)

(defun auralcat/change-theme (new-theme)
  "Disables the current theme in the session, loads and enables the NEW-THEME."
  ;; This is the code Emacs uses to load themes in custom.el
  (interactive
   (list
    (intern (completing-read "Change to theme: "
         (mapcar #'symbol-name
             (custom-available-themes))))))
  (let* (
     (current-theme (car custom-enabled-themes))
     (new-theme-loaded-p (memq new-theme custom-enabled-themes)))
    (disable-theme current-theme)
    (if new-theme-loaded-p
    (enable-theme new-theme)
      (load-theme new-theme))
    ;; We should do this here because not every theme defines a fringe face and
    ;; I customized the fringe on my end.
    (auralcat/set-fringe-face-to-default-bg))
  ;; We should also set the preferred fonts here because this function does not
  ;; run any hooks.
  (auralcat--set-preferred-fonts-for-current-theme))

;; Add the hook on circadian
;; Bind it to a keychord.
(global-set-key (kbd "M-`") 'auralcat/change-theme)
  #+END_SRC
** Modus themes customization
The ~modus-themes~ come with Emacs since version 28, so you don't need
to install it through ~use-package~ anymore.

#+BEGIN_SRC emacs-lisp :tangle yes
(setopt modus-themes-deuteranopia t)
(setopt modus-themes-syntax '(green-strings)
      modus-themes-mode-line '(3d accented borderless)
      modus-themes-diffs 'desaturated)
#+END_SRC

** Abyss
   Dark contrast theme
   #+BEGIN_SRC emacs-lisp :tangle yes
   #+END_SRC
** Twilight Bright
   A port of the theme from TextMate.
   #+BEGIN_SRC emacs-lisp :tangle yes
(use-package twilight-bright-theme :defer t)
   #+END_SRC
** Gruvbox
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gruvbox-theme :defer t)
#+END_SRC
** Solarized themes
These are the official ones.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package solarized-theme :defer t)
#+END_SRC
** Zenburn
The Zenburn theme is the only theme I found so far that is _balanced
enough_ for both light and dark settings!

#+begin_src emacs-lisp :tangle yes
(use-package zenburn-theme)
#+end_src
* Fonts
It's better to set the fonts here instead of hard-coding them in init.el or in
the themes themselves.
** Default
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set fonts for each system if the extra ones are installed.
;; Otherwise use the system's default fonts.
(defun auralcat--set-fixed-pitch-fonts (font-name height)
  "Sets the fixed pitch fonts with the FONT-NAME family and the height as HEIGHT for both the 'default and 'fixed-pitch faces."
  (set-face-attribute 'default nil :family font-name :height height)
  (set-face-attribute 'fixed-pitch nil :family font-name :height height)
  (set-face-attribute 'org-block nil :family font-name :height height)
  (set-face-attribute 'org-table nil :family font-name :height height))

(defun auralcat--set-preferred-fonts-for-current-theme ()
  "Sets the preferred fonts for the current theme depending on the system Emacs is used in."
  (cond
   ((eq system-type 'darwin)
    (if (font-info "B612 Mono")
    (auralcat--set-fixed-pitch-fonts "B612 Mono" 90)
      (auralcat--set-fixed-pitch-fonts "Monaco" 120)))
   ((eq system-type 'gnu/linux)
    ;; Pure GTK Emacs does not play well with multiple frames.
    ;; This is not a problem for the personal setup, but I use 2 displays at work.
    (auralcat--set-fonts-for-gnu-linux 120))))

(defun auralcat--set-fonts-for-gnu-linux (height)
  "Sets fonts for GNU/Linux machines with HEIGHT."
  (if (font-info "monofur")
      (auralcat--set-fixed-pitch-fonts "monofur" height)
    (auralcat--set-fixed-pitch-fonts "Ubuntu Mono" height)))

;; Use Helvetica as the sans-serif font when available.
(when (font-info "Helvetica")
    (set-face-attribute 'variable-pitch nil :family "Helvetica" :height 120)
    ;; Use the Helvetica font as well for Emacs 29 mode line.
    (set-face-attribute 'mode-line nil :family "Helvetica"))

  #+END_SRC

* Graphical
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set font in graphical mode
(when (display-graphic-p)
  ;; Remove menu and scroll bars in graphical mode
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  ;; Maximize frame on startup
  (toggle-frame-maximized)
  ;; Space lines and bask in the gloriousness of graphical mode.
  (setopt line-spacing 0.2))
  #+END_SRC
* Multiplexing
This involves window and tab management.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Set rules for displaying buffers in windows.
(setopt display-buffer-alist
      ;; Press q in the Magit buffer and the window vanishes!
      `(("^magit: .*$"
     (display-buffer-reuse-mode-window display-buffer-reuse-window display-buffer-at-bottom)
     (window-height . 0.5)
     (window-parameters . ((delete-window . t)))
     )
    ("^magit-diff: .*$"
     (display-buffer-use-some-frame display-buffer-reuse-mode-window display-buffer-reuse-window)
     (reusable-frames . t)
     (window-parameters . ((delete-window . t)))
     )
    ("^magit-revision: .*$"
     (display-buffer-reuse-mode-window display-buffer-reuse-window display-buffer-use-some-frame)
     (reusable-frames . t)
     (window-parameters . ((delete-window . t)))
     )
    ;; Search buffers tend to be more useful when they're in the same frame as the code.
    ("\\(^\\*ag search text:.*\\*$\\|\\^*Occur.*\\*$\\)"
     (display-buffer-reuse-mode-window display-buffer-reuse-window)
     )
    ("^\\*Org .*Export\\*$"
     (display-buffer-reuse-window display-buffer-in-side-window)
     (window-height . 0.5)
     (window-parameters . ((delete-window . t)))
     )))
#+END_SRC

* Keybindings
** Translation keymap
The keys in my personal machine are bound to the corresponding
bindings using ~AltGr~ so this is necessary to use the Meta key on the
right button as well.

 #+BEGIN_SRC emacs-lisp :tangle yes
;; Translate the compose keys
(define-key key-translation-map (kbd "Â¹") (kbd "M-1"))
(define-key key-translation-map (kbd "Â²") (kbd "M-2"))
(define-key key-translation-map (kbd "Â³") (kbd "M-3"))
(define-key key-translation-map (kbd "Â£") (kbd "M-4"))
(define-key key-translation-map (kbd "Â¢") (kbd "M-5"))
(define-key key-translation-map (kbd "Ã°") (kbd "M-d"))
(define-key key-translation-map (kbd "ÃŸ") (kbd "M-s"))
(define-key key-translation-map (kbd "Â»") (kbd "M-x"))
(define-key key-translation-map (kbd "Â«") (kbd "M-z"))
(define-key key-translation-map (kbd "C-Â«") (kbd "C-M-z"))
(define-key key-translation-map (kbd "C-Â»") (kbd "C-M-x"))
(define-key key-translation-map (kbd "Å‹") (kbd "M-g"))
(define-key key-translation-map (kbd "<M-S-dead-grave>") (kbd "M-`"))
(define-key key-translation-map (kbd "â€œ") (kbd "M-v"))
(define-key key-translation-map (kbd "â€˜") (kbd "M-S-v"))
(define-key key-translation-map (kbd "C-â€œ") (kbd "C-M-v"))
(define-key key-translation-map (kbd "C-â€˜") (kbd "C-S-M-v"))
(define-key key-translation-map (kbd "Ã¦") (kbd "M-a"))
(define-key key-translation-map (kbd "C-Ã¦") (kbd "C-M-a"))
(define-key key-translation-map (kbd "Å§") (kbd "M-t"))
(define-key key-translation-map (kbd "C-Å§") (kbd "C-M-t"))
(define-key key-translation-map (kbd "Ã†") (kbd "M-S-a"))
(define-key key-translation-map (kbd "Â°") (kbd "M-e"))
(define-key key-translation-map (kbd "C-Â°") (kbd "C-M-e"))
(define-key key-translation-map (kbd "Ä‘") (kbd "M-f"))
(define-key key-translation-map (kbd "Âª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "C-Ä‘") (kbd "C-M-f"))
(define-key key-translation-map (kbd "C-Âª") (kbd "M-S-f"))
(define-key key-translation-map (kbd "â€") (kbd "M-b"))
(define-key key-translation-map (kbd "â€™") (kbd "M-S-b"))
(define-key key-translation-map (kbd "C-â€") (kbd "C-M-b"))
(define-key key-translation-map (kbd "C-â€™") (kbd "C-M-S-b"))
(define-key key-translation-map (kbd "Â©") (kbd "M-c"))
(define-key key-translation-map (kbd "C-Â©") (kbd "C-M-c"))
(define-key key-translation-map (kbd "C-ÃŸ") (kbd "C-M-s"))
(define-key key-translation-map (kbd "C-Â®") (kbd "C-M-r"))
(define-key key-translation-map (kbd "Â®") (kbd "M-r"))
(define-key key-translation-map (kbd "M-Â°") (kbd "M-S-e"))
;; C-M-number translations.
(define-key key-translation-map (kbd "â…œ") (kbd "M-%"))
(define-key key-translation-map (kbd "C-â…œ") (kbd "C-M-%"))
(define-key key-translation-map (kbd "Â¼") (kbd "M-$"))
(define-key key-translation-map (kbd "C-Â¼") (kbd "C-M-$"))
(define-key key-translation-map (kbd "Â¾") (kbd "M-#"))
(define-key key-translation-map (kbd "C-Â¾") (kbd "C-M-#"))
(define-key key-translation-map (kbd "Â½") (kbd "M-@"))
(define-key key-translation-map (kbd "C-Â½") (kbd "C-M-@"))
(define-key key-translation-map (kbd "Â¡") (kbd "M-!"))
(define-key key-translation-map (kbd "C-Â¡") (kbd "C-M-!"))

;; Some speed commands
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'ido-switch-buffer)
(global-set-key (kbd "M-4") 'switch-to-buffer-other-window)
(global-set-key (kbd "M-5") 'tab-bar-switch-to-tab)

(define-key comint-mode-map (kbd "M-1") 'delete-other-windows)
(define-key comint-mode-map (kbd "M-4") 'switch-to-buffer-other-window)

;; Improve the case change commands with built-in DWIM
(global-set-key (kbd "M-u") 'upcase-dwim)
(global-set-key (kbd "M-l") 'downcase-dwim)
(global-set-key (kbd "M-c") 'capitalize-dwim)

;; Resize the frame with ease
(global-set-key [M-f11] (quote toggle-frame-fullscreen))
(global-set-key [M-f10] (quote toggle-frame-maximized))

(global-set-key (kbd "M-\"") (quote abbrev-prefix-mark))

;; Switch windows and frames
(define-key global-map (kbd "M-o") 'other-window)

;; Scroll other windows' pages easier
(define-key global-map (kbd "M-]") 'scroll-other-window)
(define-key global-map (kbd "M-[") 'scroll-other-window-down)

;; Unfill region
(define-key global-map "\C-\M-q" 'unfill-region)

;; Mapping AltGr-d to delete-other-windows,
;; Another symbol I don't use often.
(global-set-key [240] (quote delete-other-windows))

;; Map the Home and End keys to go to the beginning and end of the buffer
(global-set-key [home] (quote beginning-of-buffer))
(global-set-key [end] (quote end-of-buffer))

;; Move to beginning of line or indentation
(defun back-to-indentation-or-beginning (args)
  (interactive "P")
  (if (= (point) (progn (back-to-indentation) (point)))
      (beginning-of-line args)))

;; We need this to get back to the beginning of the indentation or first word of the line.
(global-set-key (kbd "C-a") (quote back-to-indentation-or-beginning))

;; Hippie-Expand: change key to M-SPC; Replace dabbrev-expand
(global-set-key "\M- " 'hippie-expand)
(global-set-key "\M-/" 'hippie-expand)

;; Use replace-string instead of query-replace in M-%
(global-set-key "\M-%" 'replace-string)
  #+END_SRC

** Personal keymap
I need these keybindings to call quick functions I use often.

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar auralcat-map
  (let ((map (make-sparse-keymap)))
    ;; Your keybindings go here.
    (define-key map (kbd "fo") #'(lambda () (find-file "~/.emacs.d/myinit.org")))
    (define-key map (kbd "fs") #'(lambda () (switch-to-buffer (get-buffer "*scratch*"))))
    (define-key map (kbd "fm") #'(lambda () (switch-to-buffer (get-buffer "*Messages*"))))
    (define-key map (kbd "j") 'jump-to-register)
    (define-key map (kbd "p") 'projectile-command-map)
    map)
  "My personal keymap.")

(global-set-key (kbd "C-\\") auralcat-map)
#+END_SRC

** Remappings
#+BEGIN_SRC emacs-lisp :tangle yes
;; I use zap-up-to-char much more than zap-to-char.
(define-key global-map (kbd "M-z") 'zap-up-to-char)
(define-key global-map (kbd "C-M-z") 'zap-to-char)
;; More navigation aids that are not bound to any key by default
(define-key global-map (kbd "M-g ,") 'goto-last-change-reverse)
(define-key global-map (kbd "M-g .") 'goto-last-change)
(define-key global-map (kbd "M-g u") 'browse-url)
#+END_SRC

** Duplicate line
This is available out of the box from Emacs 29 forward.
If you're using Emacs 28 or lower, you can backport this function like so:
#+BEGIN_SRC emacs-lisp :tangle yes
(when (>= (string-to-number emacs-version) 29)
  (defun duplicate-line (&optional n)
    "Duplicate the current line N times.
+Also see the `copy-from-above-command' command."
    (interactive "p")
    (let ((line (buffer-substring (line-beginning-position)
                  (line-end-position))))
      (save-excursion
    (forward-line 1)
    (unless (bolp)
      (insert "\n"))
    (dotimes (_ n)
      (insert line "\n"))))))

(define-key global-map (kbd "C-S-d") 'duplicate-line)
#+END_SRC

** Append to buffer
Buffers are the common communication medium in Emacs. Make it easier for you to use them!
#+begin_src emacs-lisp :tangle yes
(define-key global-map (kbd "C-x x a") 'append-to-buffer)
#+end_src
* Variables
  #+BEGIN_SRC emacs-lisp :tangle yes
;; Set Fundamental mode as default mode for new buffers:
(setq-default major-mode 'fundamental-mode)
(setopt initial-major-mode 'fundamental-mode)

;; When toggling a buffer into read-only mode, activate view-mode immediately.
(setopt view-read-only t)

;; Change tab width and change tabs to spaces
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)

;; Making Emacs auto-indent
(define-key global-map (kbd "RET") 'newline-and-indent)

;; Shows trailing whitespace, if any:
(setq-default show-trailing-whitespace t)

;; Python: use python3 as default shell interpreter
(setopt python-shell-interpreter "python3")

  #+END_SRC
** Project-local variables
Disable the ~risky-variable~ check. I know what I'm doing.
This can be reverted later with ~(advice-remove)~ though.
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add 'risky-local-variable-p :override #'ignore)
#+END_SRC
* Repeat-mode maps
These are for the new ~repeat-mode~ added to Emacs 28.
First we need to enable repeat-mode globally:

#+BEGIN_SRC emacs-lisp :tangle yes
(repeat-mode 1)

;; We're also defining a macro to reduce code duplication in this config.
(defmacro auralcat/macro-make-map-for-repeat-commands (map-symbol key-commands-alist)
  (require 'cl-lib)
  `(setopt ,map-symbol
     (let ((map (make-sparse-keymap)))
       (cl-loop for (key . command) in ,key-commands-alist
        do (define-key map (kbd key) command)
        (put command 'repeat-map ',map-symbol))
       map)))
#+END_SRC

** General
#+BEGIN_SRC emacs-lisp :tangle yes
;; TODO: undo-redo is not loaded on startup through this macro. Need to figure out why.
(auralcat/macro-make-map-for-repeat-commands undo-repeat-map
                         '(("u" . undo)
                           ("r" . undo-redo)))

;; TODO: why are these keys not bound to scroll-up-command and scroll-down-command?
(auralcat/macro-make-map-for-repeat-commands scroll-map
                         '(("n" . scroll-up-command)
                           ("p" . scroll-down-command)))

(auralcat/macro-make-map-for-repeat-commands scroll-other-window-map
                         '(("]" . scroll-other-window)
                           ("[" . scroll-other-window-down)))

(auralcat/macro-make-map-for-repeat-commands control-meta-navigation-map
                         '(("n" . forward-list)
                           ("p" . backward-list)
                           ("a" . beginning-of-defun)
                           ("e" . end-of-defun)
                           ("f" . forward-sexp)
                           ("b" . backward-sexp)))

(auralcat/macro-make-map-for-repeat-commands goto-change-map
                         '(("." . goto-last-change)
                           ("," . goto-last-change-reverse)))
#+END_SRC

** Org-mode repeat maps
#+BEGIN_SRC emacs-lisp :tangle yes
(auralcat/macro-make-map-for-repeat-commands org-link-repeat-map
                         '(("n" . org-next-link)
                           ("p" . org-previous-link)))

(auralcat/macro-make-map-for-repeat-commands org-heading-navigation-map
                         '(("n" . org-next-visible-heading)
                           ("p" . org-previous-visible-heading)
                           ("f" . org-forward-heading-same-level)
                           ("b" . org-backward-heading-same-level)))
#+END_SRC

** Markdown repeat maps
#+BEGIN_SRC emacs-lisp :tangle yes
(auralcat/macro-make-map-for-repeat-commands markdown-heading-repeat-map
                         '(("n" . markdown-outline-next)
                           ("p" . markdown-outline-previous)
                           ("f" . markdown-outline-next-same-level)
                           ("b" . markdown-outline-previous-same-level)))
#+END_SRC

* Custom functions
** Auto create missing directories
Taken from https://emacsredux.com/blog/2022/06/12/auto-create-missing-directories/
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun er-auto-create-missing-dirs ()
  (let ((target-dir (file-name-directory buffer-file-name)))
    (unless (file-exists-p target-dir)
      (make-directory target-dir t))))

(add-to-list 'find-file-not-found-functions #'er-auto-create-missing-dirs)
   #+END_SRC

** Calculate leap year
   #+BEGIN_SRC emacs-lisp :tangle yes
(defun is-leap-year (year)
  "Checks if the given YEAR is a leap year"
  (interactive "P")
  (or
   (and (not (eq (% year 100) 0))
    (eq (% year 4) 0))
   (eq (% year 400) 0))
  )

   #+END_SRC
** Unfill region
   #+BEGIN_SRC emacs-lisp :tangle yes
;; Unfill region, AKA leave single huge line
(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
       logical line.  This is useful, e.g., for use with
       `visual-line-mode'."
  (interactive "*r")
  (let ((fill-column (point-max)))
    (fill-region beg end)))
   #+END_SRC
** COMMENT Read value from environment variables
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/get-env-var (env-var-name)
  "This is a way to work around how the system interprets environment variables
to read them in real time. It returns the value under ENV-VAR-NAME in your shell init files.

You just need to change the env var value (or add the key) in .bash_profile and
this function will pick it up."
 (shell-command-to-string (format "$SHELL --login -c 'echo -n $%s'" env-var-name)))
#+END_SRC
** Copy text from prog-modes into Markdown code block
This is useful when you want to copy some lines of code from Emacs to paste on Github comments or in a chat tool. That way you don't have to type `s and paste the text in there. Makes the process much smoother and faster.

#+NAME: auralcat/prog-copy-region-in-named-gfm-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-named-gfm-code-block (beg end)
  "Copy the selected region inside a named GFM code block with the major mode name to the clipboard."
  (interactive (if (use-region-p)
           (list (region-beginning) (region-end))
         (list nil nil)))
  (let ((major-mode-basename (string-replace "-mode" "" (prin1-to-string major-mode)))
    (region-raw-string (buffer-substring-no-properties beg end)))
      (kill-new (format "```%s
%s
```" major-mode-basename region-raw-string))
  (message (format "Region copied to clipboard inside GFM %s code block!" major-mode-basename))))
#+END_SRC

The ~diff~ block is handy when you want to highlight a single line of code when explaining things in GitHub.

#+NAME: auralcat/prog-copy-region-in-diff-md-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-diff-gfm-code-block (beg end)
  "Copy the selected region inside a GFM `diff` code block to the clipboard.

   This is useful to highlight a single line in your message or comment."
  (interactive (if (use-region-p)
           (list (region-beginning) (region-end))
         (list nil nil)))
  (kill-new (format "```%s
%s
```" "diff" (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside GFM `diff` code block!"))
#+END_SRC

We can also create the special ~suggestion~ GFM code block here. This is interpreted by GitHub as a code suggestion that the author of the pull request can incorporate into the branch with a single click. This makes the process of applying suggestions much faster and painless.

#+NAME: auralcat/prog-copy-region-in-suggestion-gfm-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-suggestion-gfm-code-block (beg end)
  "Copy the selected region inside a `suggestion` GFM code block with the major mode name to the clipboard.

  This block is interpreted by GitHub as a suggestion to the pull request, so the author or maintainers can apply the suggestions to the branch with a single click."
  (interactive (if (use-region-p)
           (list (region-beginning) (region-end))
         (list nil nil)))
  (kill-new (format "```%s
%s
```" "suggestion" (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside a `suggestion` GFM code block!"))
#+END_SRC

For other cases where GFM code blocks don't get interpreted correctly, we can use the plain fenced Markdown code block:

#+NAME: auralcat/prog-copy-region-in-plain-md-code-block
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/prog-copy-region-in-plain-md-code-block (beg end)
  "Copy the selected region inside a plain Markdown code block."
  (interactive (if (use-region-p)
           (list (region-beginning) (region-end))
         (list nil nil)))
  (kill-new (format "```
%s
```"  (buffer-substring-no-properties beg end)))
  (message "Region copied to clipboard inside plain Markdown code block!"))
#+END_SRC
** Open a new line before point
Just like O in Vim.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/open-line (args)
  (interactive "p")
  "Inserts a new line before the line where point is.
   Keeps point in the same column as it was before."
  (save-excursion
    (move-beginning-of-line 1)
    (newline args)))

(global-set-key (kbd "C-o") 'auralcat/open-line)
#+END_SRC
* Speed dial files
# TODO: If we add more files in here, we can create a generic function
# to speed dial through files!

** This config file
We need to have access to this file on speed dial.
This is a huge quality of life improvement!
#+begin_src emacs-lisp :tangle yes
(defun auralcat/open-config-file ()
  "Opens your Emacs configuration file."
  (interactive)
  ;; This is how you check if a buffer is opened.
  (if (buffer-live-p (get-buffer "myinit.org"))
      (switch-to-buffer "myinit.org")
    ;; If the buffer is not open, visit the file
    (find-file "~/.emacs.d/myinit.org")))

;; We also need to bind this to a key
(global-set-key (kbd "M-g e") 'auralcat/open-config-file)
(global-set-key (kbd "M-g M-e") 'auralcat/open-config-file)
#+end_src
** Secrets file
#+begin_src emacs-lisp :tangle yes
(defun auralcat/open-secrets-file ()
  "Opens your Emacs secrets file."
  (interactive)
  ;; This is how you check if a buffer is opened.
  (if (buffer-live-p (get-buffer ".emacs.secrets"))
      (switch-to-buffer ".emacs.secrets")
    ;; If the buffer is not open, visit the file
    (find-file "~/.emacs.secrets")))

;; We also need to bind this to a key
(global-set-key (kbd "M-g s") 'auralcat/open-secrets-file)
(global-set-key (kbd "M-g M-s") 'auralcat/open-secrets-file)
#+end_src

* Mode Line
** VC mode customizations
#+BEGIN_SRC emacs-lisp :tangle yes
(advice-add #'vc-git-mode-line-string :filter-return #'my-replace-git-status)
(defun my-replace-git-status (tstr)
  (let* ((tstr (replace-regexp-in-string "Git" "" tstr))
     (first-char (substring tstr 0 1))
     (rest-chars (substring tstr 1)))
    (cond
     ((string= ":" first-char) ;;; Modified
      (replace-regexp-in-string "^:" "âš¡ï¸" tstr))
     ((string= "-" first-char) ;; No change
      (replace-regexp-in-string "^-" "âœ”ï¸" tstr))
     (t tstr))))
#+END_SRC
** Custom code
[[https://github.com/rnkn/olivetti/issues/39#issuecomment-660606677][Source]]
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mode-line-align (left right)
  "Return a string with LEFT and RIGHT at the edges of the
  current window."
  (format (format "%%s %%%ds" (- (window-total-width) (length left) 2))
      left right))

(setopt auralcat/mode-line-left-side
      ;; This should be a quoted list if you want values to be updated
      ;; when things change in the buffer.
      '(
    " " mode-line-buffer-identification
    " " mode-line-modified
    " " mode-name
    " " mode-line-position
    " " (vc-mode vc-mode)
    ))

(setopt auralcat/mode-line-right-side
      (list minor-mode-alist
    " " mode-line-misc-info
    " " mode-line-end-spaces))

;; This needs to be setq-default to make every buffer use this mode line format.
(setq-default mode-line-format
      '("%e" (:eval (mode-line-align
     (format-mode-line
      auralcat/mode-line-left-side)
     (format-mode-line
      auralcat/mode-line-right-side)))))
#+END_SRC
* Scratch tabs (inspired by Tot)
I'm experimenting this idea inspired by the Tot application on Mac.
It's essentially fancy temp buffers with Markdown.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun make-tot-tab (i tab-name)
  "Creates a new Tot tab using org-mode."
  (tab-bar-new-tab)
  ;; I'm using org-mode way more than Markdown. Let's default to it.
  (find-file (format "/tmp/tot/%s.org.en" tab-name))
  (tab-bar-rename-tab (format "*%s*" tab-name)))
#+END_SRC

We also need a better way to navigate among tabs for this.
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key global-map (kbd "C-x t >") 'tab-bar-switch-to-last-tab)
;; Move to first tab
(define-key global-map (kbd "C-x t <") #'(lambda (args) (interactive "P") (tab-bar-switch-to-last-tab 99)))
(define-key global-map (kbd "M-g t") 'tab-bar-switch-to-recent-tab)
#+END_SRC
* Cursor
#+BEGIN_SRC emacs-lisp :tangle yes
(defun auralcat/get-face-foreground-color (face)
  "Return the hex code from the specified FACE."
  (face-attribute face :foreground))

(add-hook 'circadian-after-load-theme-hook #'(lambda (theme) (auralcat--set-preferred-fonts-for-current-theme)))
(add-hook 'after-init-hook #'(lambda () (auralcat--set-preferred-fonts-for-current-theme)))

(setq-default blink-cursor-blinks 0)
(setq-default blink-cursor-interval 0.6)
(setq-default blink-cursor-delay 0.2)
#+END_SRC
